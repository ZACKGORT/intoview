<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Physics Scene</title>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>
  <script src="https://cdn.babylonjs.com/cannon.js"></script>
  
  <style>
    /* BASIC STYLES FOR THE SCENE TO WORK */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #0a0a0f;
      color: #fff;
    }

    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      cursor: grab;
    }

    #canvas.grabbing {
      cursor: grabbing;
    }
    
    /* UI OVERLAY & STATUS BAR */
    #ui-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    #status-bar {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 14px;
      color: #fff;
    }

    .block-label {
      position: absolute;
      transform: translate(-50%, -50%);
      pointer-events: none;
      white-space: nowrap;
      padding: 4px 8px;
      border-radius: 4px;
      background: rgba(0, 0, 0, 0.75);
      border: 1px solid #00ff88;
      opacity: 0; /* Managed by GSAP/JS */
      transition: border-color 0.2s;
    }

    .block-label.active {
      border-color: #ffd700;
    }
    
    .block-label .main {
      font-weight: bold;
      color: #00ff88;
    }
    
    .block-label .sub {
      font-size: 10px;
      color: #aaa;
    }
    
    /* Context Menu */
    #context-menu {
      position: absolute;
      background: rgba(15, 15, 25, 0.95);
      border: 1px solid #333;
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      padding: 5px;
      min-width: 180px;
      z-index: 1000;
      display: none;
      pointer-events: auto;
    }
    
    .context-menu-item {
      padding: 8px 12px;
      cursor: pointer;
      font-size: 14px;
      color: #ddd;
      transition: background 0.1s;
      border-radius: 3px;
    }
    
    .context-menu-item:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    
    .context-menu-item strong {
      float: right;
      font-weight: normal;
      color: #00ff88;
    }
    
    .context-menu-item.danger strong {
      color: #ff6b6b;
    }

    /* FAB */
    .fab {
      position: fixed;
      bottom: 32px;
      right: 32px;
      width: 64px;
      height: 64px;
      background: #00ff88;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      color: #0a0a0f;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      transition: transform 0.1s, background 0.1s;
      z-index: 10;
      pointer-events: auto;
    }

    .fab:hover {
      background: #00cc6a;
      transform: scale(1.05);
    }

    /* Magnetic Indicator */
    #magneticIndicator {
      position: absolute;
      border: 2px dashed #00ff88;
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.1s;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="ui-overlay">
    <div id="status-bar">
      Blocks: <span id="blockCount">0</span> |
      Magnetic: <span id="magneticStatus">OFF</span> |
      Force Push: <span id="forceStatus">Normal</span> |
      **Camera: <span id="cameraStatus">Overhead (C)</span>** </div>

    <div id="magneticIndicator"></div>

    <div id="context-menu"></div>

    <div class="fab" id="fab" title="Click to add a cube, Shift+Click for 5 cubes">
      +
    </div>
  </div>

  <script>
    // ===========================================
    // START OF MODIFIED JAVASCRIPT
    // ===========================================
    let scene, camera, renderer, world;
    let raycaster, mouse = new THREE.Vector2();
    let cubes = [];
    let connections = [];
    let draggedCube = null;
    let hoveredCube = null;
    let isDragging = false;
    let isRotating = false;
    let previousMousePosition = { x: 0, y: 0 };
    let magneticMode = false;
    let forcePushMode = false;
    let labelIdCounter = 0;

    const CUBE_SIZE = 2;
    const MAGNETIC_RANGE = 4.5;
    const BREAK_THRESHOLD = 18;
    const MAX_PIVOT = 80;
    const BOUNDARY_LIMIT = 90;

    const Rig = {
      pivot: new THREE.Vector3(0, 0, 0),
      targetPivot: new THREE.Vector3(0, 0, 0),
      zoom: 0,
      targetZoom: 0
    };

    // === NEW/MODIFIED CAMERA CONFIGURATION ===
    const OVERHEAD_CAM_CONFIG = {
      y: 62,
      z: 0.001,
      rotX: -Math.PI / 2 + 0.0001
    };

    const groundCamConfig = {
      y: 9.5,
      z: 27,
      rotX: -0.43
    };

    // isCameraOverhead holds the persistent state (toggled by 'C')
    let isCameraOverhead = true; 

    // currentCamConfig initializes to Overhead and is the variable GSAP modifies
    let currentCamConfig = { ...OVERHEAD_CAM_CONFIG }; 
    // =========================================

    let isShiftPressed = false;

    const faceNormals = [
      new THREE.Vector3(0, 1, 0), // 1 (top)
      new THREE.Vector3(0, 0, 1), // 2
      new THREE.Vector3(1, 0, 0), // 3
      new THREE.Vector3(-1, 0, 0), // 4
      new THREE.Vector3(0, 0, -1), // 5
      new THREE.Vector3(0, -1, 0)  // 6 (bottom)
    ];

    let lastTime = 0;

    const groundMaterial = new CANNON.Material('ground');
    const cubeMaterial = new CANNON.Material('cube');
    const contactMaterial = new CANNON.ContactMaterial(groundMaterial, cubeMaterial, {
      friction: 0.4,
      restitution: 0.3
    });

    // === MODIFIED: Now updates the Camera Status in the UI ===
    function updateStatusBar() {
      document.getElementById('blockCount').textContent = cubes.length;
      document.getElementById('magneticStatus').textContent = magneticMode ? 'ON' : 'OFF';
      document.getElementById('magneticStatus').style.color = magneticMode ? '#00ff88' : '#ff6b6b';
      document.getElementById('forceStatus').textContent = forcePushMode ? 'JEDI' : 'Normal';
      document.getElementById('forceStatus').style.color = forcePushMode ? '#ffd700' : '#00ff88';

      // Update camera status
      const camStatusText = isCameraOverhead ? 'Overhead (C)' : 'Ground (C)';
      const camStatusColor = isCameraOverhead ? '#00ff88' : '#ffd700';
      const camStatusEl = document.getElementById('cameraStatus');
      if (camStatusEl) {
          camStatusEl.textContent = camStatusText;
          camStatusEl.style.color = camStatusColor;
      }
    }
    // ... rest of init() and helper functions ...

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      scene.fog = new THREE.FogExp2(0x000000, 0.011);

      camera = new THREE.PerspectiveCamera(68, window.innerWidth / window.innerHeight, 0.1, 1000);

      const canvas = document.getElementById('canvas');
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: 'high-performance' });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      world = new CANNON.World();
      world.gravity.set(0, -50, 0);
      world.broadphase = new CANNON.NaiveBroadphase();
      world.solver.iterations = 15;
      world.addContactMaterial(contactMaterial);

      // Lighting
      scene.add(new THREE.AmbientLight(0xffffff, 0.5));

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.6);
      dirLight.position.set(15, 40, 15);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      scene.add(dirLight);

      // Neon point lights
      const neon1 = new THREE.PointLight(0x00ffff, 5, 80);
      neon1.position.set(-25, 20, -25);
      scene.add(neon1);
      const neon2 = new THREE.PointLight(0xff00ff, 5, 80);
      neon2.position.set(25, 20, 25);
      scene.add(neon2);
      const neon3 = new THREE.PointLight(0x00ff88, 4.5, 70);
      neon3.position.set(0, 30, 0);
      scene.add(neon3);

      // Ground
      const groundGeo = new THREE.PlaneGeometry(220, 220);
      const groundMat = new THREE.MeshStandardMaterial({ 
        color: 0x0f0f1f, 
        roughness: 0.85, 
        metalness: 0.95,
        envMapIntensity: 1.3
      });
      const groundMesh = new THREE.Mesh(groundGeo, groundMat);
      groundMesh.rotation.x = -Math.PI / 2;
      groundMesh.position.y = -10;
      groundMesh.receiveShadow = true;
      scene.add(groundMesh);

      const groundShape = new CANNON.Plane();
      const groundBody = new CANNON.Body({ mass: 0, material: groundMaterial });
      groundBody.addShape(groundShape);
      groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI / 2);
      groundBody.position.y = -10;
      world.addBody(groundBody);

      // Containment walls
      const WALL_THICKNESS = 8;
      const WALL_HEIGHT = 80;
      const halfThickness = WALL_THICKNESS / 2;
      const halfHeight = WALL_HEIGHT / 2;
      const wallY = -10 + halfHeight;
      const wallDistance = BOUNDARY_LIMIT + halfThickness;
      const wallSpanHalf = BOUNDARY_LIMIT + 20;

      const wallMaterial = groundMaterial; // Use same as ground

      // North / South walls
      const nsShape = new CANNON.Box(new CANNON.Vec3(wallSpanHalf, halfHeight, halfThickness));
      let wallBody = new CANNON.Body({mass: 0, material: wallMaterial});
      wallBody.addShape(nsShape);
      wallBody.position.set(0, wallY, wallDistance);
      world.addBody(wallBody);

      wallBody = new CANNON.Body({mass: 0, material: wallMaterial});
      wallBody.addShape(nsShape);
      wallBody.position.set(0, wallY, -wallDistance);
      world.addBody(wallBody);

      // East / West walls
      const ewShape = new CANNON.Box(new CANNON.Vec3(halfThickness, halfHeight, wallSpanHalf));
      wallBody = new CANNON.Body({mass: 0, material: wallMaterial});
      wallBody.addShape(ewShape);
      wallBody.position.set(wallDistance, wallY, 0);
      world.addBody(wallBody);

      wallBody = new CANNON.Body({mass: 0, material: wallMaterial});
      wallBody.addShape(ewShape);
      wallBody.position.set(-wallDistance, wallY, 0);
      world.addBody(wallBody);

      // Grid
      const grid = new THREE.GridHelper(220, 110, 0x004444, 0x002222);
      grid.position.y = -9.98;
      scene.add(grid);

      raycaster = new THREE.Raycaster();

      setupEventListeners();
      
      const fab = document.getElementById('fab');
      fab.addEventListener('click', (e) => {
        if (e.shiftKey) {
          addRandomCube(5);
        } else {
          addRandomCube();
        }
      });

      // Initial blocks
      for (let i = 0; i < 15; i++) {
        setTimeout(() => addRandomCube(), i * 200);
      }

      updateStatusBar();
      animate(0);
    }

    function createCube(position) {
      if (!position) {
        position = new THREE.Vector3(
          (Math.random() - 0.5) * 50,
          25 + Math.random() * 20,
          (Math.random() - 0.5) * 50
        );
      }

      const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
      const hue = Math.random();
      const color = new THREE.Color().setHSL(hue, 1.0, 0.5);
      const material = new THREE.MeshPhysicalMaterial({
        color: color,
        metalness: 1.0,
        roughness: 0.05,
        clearcoat: 1.0,
        clearcoatRoughness: 0.0,
        emissive: color,
        emissiveIntensity: 3.0,
        envMapIntensity: 1.6
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      scene.add(mesh);

      const shape = new CANNON.Box(new CANNON.Vec3(CUBE_SIZE/2, CUBE_SIZE/2, CUBE_SIZE/2));
      const body = new CANNON.Body({ mass: 1, material: cubeMaterial });
      body.addShape(shape);
      body.position.copy(position);
      body.linearDamping = 0.01;
      body.angularDamping = 0.01;
      body.allowSleep = true;
      body.sleepSpeedLimit = 0.5;
      body.sleepTimeLimit = 0.5;
      world.addBody(body);

      // Create a label element for this dice
      const labelEl = createLabelElement(`Dice ${++labelIdCounter}`, mesh);
      // Add subtle subtext data (world coordinates)
      labelEl.querySelector('.sub').textContent = formatPos(position);

      const cube = { mesh, body, connections: [], labelEl, labelId: labelIdCounter };

      body.addEventListener('sleep', (event) => {
        const quat = new THREE.Quaternion(body.quaternion.x, body.quaternion.y, body.quaternion.z, body.quaternion.w);
        const up = new THREE.Vector3(0, 1, 0);
        let maxDot = -Infinity;
        let topFace = 0;
        for (let i = 0; i < faceNormals.length; i++) {
          const normal = faceNormals[i].clone().applyQuaternion(quat);
          const dot = normal.dot(up);
          if (dot > maxDot) {
            maxDot = dot;
            topFace = i + 1;
          }
        }
        if (maxDot < 0.98) {
          // Perturb to continue rolling
          body.velocity.set(Math.random() * 0.2 - 0.1, Math.random() * 0.2 - 0.1, Math.random() * 0.2 - 0.1);
          body.angularVelocity.set(Math.random() * 0.2 - 0.1, Math.random() * 0.2 - 0.1, Math.random() * 0.2 - 0.1);
          body.wakeUp();
        } else {
          // Update label with top face
          cube.labelEl.querySelector('.main').textContent = `Top face: ${topFace}`;
          cube.labelEl.querySelector('.sub').textContent = formatPos(cube.mesh.position);
        }
      });

      cubes.push(cube);
      updateStatusBar();
      return cube;
    }

    function createLabelElement(text, mesh) {
      const container = document.getElementById('ui-overlay');
      const el = document.createElement('div');
      el.className = 'block-label';
      el.innerHTML = `<div class="main">${text}</div><div class="sub">‚Ä¶</div>`;
      el.style.opacity = '0';
      container.appendChild(el);
      return el;
    }

    function formatPos(v3) {
      return `${v3.x.toFixed(1)}, ${v3.y.toFixed(1)}, ${v3.z.toFixed(1)}`;
    }

    function addRandomCube(count = 1) {
      const actualCount = Math.min(count, 10);
      for (let i = 0; i < actualCount; i++) {
        setTimeout(() => createCube(), i * 120);
      }
    }

    function hasConnection(c1, c2) {
      return connections.some(conn => 
        (conn.cube1 === c1 && conn.cube2 === c2) ||
        (conn.cube1 === c2 && conn.cube2 === c1)
      );
    }

    function createConnection(c1, c2) {
      if (hasConnection(c1, c2)) return;

      const constraint = new CANNON.PointToPointConstraint(
        c1.body, new CANNON.Vec3(0, 0, 0), 
        c2.body, new CANNON.Vec3(0, 0, 0),
        5
      );
      world.addConstraint(constraint);

      const line = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([c1.mesh.position, c2.mesh.position]),
        new THREE.LineBasicMaterial({ 
          color: 0x00ff88, 
          transparent: true, 
          opacity: 0.8,
          linewidth: 2
        })
      );
      scene.add(line);

      const connection = { cube1: c1, cube2: c2, constraint, line };
      connections.push(connection);
      c1.connections.push(connection);
      c2.connections.push(connection);

      // Snap glow effect
      const mid = new THREE.Vector3().addVectors(c1.mesh.position, c2.mesh.position).multiplyScalar(0.5);
      const glow = new THREE.Mesh(
        new THREE.SphereGeometry(0.5, 16, 16), 
        new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 1 })
      );
      glow.position.copy(mid);
      scene.add(glow);
      gsap.to(glow.scale, { x: 7, y: 7, z: 7, duration: 0.5, ease: "power2.out" });
      gsap.to(glow.material, { opacity: 0, duration: 0.6, onComplete: () => scene.remove(glow) });
    }

    function breakConnection(conn) {
      if (!conn) return;
      world.removeConstraint(conn.constraint);
      scene.remove(conn.line);
      conn.cube1.connections = conn.cube1.connections.filter(c => c !== conn);
      conn.cube2.connections = conn.cube2.connections.filter(c => c !== conn);
      connections = connections.filter(c => c !== conn);
    }

    function updateConnectionLines() {
      connections.forEach(conn => {
        const pos = conn.line.geometry.attributes.position;
        pos.array[0] = conn.cube1.mesh.position.x;
        pos.array[1] = conn.cube1.mesh.position.y;
        pos.array[2] = conn.cube1.mesh.position.z;
        pos.array[3] = conn.cube2.mesh.position.x;
        pos.array[4] = conn.cube2.mesh.position.y;
        pos.array[5] = conn.cube2.mesh.position.z;
        pos.needsUpdate = true;
      });
    }

    function enforceBoundaries() {
      cubes.forEach(cube => {
        const pos = cube.body.position;
        let needsCorrection = false;
        
        if (Math.abs(pos.x) > BOUNDARY_LIMIT) {
          pos.x = Math.sign(pos.x) * BOUNDARY_LIMIT;
          cube.body.velocity.x *= -0.5;
          needsCorrection = true;
        }
        if (Math.abs(pos.z) > BOUNDARY_LIMIT) {
          pos.z = Math.sign(pos.z) * BOUNDARY_LIMIT;
          cube.body.velocity.z *= -0.5;
          needsCorrection = true;
        }
        // Removed y boundary check to allow physics to handle ground collision
        
        if (needsCorrection) {
          cube.body.wakeUp();
        }
      });
    }

    function getIntersects(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      return raycaster.intersectObjects(cubes.map(c => c.mesh));
    }

    function getPlaneIntersection(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersect = new THREE.Vector3();
      if (raycaster.ray.intersectPlane(plane, intersect)) return intersect;
      return null;
    }

    function updateMagneticIndicator(cube) {
      const el = document.getElementById('magneticIndicator');
      if (cube && magneticMode) {
        const vec = cube.mesh.position.clone().project(camera);
        const x = (vec.x * 0.5 + 0.5) * window.innerWidth;
        const y = (vec.y * -0.5 + 0.5) * window.innerHeight;
        el.style.left = `${x}px`;
        el.style.top = `${y}px`;
        el.style.width = '80px';
        el.style.height = '80px';
        el.style.marginLeft = '-40px';
        el.style.marginTop = '-40px';
        el.style.opacity = '0.8';
      } else {
        el.style.opacity = '0';
      }
    }

    function showContextMenu(x, y) {
      const menu = document.getElementById('context-menu');
      menu.innerHTML = `
        <div class="context-menu-item" data-action="magnetic">
          üß≤ Magnetic Mode: <strong>${magneticMode ? 'ON' : 'OFF'}</strong>
        </div>
        <div class="context-menu-item" data-action="force">
          ‚ö° Force Push: <strong>${forcePushMode ? 'JEDI' : 'Normal'}</strong>
        </div>
        <div class="context-menu-item danger" data-action="clear">
          üóëÔ∏è Clear All Dice
        </div>
      `;
      menu.style.display = 'block';
      menu.style.left = `${x}px`;
      menu.style.top = `${y}px`;

      setTimeout(() => {
        document.addEventListener('click', hideContextMenu);
      }, 0);
    }

    function hideContextMenu() {
      const menu = document.getElementById('context-menu');
      menu.style.display = 'none';
      document.removeEventListener('click', hideContextMenu);
    }

    function setupEventListeners() {
      const canvas = document.getElementById('canvas');
      const menu = document.getElementById('context-menu');

      menu.addEventListener('click', (e) => {
        const item = e.target.closest('.context-menu-item');
        if (!item) return;
        
        const action = item.dataset.action;
        if (action === 'magnetic') {
          magneticMode = !magneticMode;
          if (!magneticMode) {
            connections.slice().forEach(c => breakConnection(c));
          }
        } else if (action === 'force') {
          forcePushMode = !forcePushMode;
        } else if (action === 'clear') {
          if (confirm('Clear all dice? This cannot be undone.')) {
            cubes.forEach(c => {
              scene.remove(c.mesh);
              if (c.labelEl && c.labelEl.parentNode) c.labelEl.parentNode.removeChild(c.labelEl);
              world.removeBody(c.body);
            });
            connections.forEach(c => {
              scene.remove(c.line);
              world.removeConstraint(c.constraint);
            });
            cubes = [];
            connections = [];
            labelIdCounter = 0;
            updateStatusBar();
          }
        }
        updateStatusBar();
        hideContextMenu();
      });

      canvas.addEventListener('mousedown', (e) => {
        if (e.button === 2) { 
          isRotating = true; 
          previousMousePosition = { x: e.clientX, y: e.clientY }; 
          canvas.style.cursor = 'grabbing';
          return; 
        }
        const intersects = getIntersects(e);
        if (intersects.length > 0) {
          draggedCube = cubes.find(c => c.mesh === intersects[0].object);
          isDragging = true;
          canvas.classList.add('grabbing');
          // show label when dragging
          if (draggedCube && draggedCube.labelEl) {
            draggedCube.labelEl.classList.add('active');
            gsap.to(draggedCube.labelEl, { opacity: 1, duration: 0.12 });
          }
        }
      });

      canvas.addEventListener('mousemove', (e) => {
        if (isRotating) {
          const dx = e.clientX - previousMousePosition.x;
          const dy = e.clientY - previousMousePosition.y;
          Rig.targetPivot.x -= dx * 0.12;
          Rig.targetPivot.z -= dy * 0.12;
          Rig.targetPivot.x = THREE.MathUtils.clamp(Rig.targetPivot.x, -MAX_PIVOT, MAX_PIVOT);
          Rig.targetPivot.z = THREE.MathUtils.clamp(Rig.targetPivot.z, -MAX_PIVOT, MAX_PIVOT);
          previousMousePosition = { x: e.clientX, y: e.clientY };
          return;
        }

        if (isDragging && draggedCube) {
          const planeIntersect = getPlaneIntersection(e);
          if (planeIntersect) {
            const forceVec = planeIntersect.clone().sub(draggedCube.mesh.position).multiplyScalar(50);
            draggedCube.body.applyForce(new CANNON.Vec3(forceVec.x, forceVec.y, forceVec.z), draggedCube.body.position);
            draggedCube.body.wakeUp();
          }
          return;
        }

        const intersects = getIntersects(e);
        if (intersects.length > 0) {
          const newHovered = cubes.find(c => c.mesh === intersects[0].object);
          if (hoveredCube !== newHovered) {
            // hide previous hovered label
            if (hoveredCube && hoveredCube.labelEl) {
              hoveredCube.labelEl.classList.remove('active');
              gsap.to(hoveredCube.labelEl, { opacity: 0, duration: 0.12 });
            }
            hoveredCube = newHovered;
            if (hoveredCube && hoveredCube.labelEl) {
              hoveredCube.labelEl.classList.add('active');
              // update subtext with live coords
              hoveredCube.labelEl.querySelector('.sub').textContent = formatPos(hoveredCube.mesh.position);
              gsap.to(hoveredCube.labelEl, { opacity: 1, duration: 0.12 });
            }
          }
          canvas.classList.add('hovering');
        } else {
          // remove hover
          if (hoveredCube && hoveredCube.labelEl) {
            hoveredCube.labelEl.classList.remove('active');
            gsap.to(hoveredCube.labelEl, { opacity: 0, duration: 0.12 });
          }
          hoveredCube = null;
          canvas.classList.remove('hovering');
        }
        updateMagneticIndicator(hoveredCube);
      });

      canvas.addEventListener('mouseup', () => {
        isDragging = false;
        isRotating = false;
        if (draggedCube && draggedCube.labelEl) {
          // when released, keep label visible briefly then fade
          gsap.to(draggedCube.labelEl, { opacity: 0, delay: 0.4, duration: 0.22, onComplete: () => {
            if (draggedCube) draggedCube.labelEl.classList.remove('active');
          }});
        }
        draggedCube = null;
        canvas.classList.remove('grabbing');
        canvas.style.cursor = 'grab';
      });

      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        Rig.targetZoom += e.deltaY * 0.002;
        Rig.targetZoom = Math.max(-0.5, Math.min(1.6, Rig.targetZoom));
      }, { passive: false });

      // Right-click is now exclusively for Force Push on a block, or nothing otherwise.
      canvas.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const intersects = getIntersects(e);
        if (intersects.length > 0) {
          const cube = cubes.find(c => c.mesh === intersects[0].object);
          const normal = intersects[0].face.normal.clone();
          normal.transformDirection(cube.mesh.matrixWorld);
          const strength = forcePushMode ? -444 : 0;
          const impulse = new CANNON.Vec3(normal.x, normal.y, normal.z).scale(strength);
          cube.body.applyImpulse(impulse, cube.body.position);
          cube.body.wakeUp();
          // briefly show label when force pushed
          if (cube.labelEl) {
            cube.labelEl.classList.add('active');
            cube.labelEl.querySelector('.sub').textContent = formatPos(cube.mesh.position);
            gsap.killTweensOf(cube.labelEl);
            gsap.to(cube.labelEl, { opacity: 1, duration: 0.08 });
            gsap.to(cube.labelEl, { opacity: 0, delay: 0.5, duration: 0.28, onComplete: () => cube.labelEl.classList.remove('active') });
          }
        }
      });

      window.addEventListener('keydown', (e) => {
        if (e.key === 'Shift' && !isShiftPressed) {
          isShiftPressed = true;
          gsap.to(currentCamConfig, { ...groundCamConfig, duration: 0.7, ease: "power2.out" });
        }
        
        // M key toggles the context menu
        if (e.key === 'm' || e.key === 'M') {
            e.preventDefault();
            const menu = document.getElementById('context-menu');
            if (menu.style.display === 'block') {
                hideContextMenu();
            } else {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                showContextMenu(centerX, centerY);
            }
        }

        if (e.key === 'f' || e.key === 'F') {
          forcePushMode = !forcePushMode;
          updateStatusBar();
        }
      });

      window.addEventListener('keyup', (e) => {
        if (e.key === 'Shift' && isShiftPressed) {
          isShiftPressed = false;
          gsap.to(currentCamConfig, { 
            y: 62, 
            z: 0.001, 
            rotX: -Math.PI / 2 + 0.0001, 
            duration: 0.8, 
            ease: "power2.inOut" 
          });
        }
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Touch support
      canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
          const touch = e.touches[0];
          const fakeEvent = { clientX: touch.clientX, clientY: touch.clientY, button: 0 };
          canvas.dispatchEvent(new MouseEvent('mousedown', fakeEvent));
        }
      }, { passive: true });

      canvas.addEventListener('touchmove', (e) => {
        if (e.touches.length === 1) {
          const touch = e.touches[0];
          const fakeEvent = { clientX: touch.clientX, clientY: touch.clientY };
          canvas.dispatchEvent(new MouseEvent('mousemove', fakeEvent));
        }
      }, { passive: true });

      canvas.addEventListener('touchend', () => {
        canvas.dispatchEvent(new MouseEvent('mouseup', {}));
      }, { passive: true });
    }

    function updateLabels() {
      // position each label by projecting the cube's world position to screen space
      const overlay = document.getElementById('ui-overlay');
      if (!overlay) return;

      const halfW = window.innerWidth / 2;
      const halfH = window.innerHeight / 2;

      cubes.forEach(cube => {
        if (!cube.labelEl) return;
        const pos = cube.mesh.position.clone();
        // lift label a bit above the cube
        pos.y += (CUBE_SIZE * 0.6) + 0.8;
        const projected = pos.project(camera);
        // if behind camera, hide
        const behind = projected.z > 1 || projected.z < -1;
        const x = (projected.x * halfW) + halfW;
        const y = (-projected.y * halfH) + halfH;

        // update subtext (live coordinates) if active/hovered
        if (cube === hoveredCube || cube === draggedCube) {
          cube.labelEl.querySelector('.sub').textContent = formatPos(cube.mesh.position);
        }

        // clamp on-screen positions
        const clampedX = Math.max(10, Math.min(window.innerWidth - 10, x));
        const clampedY = Math.max(10, Math.min(window.innerHeight - 10, y));

        cube.labelEl.style.left = `${clampedX}px`;
        cube.labelEl.style.top = `${clampedY}px`;

        // if label is active we keep it visible; otherwise keep it hidden to reduce clutter
        if (behind) {
          cube.labelEl.style.opacity = '0';
          cube.labelEl.style.pointerEvents = 'none';
        } else {
          // If active class exists, opacity is managed via GSAP / transitions; otherwise ensure hidden
          if (!cube.labelEl.classList.contains('active')) {
            cube.labelEl.style.opacity = '0';
          }
        }
      });
    }

    function animate(time) {
      requestAnimationFrame(animate);

      const dt = (time - lastTime) / 1000;
      if (dt > 0) {
        world.step(1/60, dt, 3);
      }
      lastTime = time;

      cubes.forEach(cube => {
        cube.mesh.position.copy(cube.body.position);
        cube.mesh.quaternion.copy(cube.body.quaternion);
      });

      enforceBoundaries();
      updateConnectionLines();

      if (magneticMode) {
        for (let i = 0; i < cubes.length - 1; i++) {
          for (let j = i + 1; j < cubes.length; j++) {
            const a = cubes[i], b = cubes[j];
            const dist = a.mesh.position.distanceTo(b.mesh.position);
            
            if (dist < MAGNETIC_RANGE && !hasConnection(a, b)) {
              createConnection(a, b);
            }
            
            if (dist > BREAK_THRESHOLD) {
              const conn = connections.find(c => 
                (c.cube1 === a && c.cube2 === b) || (c.cube1 === b && c.cube2 === a)
              );
              if (conn) breakConnection(conn);
            }
          }
        }
      }

      // update labels each frame
      updateLabels();

      Rig.pivot.lerp(Rig.targetPivot, 0.18);
      Rig.zoom += (Rig.targetZoom - Rig.zoom) * 0.18;

      let y = currentCamConfig.y;
      let z = currentCamConfig.z;
      const zoomFactor = 0.5 + Rig.zoom * 0.9;
      y *= zoomFactor;
      z *= zoomFactor;

      camera.position.set(Rig.pivot.x, Rig.pivot.y + y, Rig.pivot.z + z);
      camera.rotation.x = currentCamConfig.rotX;
      camera.lookAt(Rig.pivot);

      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
