<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Guitar ↔ Piano Mapper — intoview.pro</title>
<link rel="icon" href="/favicon.ico" sizes="any">
<style>
  :root{
    --bottom-h: 32vh;

    /* isometric cubes (fretboard only) */
    --cube-size-base: 40;
    --iso-cell-base:  56;
    --iso-cell:  calc(var(--iso-cell-base) * 1px);
    --cube-size: calc(var(--cube-size-base) * 1px);

    /* labels */
    --lbl-note-dx:-10px;  --lbl-note-dy:-6px;

    /* background grid (roomier) */
    --bg:#000;
    --grid-gap: 4px;
    --grid-alpha:.12;
    --grid-thin: rgb(160 190 255 / calc(var(--grid-alpha) * .20));
    --grid-bold: rgb(84 140 255 / calc(var(--grid-alpha) * .36));

    /* keyboard */
    --panel:#000;
    --fg:#e9eeff;
    --muted:#a8b4d6;
    --accent:#1f6fff;
    --white-r: 4px;
    --black-r: 4px;

    /* computed */
    --white-w: 48px;

    /* gutter between fretboard and keyboard */
    --gutter-size: 16px;
    --gutter-hit:  16px;

    /* BG hover/pulses */
    --iso-highlight-fill: 255 255 255;
    --iso-highlight-alpha: .25;
    --iso-stroke-alpha: .55;
    --iso-fade-ms: 900;
    --iso-blur-min: 0px;
    --iso-blur-max: 12px;
    --iso-blur-curve: 1.35;
  }

  html,body{height:100%}
  body{
    margin:0; color:var(--fg); background:var(--bg);
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    overflow:hidden;
    background-image:
      repeating-linear-gradient(30deg,  var(--grid-thin) 0 1px, transparent 1px var(--grid-gap)),
      repeating-linear-gradient(90deg,  var(--grid-thin) 0 1px, transparent 1px var(--grid-gap)),
      repeating-linear-gradient(150deg, var(--grid-thin) 0 1px, transparent 1px var(--grid-gap)),
      repeating-linear-gradient(30deg,  transparent 0 calc(var(--grid-gap)*4 - 1px), var(--grid-bold) calc(var(--grid-gap)*4 - 1px) calc(var(--grid-gap)*4)),
      repeating-linear-gradient(90deg,  transparent 0 calc(var(--grid-gap)*4 - 1px), var(--grid-bold) calc(var(--grid-gap)*4 - 1px) calc(var(--grid-gap)*4)),
      repeating-linear-gradient(150deg, transparent 0 calc(var(--grid-gap)*4 - 1px), var(--grid-bold) calc(var(--grid-gap)*4 - 1px) calc(var(--grid-gap)*4));
    background-attachment:fixed,fixed,fixed,fixed,fixed,fixed;
    font:14px/1.35 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
  }

  /* BG hover/pulses canvas sits behind everything */
  .iso-canvas{ position:fixed; inset:0; z-index:0; pointer-events:none; }

  /* ===== Main area above fixed keyboard ===== */
  .top-pane{
    position:relative;
    height:100vh;
    padding-bottom: calc(var(--bottom-h) + var(--gutter-size));
    box-sizing:border-box;
    display:flex;
    flex-direction:column;
    z-index:1;
  }

  /* fretboard + gutter */
  .fretboard-wrap{
    height: calc(100vh - var(--bottom-h) - var(--gutter-size));
    position:relative; overflow:hidden; min-height:220px;
  }
  .gutter{
    position:relative; height: var(--gutter-size);
    background: linear-gradient(90deg, rgb(255 255 255 / .06), transparent 40%, transparent 60%, rgb(255 255 255 / .06));
    cursor: row-resize; flex: 0 0 auto; z-index:3;
  }
  .gutter::after{ content:""; position:absolute; inset:calc((var(--gutter-size) - var(--gutter-hit))/2 * -1) 0; }

  /* ===== Stage (isometric guitar fretboard) ===== */
  #isoCanvas{ position:absolute; inset:0; z-index:1; pointer-events:none; }
  #stage{ position:absolute; inset:0; z-index:2; overflow:visible; width:100%; height:100%; }

  .cube{
    cursor:pointer; outline:none;
    --facet-top-fill:#ffffff; --facet-side-fill:#ededed; --facet-dark-fill:#767676;
    filter: blur(calc(var(--depth-blur, 0px) + var(--focus-blur, 0px)));
    transition: filter .24s ease, transform .24s ease;
  }
  .cube .facet-top,
  .cube .facet-side,
  .cube .facet-dark { transition: fill .24s ease; }
  .cube .facet-top  { fill: var(--facet-top-fill); }
  .cube .facet-side { fill: var(--facet-side-fill); }
  .cube .facet-dark { fill: var(--facet-dark-fill); }

  .cube.dim{
    --facet-top-fill:#2b2b2b; --facet-side-fill:#1e1e1e; --facet-dark-fill:#000000;
    filter: blur(var(--depth-blur, 0px)) brightness(0.95);
  }

  .cube.selected{
    --facet-top-fill:#ffd84a; --facet-side-fill:#e6bf00; --facet-dark-fill:#b38f00;
    filter: drop-shadow(0 0 14px rgb(255 216 74 / .35));
  }

  .cube.active{ filter: blur(var(--depth-blur, 0px)) drop-shadow(0 0 14px rgb(0 0 0 / .60)); }

  .note{
    font-family: ui-monospace, Menlo, Consolas, monospace;
    font-size:11px; font-weight:800;
    fill:#ffffff; opacity:.98; user-select:none; pointer-events:none;
    paint-order: stroke fill; stroke:#000; stroke-width:2px; stroke-opacity:.55;
  }

  .string-tag{ position:absolute; left:10px; color:#cdd8ff; font:700 12px/1 ui-monospace, Menlo, monospace; opacity:.9; text-shadow:0 1px 0 #000; }
  @media (max-width:560px){ .note{ display:none; } }

  /* ===== Fixed Keyboard Footer ===== */
  .keyboard-wrap{
    position:fixed; left:0; right:0; bottom:0;
    height:var(--bottom-h);
    background:var(--panel);
    box-shadow:0 -8px 28px rgb(0 0 0 / .35);
    display:grid; grid-template-rows: auto auto 1fr auto; gap:8px;
    padding:10px 10px 8px;
    z-index: 5;
  }
  .kbd-head{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
  .kbd-head .meta{ color:var(--muted); font-weight:700 }

  /* Open strings row */
  .opens-row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:center; }
  .open-pill{
    appearance:none; border:1px solid rgb(255 255 255 / .14);
    background:linear-gradient(#141d3a,#0c1226); color:#eaf0ff;
    padding:6px 10px; border-radius:999px; font:800 12px/1 ui-monospace, Menlo, monospace;
    display:inline-flex; gap:8px; align-items:baseline; cursor:pointer;
    box-shadow: 0 6px 12px rgb(0 0 0 / .35), inset 0 -10px 20px rgb(0 0 0 / .25);
  }
  .open-pill small{ color:#8aa0ff; font-weight:800; }

  .keyboard{ position:relative; border:1px solid rgb(255 255 255 / .10); border-radius:12px; height:100%;
    background:
      radial-gradient(1200px 60% at 50% 0%, rgb(255 255 255 / .05), transparent 60%),
      linear-gradient(180deg, rgb(255 255 255 / .03), transparent);
    overflow:hidden; }
  .whites{ position:absolute; inset: clamp(6px, 1.2vh, 12px); display:flex; align-items:end; justify-content:center; gap:clamp(2px, 0.6vw, 8px); }
  .white{ width:var(--white-w); height:100%; border-radius:var(--white-r); background:linear-gradient(#fbfbfb, #f2f2f2);
    border:1px solid #e2e2e2; color:#222; box-shadow: inset 0 -36px 40px -12px rgb(0 0 0 / .08), 0 10px 16px rgb(0 0 0 / .35);
    position:relative; display:grid; grid-template-rows: 1fr auto; overflow:clip; cursor:pointer;
    transition:transform .03s ease, box-shadow .5s ease, filter .5s ease; }
  .white:active, .white.playing{ transform:translateY(1px); box-shadow: inset 0 -10px 18px -6px rgb(0 0 0 / .16), 0 6px 12px rgb(0 0 0 / .45), 0 0 0 3px var(--accent) inset; filter:brightness(0.98); }
  .wlabel{ font:700 12px/1 ui-monospace, Menlo, Consolas, monospace; color:#333; background:#f6f6f6; border-top:1px solid #e8e8e8; padding:6px 8px; display:flex; align-items:center; justify-content:center; gap:8px; }
  .wlabel small{ color:#666 }

  .black{ position:absolute; top: clamp(6px, 1.2vh, 12px); width:26px; height:62%; border-radius:var(--black-r);
    background: linear-gradient(#3a3a3a, #1b1b1b); border:1px solid #101010; box-shadow: inset 0 -20px 20px -6px rgb(0 0 0 / .55), 0 12px 20px rgb(0 0 0 / .6);
    z-index:3; cursor:pointer; display:block; transition:transform .03s ease, box-shadow .5s ease, filter .5s ease; }
  .black:active, .black.playing{ transform:translateY(1px); box-shadow: inset 0 -8px 16px -6px rgb(0 0 0 / .75), 0 6px 12px rgb(0 0 0 / .7), 0 0 0 3px var(--accent) inset; filter:brightness(1.02); }

  /* Glow + scale highlights */
  .white.active, .black.active{
    box-shadow:
      0 0 0 4px rgb(61 169 255 / .95) inset,
      0 0 0 2px rgb(61 169 255 / .85),
      0 0 26px 10px rgb(61 169 255 / .45);
    filter: brightness(1.03);
  }
  .white.mem0, .black.mem0{ box-shadow: 0 0 0 4px rgb(78 224 181 / .95) inset, 0 0 0 2px rgb(78 224 181 / .85), 0 0 32px 12px rgb(78 224 181 / .55); }
  .white.mem1, .black.mem1{ box-shadow: 0 0 0 4px rgb(78 224 181 / .70) inset, 0 0 0 2px rgb(78 224 181 / .50), 0 0 26px 10px rgb(78 224 181 / .35); }
  .white.mem2, .black.mem2{ box-shadow: 0 0 0 3px rgb(78 224 181 / .45) inset, 0 0 0 1px rgb(78 224 181 / .35), 0 0 20px 8px  rgb(78 224 181 / .25); }

  .controls{ position:absolute; z-index:4; inset:12px auto auto 12px; display:flex; gap:8px; align-items:center; background:rgb(0 0 0 / .45); border:1px solid rgb(255 255 255 / .12); padding:8px 10px; border-radius:10px; backdrop-filter: blur(6px); }
  .controls label{ font:700 12px/1 ui-monospace, Menlo, monospace; color:#e2e9ff; display:flex; align-items:center; gap:6px; text-shadow:0 1px 0 #000; }
  .controls select{ appearance:none; background:#0e1533; color:#e8eeff; border:1px solid rgb(255 255 255 / .16); border-radius:8px; padding:6px 26px 6px 10px; font:700 12px/1 ui-monospace, Menlo, monospace; }

  /* in-scale highlighting */
  .cube.in-scale{ --facet-top-fill:#d9fff5; --facet-side-fill:#bff7e8; --facet-dark-fill:#83cdb7; }
  .cube.root{ --facet-top-fill:#ffffff; --facet-side-fill:#d8fff3; --facet-dark-fill:#5ed2af; }
  .white.in-scale, .black.in-scale{ box-shadow: 0 0 0 3px rgb(78 224 181 / .55) inset, 0 0 0 1px rgb(78 224 181 / .45), 0 0 16px 6px rgb(78 224 181 / .20); }
  .white.root, .black.root{ box-shadow: 0 0 0 4px rgb(78 224 181 / .95) inset, 0 0 0 2px rgb(78 224 181 / .85), 0 0 28px 10px rgb(78 224 181 / .45); }

  .fret-num{ font:800 12px/1 ui-monospace, Menlo, Consolas, monospace; fill:#c7d4ff; opacity:.95; user-select:none; pointer-events:none; text-shadow:0 1px 0 #000; }

  /* ===== HUD: mini ASCII tab + controls ===== */
  .hud{
    position:fixed; top:12px; right:12px; z-index:6;
    display:flex; flex-direction:column; gap:8px; align-items:stretch;
    pointer-events:none;
  }
  .hud .card{
    pointer-events:auto;
    background: rgb(8 12 26 / .6);
    border:1px solid rgb(255 255 255 / .12);
    backdrop-filter: blur(8px);
    border-radius:12px;
    padding:10px;
    box-shadow: 0 8px 24px rgb(0 0 0 / .35);
  }

  .mini-tab{
    margin:0;
    white-space:pre;
    font: 700 9px/1.15 ui-monospace, Menlo, Consolas, monospace;
    color:#cfe1ff;
    width:min(38vw, 420px);
    max-width:420px;
    overflow:hidden;
    opacity:.96;
    user-select:text;
  }
  .hud .meta{ display:flex; align-items:center; justify-content:space-between; gap:8px; margin-top:6px; }
  .hud .btns{ display:flex; gap:6px; }
  .hud button{
    appearance:none;
    border:1px solid rgb(255 255 255 / .16);
    background:linear-gradient(#0f1733, #0a1126);
    color:#eaf0ff; font:800 11px/1 ui-monospace, Menlo, monospace;
    padding:6px 8px; border-radius:8px; cursor:pointer;
  }
  .hud button:hover{ filter:brightness(1.06) }
  .hud button:active{ transform:translateY(1px) }

  .hud .chk{ display:flex; align-items:center; gap:6px; margin-bottom:6px; font:700 11px/1 ui-monospace, Menlo, monospace; color:#cfe1ff; opacity:.9; }

  @media (max-width:560px){
    :root{ --iso-cell-base: 52; --cube-size-base: 44; }
    .wlabel{ font-size:11px }
    .mini-tab{ width:72vw; font-size:9px; }
  }

  @media (prefers-reduced-motion: reduce){
    .white, .black, .cube{ transition: none !important; }
  }
</style>
</head>
<body>

<!-- Background hover/pulses -->
<canvas id="bgIso" class="iso-canvas" aria-hidden="true"></canvas>

<div class="top-pane">
  <!-- Controls -->
  <div class="controls" aria-label="Options">
    <label>Handedness
      <select id="handedness" aria-label="Handedness">
        <option value="right">Righty</option>
        <option value="left">Lefty</option>
      </select>
    </label>
    <label>Root
      <select id="rootSelect" aria-label="Scale root"></select>
    </label>
    <label>Scale
      <select id="scaleSelect" aria-label="Scale"></select>
    </label>
    <label>View
      <select id="viewSelect" aria-label="View">
        <option value="normal">Normal</option>
        <option value="inverse">Inverse</option>
      </select>
    </label>
    <label>Tone
      <select id="toneSelect" aria-label="Tone">
        <option value="crunch">Crunch</option>
        <option value="high-gain">High-gain</option>
        <option value="glassy" selected>Glassy</option>
      </select>
    </label>
  </div>

  <!-- Fretboard -->
  <section class="fretboard-wrap" aria-label="Isometric guitar fretboard">
    <canvas id="isoCanvas" aria-hidden="true"></canvas>
    <svg id="stage" role="group" aria-label="Isometric note cubes" width="100%" height="100%">
      <g id="board">
        <g id="strings"></g>
        <g id="labels"></g>
        <g id="fretNums"></g>
      </g>
    </svg>
    <div id="stringTags" aria-hidden="true"></div>
  </section>

  <!-- Gutter to resize keyboard height -->
  <div class="gutter" id="gutterResizer" role="separator" aria-label="Resize keyboard height"></div>
</div>

<!-- Floating HUD: Mini ASCII Tab -->
<div class="hud" aria-live="polite">
  <div class="card">
    <pre id="miniTab" class="mini-tab" aria-label="Miniature ASCII guitar tab"></pre>
    <label class="chk"><input type="checkbox" id="histAll"> Log all fret positions per note</label>
    <div class="meta">
      <span id="histMeta">Notes: 0</span>
      <div class="btns">
        <button id="histBack" title="Undo last (Backspace)" type="button">Backspace</button>
        <button id="histCopy" title="Copy mini-tab + stats" type="button">Copy</button>
        <button id="histClear" title="Clear log" type="button">Clear</button>
      </div>
    </div>
  </div>
</div>

<!-- Fixed keyboard -->
<section class="keyboard-wrap" aria-label="Piano keyboard mapper">
  <div class="kbd-head">
    <strong>Keyboard</strong>
    <span class="meta" id="rangeLabel"></span>
  </div>

  <div class="opens-row" id="opensRow" aria-label="Open strings (E A D G B E)"></div>

  <div class="keyboard" id="keyboard">
    <div id="whites" class="whites"></div>
  </div>
  <small class="meta">Hover a piano key: matching fret cubes remain white, others dim. Click to paint yellow blocks; click again to unpaint.</small>
</section>

<div id="live" class="sr" aria-live="polite"></div>

<script>
/* ========= Helpers ========= */
const pcs=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const isBlackPC = {1:1,3:1,6:1,8:1,10:1};
const stage = document.getElementById('stage');
function pcOf(m){ return ((m%12)+12)%12; }
function nameOf(m){ const oct = Math.floor(m/12)-1; return (pcs[pcOf(m)] + oct); }
function isWhite(m){ return !isBlackPC[pcOf(m)]; }
function css(){ return getComputedStyle(document.documentElement); }
function num(v,fb){ const n=parseFloat(v); return Number.isFinite(n)?n:fb; }
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function px(n){ return `${Math.round(n)}px`; }
const live = document.getElementById('live');

/* ========= Gutter resizes KEYBOARD height ========= */
(function gutter(){
  const gut = document.getElementById('gutterResizer');
  let dragging=false, startY=0, startBottomPx=0;

  function getBottomPx(){
    const kb = document.querySelector('.keyboard-wrap');
    return kb ? kb.getBoundingClientRect().height : (innerHeight * 0.32);
  }
  function minBottomPx(){ return 120; }
  function maxBottomPx(){
    const minFretTop = 220;
    const g = parseFloat(css().getPropertyValue('--gutter-size')) || 10;
    return Math.max(minBottomPx(), innerHeight - minFretTop - g);
  }

  function onDown(e){
    dragging=true;
    startY = e.touches?.[0]?.clientY ?? e.clientY ?? 0;
    startBottomPx = getBottomPx();
    document.body.style.userSelect='none';
    e.target.setPointerCapture?.(e.pointerId);
  }
  function onMove(e){
    if(!dragging) return;
    const y = e.touches?.[0]?.clientY ?? e.clientY ?? startY;
    const dy = startY - y; // dragging up increases keyboard height
    const next = clamp(startBottomPx + dy, minBottomPx(), maxBottomPx());
    document.documentElement.style.setProperty('--bottom-h', px(next));
    buildFretboard(); layoutKeyboard();
  }
  function onUp(){
    dragging=false; document.body.style.userSelect='';
    buildFretboard();
  }
  gut.addEventListener('pointerdown', onDown);
  addEventListener('pointermove', onMove, {passive:true});
  addEventListener('pointerup', onUp, {passive:true});
  addEventListener('resize', ()=> buildFretboard(), {passive:true});
})();

/* ========= State ========= */
const STATE = { lefty:false, view:'normal', root:0, scale:'none', recentKeys:[], recentMax:3, tone:'glassy' };
const OPEN_MIDI_BASE = [40,45,50,55,59,64]; // E2 A2 D3 G3 B3 E4
const STRING_NAMES_BASE = ['E2','A2','D3','G3','B3','E4'];
const FRETS = 22;

/* ========= TAB mapping (mini ascii) ========= */
const TAB_OPEN = [64,59,55,50,45,40];  // high e4 → low E2 (top→bottom)
const TAB_LABELS = ['e','B','G','D','A','E'];
const MAX_TAB_COLS = 72;
const NOTE_LOG = []; // entries: { midi, i (0..5), fret }

/* ========= Fretboard geometry (30° iso) ========= */
const cos30=Math.sqrt(3)/2;
const sin30=0.5;

function readCell(){ return num(css().getPropertyValue('--iso-cell'), 44); }
function basis(){
  const CELL = readCell();
  const v1 = { x:  cos30*CELL, y:  sin30*CELL };
  const v2 = { x: -cos30*CELL, y:  sin30*CELL };
  const det = v1.x*v2.y - v2.x*v1.y;
  const inv = { a:v2.y/det, b:-v2.x/det, c:-v1.y/det, d:v1.x/det };
  return { CELL, v1, v2, inv };
}
let B = basis();
function toXY(I,J){ return { x:I*B.v1.x + J*B.v2.x, y:I*B.v1.y + J*B.v2.y }; }
function invXY(x,y){ return { I: B.inv.a*x + B.inv.b*y, J: B.inv.c*x + B.inv.d*y }; }

const stringsG = document.getElementById('strings');
const labelsG  = document.getElementById('labels');
const fretNumsG= document.getElementById('fretNums');
const boardG   = document.getElementById('board');
const tagsWrap = document.getElementById('stringTags');

const FRET_MARKS = {1:1,3:1,5:1,7:1,9:1,12:1,15:1,17:1,19:1,21:1};
function fretPositions(){ const pos=[0]; for(let f=1; f<=FRETS; f++) pos.push(1 - Math.pow(2, -f/12)); return pos; }

function blurForVisualRow(visualRow){
  const t = visualRow/5; // near = bottom rows
  const far = 2.2, near = 0.6;
  const px = far - (far - near) * t;
  return px.toFixed(2) + 'px';
}

function sizeForMidi(m){
  const low = Math.min(...OPEN_MIDI_BASE), high = Math.max(...OPEN_MIDI_BASE) + FRETS;
  const t = Math.max(0, Math.min(1, (m - low) / (high - low)));
  return 0.84 + (1 - t) * 0.16;
}
function unit(v){ const l=Math.hypot(v.x,v.y)||1; return {x:v.x/l, y:v.y/l}; }
function pToStr(p){ return `${Math.round(p.x)},${Math.round(p.y)}`; }

/* ========= Build Fretboard (two-pass scale + center-align by bbox) ========= */
function buildFretboard(){
  stringsG.innerHTML=''; labelsG.innerHTML=''; fretNumsG.innerHTML=''; tagsWrap.innerHTML='';
  boardG.removeAttribute('transform');
  B=basis();

  const vh = innerHeight;
  const bottomH = (document.querySelector('.keyboard-wrap')?.getBoundingClientRect().height) || (vh*0.32);
  const gut = parseFloat(css().getPropertyValue('--gutter-size')) || 10;

  const availableTop = Math.max(220, vh - bottomH - gut);
  const controls = document.querySelector('.controls');
  const controlsBottom = controls ? controls.getBoundingClientRect().bottom : 0;
  const SAFE_TOP_PAD = Math.max(16, Math.ceil(controlsBottom) + 12);

  const pos = fretPositions();

  /* the same target center point for both views */
  const targetCenterPx = { x: innerWidth / 2, y: Math.max((availableTop) * 0.52, SAFE_TOP_PAD + 40) };

  function place(scale){
    document.documentElement.style.setProperty('--iso-cell',  (num(css().getPropertyValue('--iso-cell-base'), 44)*scale)+'px');
    document.documentElement.style.setProperty('--cube-size', (num(css().getPropertyValue('--cube-size-base'),56)*scale)+'px');
    B=basis();
    stringsG.innerHTML=''; labelsG.innerHTML=''; fretNumsG.innerHTML='';

    const totalRows = 6;
    const centerIJ = invXY(targetCenterPx.x, targetCenterPx.y);
    const spanI = FRETS;
    const useInverse = (STATE.view === 'inverse');

    const opens     = (STATE.lefty ? OPEN_MIDI_BASE.slice().reverse() : OPEN_MIDI_BASE.slice());
    const openNames = (STATE.lefty ? STRING_NAMES_BASE.slice().reverse() : STRING_NAMES_BASE.slice());

    /* start indices so that 12th fret is roughly central; final exact centering happens later */
    const ANCHOR_FRET = 12;
    const posAnchor = pos[ANCHOR_FRET];
    const posAnchorView = useInverse ? (1 - posAnchor) : posAnchor;

    const startI = centerIJ.I - posAnchorView * spanI;
    const startJ = centerIJ.J - (totalRows/2);

    const baseW=num(css().getPropertyValue('--cube-size'), 36);
    const baseH=baseW*(96/86);

    const e1 = unit(B.v1), e2 = unit(B.v2);

    for(let visualRow=0; visualRow<totalRows; visualRow++){
      const s = visualRow;
      const stringNumber = STATE.lefty ? (1 + s) : (6 - s);

      const stringGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
      stringGroup.setAttribute('data-string', String(stringNumber));
      stringsG.appendChild(stringGroup);

      for(let f=0; f<=FRETS; f++){
        const posF = pos[f];
        const posFI = useInverse ? (1 - posF) : posF;

        const I = startI + posFI * spanI;
        const J = startJ + visualRow;

        const pC=toXY(I,J);

        const g=document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('class','cube'); g.setAttribute('tabindex','0'); g.setAttribute('role','button');

        const midi = (opens[s] + f); const nm = nameOf(midi);
        g.dataset.midi = String(midi); g.dataset.name = nm;
        g.dataset.string = String(stringNumber);
        g.dataset.fret = String(f);
        g.setAttribute('aria-label', `String ${g.dataset.string}, fret ${f}, ${nm}`);

        const k = sizeForMidi(midi);
        const sxy = baseW * k;
        const depth = baseH * k * 0.42;

        g.style.setProperty('--depth-blur', blurForVisualRow(visualRow));
        g.style.setProperty('--focus-blur', '0px');

        const p0 = { x: pC.x, y: pC.y };
        const p1 = { x: p0.x + e1.x * (sxy/2), y: p0.y + e1.y * (sxy/2) };
        const p3 = { x: p0.x + e2.x * (sxy/2), y: p0.y + e2.y * (sxy/2) };
        const p2 = { x: p1.x + e2.x * (sxy/2), y: p1.y + e2.y * (sxy/2) };

        const down = { x: 0, y: depth };

        const top = document.createElementNS('http://www.w3.org/2000/svg','polygon');
        top.setAttribute('class','facet-top');
        top.setAttribute('points', [p0,p1,p2,p3].map(pToStr).join(' '));

        const side = document.createElementNS('http://www.w3.org/2000/svg','polygon');
        side.setAttribute('class','facet-side');
        side.setAttribute('points', [p1,p2,{x:p2.x+down.x,y:p2.y+down.y},{x:p1.x+down.x,y:p1.y+down.y}].map(pToStr).join(' '));

        const dark = document.createElementNS('http://www.w3.org/2000/svg','polygon');
        dark.setAttribute('class','facet-dark');
        dark.setAttribute('points', [p3,p2,{x:p2.x+down.x,y:p2.y+down.y},{x:p3.x+down.x,y:p3.y+down.y}].map(pToStr).join(' '));

        const cx = (p0.x + p1.x + p2.x + p3.x) / 4;
        const cy = (p0.y + p1.y + p2.y + p3.y) / 4;

        const lbl=document.createElementNS('http://www.w3.org/2000/svg','text');
        lbl.setAttribute('class','note');
        lbl.setAttribute('x', cx);
        lbl.setAttribute('y', cy + 10);
        lbl.setAttribute('text-anchor','middle');
        lbl.textContent = nm + (f===0?' (open)':'');

        g.appendChild(top); g.appendChild(side); g.appendChild(dark);
        stringGroup.appendChild(g);
        labelsG.appendChild(lbl);
      }
    }

    /* string tags aligned to float rows derived from centerIJ */
    for(let visualRow2=0; visualRow2<6; visualRow2++){
      const J2 = (centerIJ.J - (6/2)) + visualRow2;
      const p2 = toXY(startI-2, J2);
      const tag = document.createElement('div'); tag.className='string-tag';
      const labelIndex = STATE.lefty ? (1 + visualRow2) : (6 - visualRow2);
      tag.style.top = (p2.y-6) + 'px';
      tag.textContent = 'String ' + labelIndex + ' — ' + (STATE.lefty ? STRING_NAMES_BASE[visualRow2] : STRING_NAMES_BASE.slice().reverse()[visualRow2]);
      tagsWrap.appendChild(tag);
    }

    /* fret numerals (respect inverse) */
    for(let fn=1; fn<=FRETS; fn++){
      if(!FRET_MARKS[fn]) continue;
      const posFN = pos[fn];
      const posFNI = useInverse ? (1 - posFN) : posFN;
      const Ii = startI + posFNI * spanI;
      const Jj = startJ - 0.6; const tp = toXY(Ii,Jj);
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('class','fret-num'); t.setAttribute('x', tp.x); t.setAttribute('y', tp.y);
      t.setAttribute('text-anchor','middle'); t.textContent = String(fn);
      fretNumsG.appendChild(t);
    }
  }

  /* ---- first pass at base scale = 1 to measure ---- */
  place(1);

  /* compute a scale that fits inside the safe region */
  const polys1=stage.querySelectorAll('polygon');
  if(!polys1.length) return;
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  polys1.forEach(u=>{ const bb=u.getBBox(); minX=Math.min(minX,bb.x); minY=Math.min(minY,bb.y); maxX=Math.max(maxX,bb.x+bb.width); maxY=Math.max(maxY,bb.y+bb.height); });
  const pad = Math.max(16, Math.min(48, Math.round(Math.min(innerWidth, availableTop)*0.04)));
  const needW = innerWidth - pad*2;
  const needH = availableTop - 12 - pad*2;
  const bboxW = maxX-minX, bboxH = maxY-minY;
  const scale = Math.min(1, needW/bboxW, needH/bboxH);

  /* ---- second pass with final scale ---- */
  place(scale);

  /* ---- final exact centering by bbox so Normal/Inverse coincide ---- */
  const polys2=stage.querySelectorAll('polygon');
  if(!polys2.length) return;
  minX=Infinity;minY=Infinity;maxX=-Infinity;maxY=-Infinity;
  polys2.forEach(u=>{ const bb=u.getBBox(); minX=Math.min(minX,bb.x); minY=Math.min(minY,bb.y); maxX=Math.max(maxX,bb.x+bb.width); maxY=Math.max(maxY,bb.y+bb.height); });
  const centerX = (minX+maxX)/2, centerY=(minY+maxY)/2;

  let dx = targetCenterPx.x - centerX;
  let dy = targetCenterPx.y - centerY;

  /* enforce top safety (don’t overlap the control bar) */
  const SAFE_TOP_PAD2 = Math.max(16, (document.querySelector('.controls')?.getBoundingClientRect().bottom ?? 0) + 12);
  if (minY + dy < SAFE_TOP_PAD2) dy += (SAFE_TOP_PAD2 - (minY + dy));

  boardG.setAttribute('transform', `translate(${Math.round(dx)}, ${Math.round(dy)})`);

  /* keep DOM string tags aligned vertically with the board translation */
  tagsWrap.querySelectorAll('.string-tag').forEach(t => {
    const cur = parseFloat(t.style.top || '0');
    t.style.top = (cur + dy) + 'px';
  });
}

/* ========= Scale highlighting ========= */
const SCALE_DEFS = {
  'none': [], 'single note': [0], 'chromatic': [0,1,2,3,4,5,6,7,8,9,10,11],
  'major': [0,2,4,5,7,9,11], 'natural minor': [0,2,3,5,7,8,10],
  'dorian': [0,2,3,5,7,9,10], 'mixolydian': [0,2,4,5,7,9,10],
  'pentatonic major': [0,2,4,7,9], 'pentatonic minor': [0,3,5,7,10], 'blues': [0,3,5,6,7,10]
};
function applyScaleHighlight(){
  const name = STATE.scale;
  if(name==='none'){
    stage.querySelectorAll('.cube').forEach(c=>c.classList.remove('in-scale','root'));
    document.querySelectorAll('.white,.black').forEach(k=>k.classList.remove('in-scale','root'));
    live.textContent = 'Scale off';
    return;
  }
  const ints = SCALE_DEFS[name]; const set = {};
  for(let i=0;i<ints.length;i++) set[(STATE.root + ints[i]) % 12] = true;

  stage.querySelectorAll('.cube').forEach(c=>{
    c.classList.remove('in-scale','root');
    const pc = pcOf(+c.dataset.midi);
    if(set[pc]){ c.classList.add('in-scale'); if(pc===STATE.root) c.classList.add('root'); }
  });
  document.querySelectorAll('.white,.black').forEach(k=>{
    k.classList.remove('in-scale','root');
    const pc = pcOf(+k.dataset.midi);
    if(set[pc]){ k.classList.add('in-scale'); if(pc===STATE.root) k.classList.add('root'); }
  });
  live.textContent = `Scale: ${name}, Root: ${pcs[STATE.root]}`;
}

/* ========= Keyboard ========= */
const whitesWrap = document.getElementById('whites');
const keyboardEl = document.getElementById('keyboard');
const rangeLabel = document.getElementById('rangeLabel');

function getKeyboardBounds(){
  return { min: Math.min(...OPEN_MIDI_BASE), max: Math.max(...OPEN_MIDI_BASE) + FRETS };
}

function layoutKeyboard(){
  const {min, max} = getKeyboardBounds();
  rangeLabel.textContent = nameOf(min) + ' → ' + nameOf(max);

  const notes=[]; for(let m=min; m<=max; m++) notes.push(m);
  const whites = notes.filter(isWhite);

  const pad = parseFloat(getComputedStyle(whitesWrap).gap) || 4;
  const wwRect = whitesWrap.getBoundingClientRect();
  const innerW = wwRect.width || keyboardEl.clientWidth;
  const wW = Math.max(24, Math.floor((innerW - pad*(whites.length-1)) / whites.length));
  document.documentElement.style.setProperty('--white-w', wW+'px');

  positionBlackKeys();
}

function buildKeyboard(){
  const {min, max} = getKeyboardBounds();

  whitesWrap.innerHTML='';
  keyboardEl.querySelectorAll('.black').forEach(b=>b.remove());

  const frag = document.createDocumentFragment();
  for(let m=min; m<=max; m++){
    if(!isWhite(m)) continue;
    const k = document.createElement('button');
    k.type='button'; k.className='white';
    k.dataset.midi=String(m);
    k.setAttribute('aria-label', nameOf(m));
    k.setAttribute('tabindex','0');
    const cap = document.createElement('div'); cap.className='wlabel';
    cap.innerHTML = `<span>${nameOf(m)}</span><small>${pcs[pcOf(m)]}</small>`;
    k.appendChild(document.createElement('div'));
    k.appendChild(cap);
    frag.appendChild(k);
  }
  whitesWrap.appendChild(frag);

  for(let m=min; m<=max; m++){
    if(isBlackPC[pcOf(m)]){
      const b = document.createElement('button');
      b.type='button'; b.className='black';
      b.dataset.midi=String(m);
      b.setAttribute('aria-label', nameOf(m));
      b.setAttribute('tabindex','0');
      keyboardEl.appendChild(b);
    }
  }

  layoutKeyboard();
}

function positionBlackKeys(){
  const blacks = Array.from(keyboardEl.querySelectorAll('.black'));
  const whites = Array.from(whitesWrap.querySelectorAll('.white'));
  if (!blacks.length || !whites.length) return;

  const kbLeft = keyboardEl.getBoundingClientRect().left;
  const whiteRects = whites.map(w => w.getBoundingClientRect());
  const whiteLefts = whiteRects.map(r => r.left - kbLeft);
  const whiteWidths = whiteRects.map(r => r.width);
  const whiteCenters = whiteLefts.map((L, i) => L + whiteWidths[i] / 2);
  const whitesMidi = whites.map(w => +w.dataset.midi);

  const avgWhiteW = whiteWidths.reduce((a,b)=>a+b, 0) / Math.max(1,whiteWidths.length);
  const blackW = Math.round(Math.max(18, Math.min(28, avgWhiteW * 0.54)));

  blacks.forEach(b => {
    const m = +b.dataset.midi;
    let nextIdx = whitesMidi.findIndex(wm => wm > m);
    if (nextIdx === -1) nextIdx = whitesMidi.length - 1;
    let prevIdx = nextIdx - 1; if (prevIdx < 0) prevIdx = 0;
    const cL = whiteCenters[prevIdx];
    const cR = whiteCenters[Math.min(nextIdx, whiteCenters.length - 1)];
    const center = (cL + cR) / 2;
    b.style.width = `${blackW}px`;
    b.style.left  = `${Math.round(center - blackW / 2)}px`;
  });
}

/* ========= Open strings row ========= */
const opensRow = document.getElementById('opensRow');
function buildOpensRow(){
  opensRow.innerHTML = '';
  const labels = ['E','A','D','G','B','E'];
  const labelSet = STATE.lefty ? labels.slice().reverse() : labels.slice();
  const baseSet  = STATE.lefty ? OPEN_MIDI_BASE.slice().reverse() : OPEN_MIDI_BASE.slice();

  baseSet.forEach((midi, idx)=>{
    const btn = document.createElement('button');
    btn.type='button';
    btn.className='open-pill';
    btn.dataset.midi = String(midi);
    btn.innerHTML = `<span>${labelSet[idx]}</span><small>${nameOf(midi)}</small>`;
    btn.addEventListener('click', async (e)=>{
      const ok = await ensureAudio();
      const key = keyboardEl.querySelector(`[data-midi="${midi}"]`);
      if (key){ key.classList.add('playing'); setTimeout(()=>key.classList.remove('playing'), 180); flashActiveKey(key, 600); }
      toggleSelectionForMidi(midi);
      if (ok) playPiano(midi);

      const pos = chooseTabPosition(midi);
      NOTE_LOG.push({ midi, i:pos.i, fret:pos.fret }); updateMiniTab();
      live.textContent = `Open string: ${labelSet[idx]} (${nameOf(midi)})`;
      triggerBgPulseAtEvent(e);
    }, { passive:true });
    opensRow.appendChild(btn);
  });
}

/* ========= Hover invert ========= */
let currentHoverMidi = null;
function beginHoverInvert(midi){
  if (currentHoverMidi === midi) return;
  currentHoverMidi = midi;
  const all = stage.querySelectorAll('.cube');
  all.forEach(c => c.classList.add('dim'));
  stage.querySelectorAll(`.cube[data-midi="${midi}"]`).forEach(c => c.classList.remove('dim'));
}
function endHoverInvert(){
  currentHoverMidi = null;
  stage.querySelectorAll('.cube.dim').forEach(c => c.classList.remove('dim'));
}

/* ========= Selection (yellow) ========= */
function toggleSelectionForMidi(midi){
  const targets = stage.querySelectorAll(`.cube[data-midi="${midi}"]`);
  const allSelected = Array.from(targets).every(c => c.classList.contains('selected'));
  targets.forEach(c => c.classList.toggle('selected', !allSelected));
}
function toggleSelectionForCube(cube){ cube.classList.toggle('selected'); }

/* ========= Active effects ========= */
function flashActiveKey(keyEl, ms=600){ keyEl.classList.add('active'); setTimeout(()=> keyEl.classList.remove('active'), ms); }

/* ========= Audio (stable / low-glitch) ========= */
const AUDIO = { started:false };
let AC=null, polyGain=null, reverbBuf=null;

/* Tunables */
const MAX_VOICES   = 10;   // global polyphony cap (was effectively ~20+)
const MAX_PARTIALS = 8;    // limit harmonics per note (CPU saver)
const BASE_RELEASE = 1.0;  // seconds; will be scaled by velocity
const NOTE_TTL     = 3.5;  // seconds; safety auto-dispose

/* track active voices for note stealing */
const activeVoices = new Set(); // items: {stop, dispose, born, prio}

function midiToFreq(m){ return 440*Math.pow(2,(m-69)/12); }

/* reuse a single reverb impulse across sessions */
function buildRoomIR(seconds=1.0){
  if (reverbBuf) return reverbBuf;
  const sr = AC.sampleRate;
  const len = Math.floor(sr * seconds);
  const buf = AC.createBuffer(2, len, sr);
  for(let ch=0; ch<2; ch++){
    const d = buf.getChannelData(ch); let lp = 0;
    for(let i=0;i<len;i++){
      const noise = (Math.random()*2-1);
      lp = 0.92*lp + 0.08*noise;
      const t = i/len;
      d[i] = lp * Math.pow(1 - t, 1.7) * 0.33;
      if (ch===1 && i>24) d[i] += d[i-24]*0.11;
    }
  }
  reverbBuf = buf;
  return reverbBuf;
}

/* fewer partials, gently tapered */
function partialsFor(freq){
  const maxByFreq = Math.max(4, Math.floor(6000 / freq));   // softer high notes
  const cap = Math.min(MAX_PARTIALS, maxByFreq);
  const out = [];
  for(let n=1; n<=cap; n++){
    let a = 1 / (n * (n<=3 ? 1.0 : 1.25));
    a *= Math.exp(-n/8.0);
    out.push({ n, a });
  }
  const sum = out.reduce((s,p)=>s+p.a,0)||1;
  out.forEach(p=>p.a/=sum);
  return out;
}

function velocityForMidi(m){
  const low = Math.min(...OPEN_MIDI_BASE), high = Math.max(...OPEN_MIDI_BASE) + FRETS;
  const t = Math.max(0, Math.min(1, (m - low) / (high - low)));
  return 0.68 + (1 - t) * 0.10; // a touch softer overall (reduces limiter work)
}

function createPianoVoice(freq, vel){
  const now = AC.currentTime;

  /* env */
  const env = AC.createGain(); env.gain.value = 0.0001;
  const atk = 0.002;
  const dec = 0.85 * (1.0 - 0.34*vel);
  const sus = 0.0009;
  const rel = BASE_RELEASE * (0.9 + 0.3*(1.0-vel)); // shorter tails

  env.gain.setValueAtTime(0.0001, now);
  env.gain.linearRampToValueAtTime(Math.max(0.28, vel), now + atk);
  env.gain.exponentialRampToValueAtTime(Math.max(1e-4, sus), now + atk + dec);

  /* simple tone: partials -> gentle LP -> soft drive */
  const lp = AC.createBiquadFilter(); lp.type='lowpass'; lp.Q.value=0.7;
  lp.frequency.value = Math.min(11000, 1000 + freq * 6.0);

  const drive = AC.createWaveShaper();
  if (!createPianoVoice._curve){
    const curveLen=1024, curve=new Float32Array(curveLen);
    for(let i=0;i<curveLen;i++){ const x=i/(curveLen-1)*2-1; curve[i]=Math.tanh(1.0*x); }
    createPianoVoice._curve = curve;
  }
  drive.curve = createPianoVoice._curve;
  drive.oversample='2x';

  const busL = AC.createGain(), busR = AC.createGain();
  busL.gain.value = 0.9; busR.gain.value = 0.9;

  const created = []; // for cleanup

  function mkOsc(mult, gainVal, detune = 0){
    const o = AC.createOscillator(); o.type='sine';
    o.frequency.value = freq*mult;
    if (detune) o.detune.value = detune;
    const g = AC.createGain(); g.gain.value = gainVal * (0.85 + 0.25*vel);
    created.push(o, g);
    return {o,g};
  }

  const parts = partialsFor(freq);
  parts.forEach(({n,a}, idx)=>{
    const {o:oL, g:gL} = mkOsc(n*0.998, a);
    const {o:oR, g:gR} = mkOsc(n*1.002, a);
    oL.connect(gL).connect(busL); oR.connect(gR).connect(busR);
    oL.start(now); oR.start(now);
    const stopAt = now + atk + dec + rel + 0.05;
    oL.stop(stopAt); oR.stop(stopAt);
  });

  /* light key thump */
  const noise = AC.createBufferSource();
  const nlen = Math.floor(AC.sampleRate*0.018);
  const nbuf = AC.createBuffer(1, nlen, AC.sampleRate);
  const nd = nbuf.getChannelData(0);
  for(let i=0;i<nlen;i++){ const t=i/nlen; nd[i] = (Math.random()*2-1) * Math.exp(-t*24); }
  noise.buffer = nbuf;
  const nHP = AC.createBiquadFilter(); nHP.type='highpass'; nHP.frequency.value = 2400;
  const nG  = AC.createGain(); nG.gain.value = (0.07 + 0.08*vel);
  created.push(noise, nHP, nG);
  noise.connect(nHP).connect(nG).connect(busL);
  noise.connect(nHP).connect(nG).connect(busR);
  noise.start(now); noise.stop(now+0.04);

  /* sum -> env -> polyGain */
  const mix = AC.createGain(); const sum = AC.createGain();
  mix.gain.value = sum.gain.value = 1.0;
  busL.connect(mix); busR.connect(mix); mix.connect(lp).connect(drive).connect(sum).connect(env);

  const post = AC.createGain(); post.gain.value = 1.0;
  env.connect(post); post.connect(polyGain);
  created.push(lp, drive, busL, busR, mix, sum, env, post);

  const stop = (releaseTime=rel)=>{
    const t=AC.currentTime;
    env.gain.cancelScheduledValues(t);
    env.gain.setTargetAtTime(0.0001, t, Math.max(0.05, releaseTime/3));
  };

  const dispose = ()=>{
    // disconnect everything to hasten GC
    created.forEach(n => { try{ n.disconnect?.(); }catch{} });
  };

  /* auto-dispose in case note rings long */
  setTimeout(dispose, Math.max(200, (rel+1.2)*1000));

  return { stop, dispose };
}

async function ensureAudio(){
  if (AUDIO.started) return true;
  try{
    const C = window.AudioContext || window.webkitAudioContext;
    AC = new C({ latencyHint:'interactive' });

    const master = AC.createGain(); master.gain.value = 0.9;
    const dry    = AC.createGain(); dry.gain.value = 0.96;
    const wet    = AC.createGain(); wet.gain.value = 0.08;

    polyGain = AC.createGain(); polyGain.gain.value = 0.85;

    const hp = AC.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 50; hp.Q.value = 0.6;
    const tiltEQ = AC.createBiquadFilter(); tiltEQ.type='peaking'; tiltEQ.frequency.value = 2400; tiltEQ.Q.value = 0.7; tiltEQ.gain.value = +1.6;

    const comp = AC.createDynamicsCompressor();
    comp.threshold.value=-20; comp.knee.value=24; comp.ratio.value=2.4; comp.attack.value=0.004; comp.release.value=0.18;

    const limiter = AC.createDynamicsCompressor();
    limiter.threshold.value=-1.0; limiter.knee.value=0; limiter.ratio.value=20; limiter.attack.value=0.002; limiter.release.value=0.10;

    const reverb = AC.createConvolver(); reverb.buffer = buildRoomIR(0.95);

    polyGain.connect(hp).connect(tiltEQ).connect(dry);
    reverb.connect(wet);

    dry.connect(master); wet.connect(master);
    master.connect(comp); comp.connect(limiter); limiter.connect(AC.destination);

    AUDIO.started = true;
    live.textContent = 'Audio ready (stable)';
    return true;
  }catch(e){
    console.warn('Audio init failed:', e);
    live.textContent = 'Audio unavailable';
    return false;
  }
}

/* Note stealing + play */
function playPiano(midi){
  if(!AUDIO.started || !AC) return () => {};
  const f = midiToFreq(midi);
  const v = createPianoVoice(f, velocityForMidi(midi));

  // Steal oldest when over cap
  if (activeVoices.size >= MAX_VOICES){
    const oldest = activeVoices.values().next().value;
    try{ oldest?.stop(0.08); oldest?.dispose?.(); }catch{}
    activeVoices.delete(oldest);
  }

  const wrapped = { ...v, born: AC.currentTime };
  activeVoices.add(wrapped);

  // purge later
  setTimeout(()=>{
    if (activeVoices.has(wrapped)) { try{ wrapped.dispose?.(); }catch{} activeVoices.delete(wrapped); }
  }, NOTE_TTL*1000);

  return ()=>{
    try{ v.stop(0.25); v.dispose?.(); }catch{}
    activeVoices.delete(wrapped);
  };
}


/* ========= Interactions ========= */
function pushMemory(el){
  document.querySelectorAll('.mem0,.mem1,.mem2').forEach(k=>k.classList.remove('mem0','mem1','mem2'));
  STATE.recentKeys = [el, ...STATE.recentKeys.filter(x=>x!==el)].slice(0, STATE.recentMax);
  STATE.recentKeys.forEach((k,i)=> k.classList.add('mem'+i));
}

/* Piano key interaction */
const histAll = document.getElementById('histAll');

document.getElementById('keyboard').addEventListener('pointerdown', async (e)=>{
  const btn = e.target.closest('.white,.black'); if(!btn) return;
  const ok = await ensureAudio();
  const midi = +btn.dataset.midi;
  btn.classList.add('playing'); setTimeout(()=>btn.classList.remove('playing'), 180);
  flashActiveKey(btn, 600);
  pushMemory(btn);
  toggleSelectionForMidi(midi);
  if(ok) playPiano(midi);

  if (histAll.checked) {
    /* log every visible fret position of this pitch, preserving real string indices */
    stage.querySelectorAll(`.cube[data-midi="${midi}"]`).forEach(c => {
      const i = (+c.dataset.string) - 1;  // string 1..6 → tab row 0..5
      const fret = +c.dataset.fret;
      NOTE_LOG.push({ midi, i, fret });
    });
  } else {
    const pos = chooseTabPosition(midi);
    NOTE_LOG.push({ midi, i:pos.i, fret:pos.fret });
  }
  updateMiniTab();
  live.textContent = `Piano: ${nameOf(midi)} (glassy)`;
  triggerBgPulseAtEvent(e);
}, { passive: true });

document.getElementById('keyboard').addEventListener('pointermove', (e)=>{
  const btn = e.target.closest('.white,.black');
  if(!btn){ return; }
  const midi = +btn.dataset.midi;
  beginHoverInvert(midi);
}, { passive:true });
document.getElementById('keyboard').addEventListener('pointerleave', ()=> endHoverInvert(), { passive:true });

/* Fret cube interaction */
stage.addEventListener('pointerdown', async (e)=>{
  const cube = e.target.closest('.cube'); if(!cube) return;
  const ok = await ensureAudio();
  const midi = +cube.dataset.midi;
  const key = document.getElementById('keyboard').querySelector(`[data-midi="${midi}"]`);
  if(key){ key.classList.add('playing'); pushMemory(key); setTimeout(()=>key.classList.remove('playing'), 180); }
  toggleSelectionForCube(cube);
  if(ok) playPiano(midi);

  const fret = +cube.dataset.fret;
  const pos = chooseTabPositionGivenFret(midi, fret);
  NOTE_LOG.push({ midi, i:pos.i, fret:pos.fret }); updateMiniTab();

  triggerBgPulseAtEvent(e);
  live.textContent = `Fretboard: ${cube.dataset.name} (string ${cube.dataset.string}, fret ${cube.dataset.fret})`;
}, { passive: true });

stage.addEventListener('keydown', async (e)=>{
  if(e.key!=='Enter' && e.key!==' ') return;
  const cube = e.target.closest('.cube'); if(!cube) return;
  e.preventDefault();
  const ok = await ensureAudio();
  const midi = +cube.dataset.midi;
  const key = document.getElementById('keyboard').querySelector(`[data-midi="${midi}"]`);
  if(key){ key.classList.add('playing'); pushMemory(key); setTimeout(()=>key.classList.remove('playing'), 180); }
  toggleSelectionForCube(cube);
  if(ok) playPiano(midi);

  const fret = +cube.dataset.fret;
  const pos = chooseTabPositionGivenFret(midi, fret);
  NOTE_LOG.push({ midi, i:pos.i, fret:pos.fret }); updateMiniTab();

  triggerBgPulseAtElement(cube);
});

/* ========= Controls ========= */
(function controls(){
  const handedSel = document.getElementById('handedness');
  const rootSel   = document.getElementById('rootSelect');
  const scaleSel  = document.getElementById('scaleSelect');
  const viewSel   = document.getElementById('viewSelect');
  const toneSel   = document.getElementById('toneSelect');

  pcs.forEach((n,i)=>{ const o=document.createElement('option'); o.value=String(i); o.textContent=n; rootSel.appendChild(o); });
  ['none','single note','chromatic','major','natural minor','dorian','mixolydian','pentatonic major','pentatonic minor','blues']
    .forEach(n=>{ const o=document.createElement('option'); o.value=n; o.textContent=n.replace(/\b\w/g,m=>m.toUpperCase()); scaleSel.appendChild(o); });

  rootSel.value=String(STATE.root);
  scaleSel.value=STATE.scale;
  handedSel.value=STATE.lefty?'left':'right';
  viewSel.value=(STATE.view==='inverse')?'inverse':'normal';
  toneSel.value = 'glassy';

  toneSel.addEventListener('change', async ()=>{ if (!AUDIO.started) await ensureAudio(); live.textContent = `Tone: ${toneSel.value}`; });
  handedSel.addEventListener('change', ()=>{ STATE.lefty = handedSel.value==='left'; buildAll(); });
  rootSel.addEventListener('change', ()=>{ STATE.root = +rootSel.value; applyScaleHighlight(); });
  scaleSel.addEventListener('change', ()=>{ STATE.scale = scaleSel.value; applyScaleHighlight(); });
  viewSel.addEventListener('change', ()=>{ STATE.view = (viewSel.value==='inverse') ? 'inverse' : 'normal'; buildFretboard(); });
})();

/* ========= Mini ASCII Tab ========= */
const miniTabEl = document.getElementById('miniTab');
const histMeta = document.getElementById('histMeta');

function chooseTabPosition(midi){
  let best = null;
  for(let i=0;i<6;i++){
    const fret = midi - TAB_OPEN[i];
    if (fret>=0 && fret<=FRETS){
      if(!best || fret < best.fret || (fret===best.fret && i<best.i)){
        best = { i, fret };
      }
    }
  }
  if(!best){
    let minErr=1e9, bestI=0, bestF=0;
    for(let i=0;i<6;i++){
      const fret = midi - TAB_OPEN[i];
      const err = Math.abs(fret<0 ? -fret : fret-FRETS*(fret>FRETS));
      if (err<minErr){ minErr=err; bestI=i; bestF=Math.max(0, Math.min(FRETS, fret)); }
    }
    best = { i:bestI, fret:bestF };
  }
  return best;
}
function chooseTabPositionGivenFret(midi, fret){
  for(let i=0;i<6;i++){
    if (TAB_OPEN[i] + (+fret) === +midi) return { i, fret:+fret };
  }
  return chooseTabPosition(midi);
}

function renderMiniTabText(){
  const cols = Math.min(MAX_TAB_COLS, NOTE_LOG.length);
  const start = Math.max(0, NOTE_LOG.length - cols);
  const lines = TAB_LABELS.map(lbl => `${lbl}|`);
  for(let c=start; c<start+cols; c++){
    for(let s=0;s<6;s++) lines[s] += '--';
  }
  for(let idx=0; idx<cols; idx++){
    const ev = NOTE_LOG[start + idx];
    const s  = ev.i;
    const f  = Math.max(0, Math.min(99, Math.round(ev.fret)));
    const fs = f.toString().padStart(2,' ').slice(-2);
    const pos = 2 + idx*2;
    lines[s] = lines[s].slice(0, pos) + fs + lines[s].slice(pos+2);
  }
  for(let idx=0; idx<cols; idx++){
    if (idx>0 && idx%4===0){
      for(let s=0;s<6;s++){
        const pos = 2 + idx*2;
        lines[s] = lines[s].slice(0,pos) + '|' + lines[s].slice(pos+1);
      }
    }
  }
  for(let s=0;s<6;s++) lines[s] += '|';
  return lines.join('\n');
}

function updateMiniTab(){
  miniTabEl.textContent = renderMiniTabText();
  histMeta.textContent = `Notes: ${NOTE_LOG.length}`;
}

/* HUD controls */
const btnBack = document.getElementById('histBack');
const btnCopy = document.getElementById('histCopy');
const btnClear= document.getElementById('histClear');

function popLastNote(){
  if (!NOTE_LOG.length) return;
  const last = NOTE_LOG.pop();
  updateMiniTab();
  live.textContent = `Removed last note: ${nameOf(last.midi)} (Backspace)`;
}
function clearLog(){
  NOTE_LOG.length = 0;
  updateMiniTab();
  live.textContent = 'Cleared note log';
}
function copyLog(){
  const tab = renderMiniTabText();
  const seq = NOTE_LOG.map(e => nameOf(e.midi)).join(', ');
  const counts = Array(12).fill(0);
  NOTE_LOG.forEach(e => counts[pcOf(e.midi)]++);
  const countLines = counts.map((c,i)=> `${pcs[i]}: ${c}`).join('\n');
  const text = `${tab}\n\nNotes (${NOTE_LOG.length}): ${seq}\n\nCounts by pitch class:\n${countLines}\n`;
  if (navigator.clipboard && window.isSecureContext){
    navigator.clipboard.writeText(text).then(()=>{ live.textContent = 'Copied mini-tab + stats to clipboard'; })
      .catch(()=> fallbackCopy(text));
  } else {
    fallbackCopy(text);
  }
}
function fallbackCopy(text){
  const ta=document.createElement('textarea');
  ta.value=text; ta.style.position='fixed'; ta.style.left='-9999px';
  document.body.appendChild(ta); ta.select();
  try{ document.execCommand('copy'); live.textContent = 'Copied mini-tab + stats to clipboard'; }
  catch(e){ live.textContent = 'Copy failed'; }
  finally{ ta.remove(); }
}

btnBack.addEventListener('click', popLastNote);
btnClear.addEventListener('click', clearLog);
btnCopy.addEventListener('click', copyLog);

document.addEventListener('keydown', (e)=>{
  if (e.key !== 'Backspace') return;
  const tag = (document.activeElement && document.activeElement.tagName) || '';
  const editable = document.activeElement && (document.activeElement.isContentEditable || /^(INPUT|TEXTAREA|SELECT)$/i.test(tag));
  if (editable) return;
  e.preventDefault();
  popLastNote();
});

/* ========= Build orchestration ========= */
function buildAll(){
  buildOpensRow();
  buildKeyboard();
  buildFretboard();
  applyScaleHighlight();
  updateMiniTab();
}

/* ========= Resize hooks ========= */
let rAF=0;
function resync(){
  cancelAnimationFrame(rAF);
  rAF=requestAnimationFrame(()=>{ layoutKeyboard(); buildFretboard(); applyScaleHighlight(); });
}
addEventListener('resize', resync, { passive: true });
addEventListener('orientationchange', resync, { passive: true });

/* ========= Init ========= */
if (document.readyState === 'loading'){
  document.addEventListener('DOMContentLoaded', async () => { buildAll(); await ensureAudio(); }, { once:true });
} else {
  (async ()=>{ buildAll(); await ensureAudio(); })();
}

/* ========= Background hover/pulse engine ========= */
(function bgIsoPulses(){
  const canvas = document.getElementById('bgIso');
  if(!canvas) return;
  const ctx = canvas.getContext('2d');

  function s(){ return getComputedStyle(document.documentElement); }
  function fnum(v, fb){ const n = parseFloat(v); return Number.isFinite(n)?n:fb; }
  function toPx(v){ const m=String(v).trim().match(/^([0-9.]+)\s*px$/i); return m?+m[1]:0; }

  const COS = Math.sqrt(3)/2, SIN = 0.5;
  let CELL = 40, v1={x:0,y:0}, v2={x:0,y:0}, det=1, inv={a:0,b:0,c:0,d:0};
  let FILL_RGB='255 255 255', FILL_A=.25, STROKE_A=.55, FADE_MS=900, BLUR_MIN='0px', BLUR_MAX='12px', BLUR_CURVE=1.35;
  let view = { w: innerWidth, h: innerHeight, cx: innerWidth/2, cy: innerHeight/2, R: Math.hypot(innerWidth, innerHeight)/2 };

  function readVars(){
    const cs = s();
    CELL       = fnum(cs.getPropertyValue('--iso-cell'), 40);
    FILL_RGB   = (cs.getPropertyValue('--iso-highlight-fill').trim() || '255 255 255');
    FILL_A     = fnum(cs.getPropertyValue('--iso-highlight-alpha'), .25);
    STROKE_A   = fnum(cs.getPropertyValue('--iso-stroke-alpha'), .55);
    FADE_MS    = fnum(cs.getPropertyValue('--iso-fade-ms'), 900);
    BLUR_MIN   = cs.getPropertyValue('--iso-blur-min').trim() || '0px';
    BLUR_MAX   = cs.getPropertyValue('--iso-blur-max').trim() || '12px';
    BLUR_CURVE = fnum(cs.getPropertyValue('--iso-blur-curve'), 1.35);

    v1 = { x:  COS * CELL, y: SIN * CELL };
    v2 = { x: -COS * CELL, y: SIN * CELL };
    det = v1.x*v2.y - v2.x*v1.y;
    inv = { a: v2.y/det, b: -v2.x/det, c: -v1.y/det, d: v1.x/det };
  }

  function resize(){
    const dpr = Math.max(1, devicePixelRatio || 1);
    canvas.width  = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width  = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    readVars();
    view = { w: innerWidth, h: innerHeight, cx: innerWidth/2, cy: innerHeight/2, R: Math.hypot(innerWidth, innerHeight)/2 };
  }
  addEventListener('resize', resize, { passive:true });
  resize();

  function snapToLattice(x,y){
    const i = inv.a*x + inv.b*y;
    const j = inv.c*x + inv.d*y;
    return { I: Math.round(i), J: Math.round(j) };
  }
  function cellPoly(I,J){
    const ox = I*v1.x + J*v2.x, oy = I*v1.y + J*v2.y;
    const p0 = {x: ox,                 y: oy};
    const p1 = {x: ox + v1.x,          y: oy + v1.y};
    const p2 = {x: ox + v1.x + v2.x,   y: oy + v1.y + v2.y};
    const p3 = {x: ox + v2.x,          y: oy + v2.y};
    const cx = (p0.x+p1.x+p2.x+p3.x)/4, cy = (p0.y+p1.y+p2.y+p3.y)/4;
    return { pts:[p0,p1,p2,p3], cx, cy };
  }
  function drawPoly(pts){
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for(let k=1;k<pts.length;k++) ctx.lineTo(pts[k].x);
    ctx.closePath();
  }

  const pulses=[];
  let lastKey='';
  addEventListener('pointermove', (e)=>{
    const {I,J} = snapToLattice(e.clientX, e.clientY);
    const key = I+','+J;
    if (key!==lastKey){
      lastKey = key;
      pulses.push({I,J,born:performance.now()});
      if(!animating) start();
    }
  }, {passive:true});
  addEventListener('pointerleave', ()=>{ lastKey=''; });

  let animating=false;
  const easeOutQuad = u => 1 - (1-u)*(1-u);
  const clamp01 = x => x<0?0:x>1?1:x;
  function start(){ animating=true; requestAnimationFrame(tick); }
  function stop(){ animating=false; }

  function tick(now){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    let alive=0;
    for (let i=0;i<pulses.length;i++){
      const p=pulses[i], age=now - p.born;
      if (age>=FADE_MS) continue;
      alive++;

      const u = age/FADE_MS, invAge = 1-u;
      const fillA = easeOutQuad(invAge) * FILL_A;
      const strokeA = invAge * STROKE_A;

      const {pts, cx, cy} = cellPoly(p.I,p.J);

      const dist = Math.hypot(cx - view.cx, cy - view.cy);
      const dNorm = clamp01(dist / view.R);
      const t = Math.pow(dNorm, BLUR_CURVE>0?BLUR_CURVE:1);
      const blurPx = toPx(BLUR_MIN) + (toPx(BLUR_MAX) - toPx(BLUR_MIN)) * t;

      ctx.filter = `blur(${blurPx}px)`;
      ctx.fillStyle = `rgb(${FILL_RGB} / ${fillA})`;
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for(let k=1;k<pts.length;k++) ctx.lineTo(pts[k].x, pts[k].y);
      ctx.closePath();
      ctx.fill();

      ctx.lineWidth = 1;
      ctx.strokeStyle = `rgb(${FILL_RGB} / ${strokeA})`;
      ctx.stroke();
      ctx.filter = 'none';
    }

    if (alive !== pulses.length){
      const cutoff = now - FADE_MS;
      for(let i=pulses.length-1;i>=0;i--) if (pulses[i].born <= cutoff) pulses.splice(i,1);
    }
    if (alive>0) requestAnimationFrame(tick); else stop();
  }

  window.triggerBgPulseAtEvent = function(ev){
    const {I,J} = snapToLattice(ev.clientX, ev.clientY);
    pulses.push({I,J,born:performance.now()}); if(!animating) start();
  };
  window.triggerBgPulseAtElement = function(el){
    const r = el.getBoundingClientRect();
    const {I,J} = snapToLattice(r.left + r.width/2, r.top + r.height/2);
    pulses.push({I,J,born:performance.now()}); if(!animating) start();
  };
})();
</script>
</body>
</html>
