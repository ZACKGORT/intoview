<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>PUNT: Neon Interactive</title>
    <style>
        :root{--bg:#0f1014;--accent:#39FF14;--pink:#FF1493;--neon-blue:#00ffff;}
        *{margin:0;padding:0;box-sizing:border-box;user-select:none;-webkit-user-select:none;}
        body{background:var(--bg);overflow:hidden;color:#fff;font-family:'Courier New', Courier, monospace;cursor:none;overscroll-behavior:none;}
        #canvas{display:block;width:100vw;height:100vh;outline:none;}
        
        /* --- UI Overlay --- */
        .hud{position:fixed;bottom:1rem;left:20px;font-size:10px;opacity:0.6;z-index:90;pointer-events:none;font-family:sans-serif;}
        .mode-status{position:fixed;top:20px;left:50%;transform:translateX(-50%);background:rgba(255,255,255,0.05);padding:8px 16px;border-radius:20px;border:1px solid rgba(255,255,255,0.1);opacity:0;transition:0.3s;z-index:100;pointer-events:none;}
        .mode-status.active{opacity:1;color:var(--pink);border-color:var(--pink);box-shadow: 0 0 15px var(--pink);}
        
        /* Top Right Controls */
        .presets{position:fixed;top:20px;right:20px;display:flex;gap:8px;z-index:100;}
        .scales{position:fixed;top:20px;left:20px;display:flex;gap:8px;z-index:100;}
        
        .btn{background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);color:#fff;padding:8px 12px;border-radius:6px;cursor:pointer;font-size:10px;font-family:inherit;transition:0.2s;text-transform:uppercase;letter-spacing:1px;}
        .btn:hover{background:rgba(255,255,255,0.1);border-color:var(--accent);}
        .btn.active{border-color:var(--pink);color:var(--pink);box-shadow:0 0 10px rgba(255,20,147,0.3);}
        
        /* Input Bars - Raised Higher */
        .top-bar{position:fixed;top:60px;left:50%;transform:translateX(-50%);z-index:100;}
        .top-bar input{background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.2);color:#fff;padding:8px 12px;border-radius:6px;width:200px;text-align:center;font-size:12px;cursor:text;}
        
        .bottom-bar{position:fixed;bottom:6.6rem; /* Raised */ left:50%;transform:translateX(-50%);display:flex;gap:8px;z-index:100;}
        .bottom-bar input{background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.2);color:#fff;padding:8px 12px;border-radius:6px;width:300px;font-size:12px;cursor:text;}
        .bottom-bar button{background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);color:#fff;padding:8px 12px;border-radius:6px;cursor:pointer;font-size:10px;transition:0.2s;}
        
        .pills{position:fixed;bottom:4rem; /* Raised */ left:50%;transform:translateX(-50%);display:flex;gap:8px;z-index:100;}

        /* Coordinates (Clamped) */
        .coords {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            color: var(--accent);
            background: rgba(0,0,0,0.6);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(57, 255, 20, 0.3);
            z-index: 90;
            pointer-events: none;
        }

        /* --- FAB / Joystick (Centered) --- */
        .fab-zone {
            position: fixed;
            bottom: 9.9rem;
            left: 50%; /* Centered */
            transform: translateX(-50%);
            width: 80px;
            height: 80px;
            z-index: 200;
            cursor: grab;
            perspective: 600px;
        }
        .fab-zone:active { cursor: grabbing; }

        .fab-cube {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transform: rotateX(-25deg) rotateY(-45deg);
            pointer-events: none;
            transition: transform 0.1s;
        }
        .f-face {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 20, 147, 0.15); /* Glassy Pink */
            border: 2px solid var(--pink);
            box-shadow: 0 0 15px var(--pink), inset 0 0 10px var(--pink);
            left: 20px;
            top: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #fff;
            backface-visibility: visible;
        }
        /* Cube construction */
        .f-face:nth-child(1) { transform: rotateY(0deg) translateZ(20px); }
        .f-face:nth-child(2) { transform: rotateY(90deg) translateZ(20px); }
        .f-face:nth-child(3) { transform: rotateY(180deg) translateZ(20px); }
        .f-face:nth-child(4) { transform: rotateY(-90deg) translateZ(20px); }
        .f-face:nth-child(5) { transform: rotateX(90deg) translateZ(20px); background: rgba(255, 20, 147, 0.3); }
        .f-face:nth-child(6) { transform: rotateX(-90deg) translateZ(20px); }

        .fab-hint {
            position: absolute;
            bottom: -16px;
            width: 100%;
            text-align: center;
            font-size: 9px;
            color: rgba(255,255,255,0.5);
            pointer-events: none;
        }

        /* --- Custom Cursor --- */
        #cursor{position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:9999;transition: opacity 0.2s;}
        .c-circle{position:absolute;width:20px;height:20px;border-radius:50%;background:radial-gradient(circle,var(--pink),transparent);opacity:0.6;mix-blend-mode:screen;}
        
        /* Interaction Lock (When FAB is active) */
        body.fab-active #cursor { opacity: 0; }
        body.fab-active .btn, body.fab-active input { pointer-events: none; opacity: 0.5; }

        /* Info & Context */
        .info{position:fixed;top:80px;right:20px;background:rgba(20,20,30,0.9);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.2);border-radius:8px;padding:16px;min-width:250px;opacity:0;transition:0.3s;z-index:90;pointer-events:none;}
        .info.active{opacity:1;}
        .info-row{font-size:11px;margin:4px 0;display:flex;justify-content:space-between}
        
        .ctx{position:fixed;background:rgba(20,20,30,0.95);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.2);border-radius:8px;padding:8px 0;min-width:180px;display:none;z-index:1000}
        .ctx.active{display:block}
        .ctx-item{padding:8px 16px;cursor:pointer;font-size:12px;transition:0.2s}
        .ctx-item:hover{background:rgba(255,255,255,0.1)}
        .ctx-div{height:1px;background:rgba(255,255,255,0.1);margin:4px 0}
        
        .launch{position:fixed;bottom:60px;left:50%;transform:translateX(-50%);background:rgba(255,170,0,0.2);border:2px solid #fa0;color:#fa0;padding:12px 24px;border-radius:8px;font-size:12px;opacity:0;transition:0.3s;z-index:100}
        .launch.active{opacity:1}
        
        /* Mobile specific adjustments */
        @media (max-width: 768px) {
            .hud { display: none; }
            .fab-zone { bottom: 20px; transform: translateX(-50%) scale(0.9); }
            .bottom-bar, .pills { display: none; }
            .top-bar { top: 70px; }
            .coords { bottom: 10px; left: 10px; font-size: 10px; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="cursor"></div>
    <div id="mode" class="mode-status">FOCAL MODE ACTIVE</div>
    
    <div class="hud">[SCROLL] Dolly · [SHIFT+SCROLL] Focal · [LMB DRAG EMPTY] Pan XY · [ARROWS] Nav · [C] Create · [L] Launch · [SPACE] Drop Special</div>
    
    <div class="scales">
        <button class="btn active" data-s="day">DAY</button>
        <button class="btn" data-s="week">WEEK</button>
        <button class="btn" data-s="month">MONTH</button>
    </div>

    <div class="presets">
        <button class="btn active" data-p="std">STD</button>
        <button class="btn" data-p="top">TOP</button>
        <button class="btn" data-p="side">SIDE</button>
    </div>

    <div class="top-bar">
        <input id="search" type="text" placeholder="Search...">
    </div>

    <div class="bottom-bar">
        <input id="task-input" type="text" placeholder="Task name (e.g. 'Meeting h/4')">
        <button id="add-task">ADD</button>
    </div>

    <div class="pills">
        <button class="btn" data-t="1" data-u="h">1h</button>
        <button class="btn" data-t="4" data-u="h">4h</button>
        <button class="btn" data-t="8" data-u="h">8h</button>
        <button class="btn" data-t="1" data-u="d">1d</button>
        <button class="btn" data-t="3" data-u="d">3d</button>
        <button class="btn" data-t="7" data-u="d">7d</button>
        <button class="btn" data-t="14" data-u="d">14d</button>
        <button class="btn" data-t="30" data-u="d">30d</button>
    </div>

    <div class="coords" id="coord-display">X:0.0 Y:0.0 Z:0.0</div>

    <div id="info" class="info">
        <div class="info-title" id="iTitle">Task</div>
        <div class="info-row"><span style="opacity:0.6">Task:</span><span id="iText">-</span></div>
        <div class="info-row"><span style="opacity:0.6">Position:</span><span id="iPos">0,0,0</span></div>
        <div class="info-row"><span style="opacity:0.6">Priority:</span><span id="iPri">Normal</span></div>
        <div class="info-row"><span style="opacity:0.6">Time:</span><span id="iTime">0H</span></div>
        <div class="info-row"><span style="opacity:0.6">State:</span><span id="iState">Default</span></div>
        <div class="info-row"><span style="opacity:0.6">Deadline:</span><span id="iHard">None</span></div>
    </div>

    <div id="ctx" class="ctx">
        <div class="ctx-item" data-a="clone">Clone</div>
        <div class="ctx-item" data-a="priority">Priority</div>
        <div class="ctx-item" data-a="pulse">Pulse</div>
        <div class="ctx-div"></div>
        <div class="ctx-item" data-a="del">Delete</div>
    </div>
    <div id="launch" class="launch">LAUNCH: Click target</div>

    <div class="fab-zone" id="joystick">
        <div class="fab-cube" id="joy-cube">
            <div class="f-face"></div>
            <div class="f-face"></div>
            <div class="f-face"></div>
            <div class="f-face"></div>
            <div class="f-face"></div>
            <div class="f-face"></div>
        </div>
        <div class="fab-hint">NAV</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
    
    <script>
        class ThinFilm extends THREE.Texture {
          constructor(t=520){
              super();
              this.thickness = t;
              this.generate();
          }
          generate(){
              const w=512,h=1;
              const d=new Uint8Array(w*4);
              for(let i=0;i<w;i++){
                  const c=i/w;
                  const u=Math.pow(1-c,5);
                  const phase = this.thickness/100 * c * Math.PI * 2;
                  let r = 0.04 + 0.96*u + (Math.sin(phase)*0.5 + 0.5);
                  let g = u + (Math.sin(phase + 2*Math.PI/3)*0.5 + 0.5);
                  let b = u + (Math.sin(phase + 4*Math.PI/3)*0.5 + 0.5);
                  r = Math.max(0, Math.min(1, r));
                  g = Math.max(0, Math.min(1, g));
                  b = Math.max(0, Math.min(1, b));
                  d[i*4]=Math.floor(r*255);
                  d[i*4+1]=Math.floor(g*255);
                  d[i*4+2]=Math.floor(b*255);
                  d[i*4+3]=255;
              }
              this.image={data:d,width:w,height:h};
              this.magFilter=THREE.LinearFilter;
              this.minFilter=THREE.LinearFilter;
              this.wrapS=THREE.ClampToEdgeWrapping;
              this.wrapT=THREE.ClampToEdgeWrapping;
              this.needsUpdate=true;
          }
      }

        const CFG = {
            cam: { eye: {y:40} },
            preset: {
                std: { o: new THREE.Vector3(0,8,20), r: new THREE.Euler(-0.3,0,0) },
                top: { o: new THREE.Vector3(0,50,0.1), r: new THREE.Euler(-Math.PI/2,0,0) },
                side: { o: new THREE.Vector3(80, 0, 0), r: new THREE.Euler(0, Math.PI/2, 0) } // Looking down -X axis
            }
        };

        const sc = new THREE.Scene();
        sc.background = new THREE.Color(0x000000);
        sc.fog = new THREE.FogExp2(0x000000, 0.009);

        const cam = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 10077);

        const rend = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        rend.setSize(innerWidth, innerHeight);
        rend.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        rend.shadowMap.enabled = true;
        rend.shadowMap.type = THREE.PCFSoftShadowMap;

        const world = new CANNON.World();
        world.gravity.set(0, -19.81, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        const mat = new CANNON.Material();
        world.addContactMaterial(new CANNON.ContactMaterial(mat, mat, { friction: 0.3, restitution: 0.5 }));

        const rig = { mode: 'std', preset: 'std', piv: new THREE.Vector3(), tPiv: new THREE.Vector3() };
        const tm = { cubes: [], sel: null, hov: null, drag: null, launch: false, lSrc: null };

        let distanceScale = 1;
        let isPanning = false;
        let panStartIntersect = null;
        let currentScale = 'day';

        sc.add(new THREE.AmbientLight(0xffffff, 0.5));

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.6);
        dirLight.position.set(15, 40, 15);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        sc.add(dirLight);

        const neon1 = new THREE.PointLight(0x00ffff, 5, 80); neon1.position.set(-25, 20, -25); sc.add(neon1);
        const neon2 = new THREE.PointLight(0xff00ff, 5, 80); neon2.position.set(25, 20, 25); sc.add(neon2);
        const neon3 = new THREE.PointLight(0x00ff88, 4.5, 70); neon3.position.set(0, 30, 0); sc.add(neon3);

        const cRT = new THREE.WebGLCubeRenderTarget(512, { format: THREE.RGBFormat, generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter });
        const cCam = new THREE.CubeCamera(0.1, 1000, cRT);
        sc.add(cCam);

        const fMap = new ThinFilm(520);

        const pMat = new THREE.MeshPhysicalMaterial({ color: 0xFF1493, metalness: 0.1, roughness: 0.1, clearcoat: 1.0, clearcoatRoughness: 0, emissive: 0xFF1493, emissiveIntensity: 0.6, envMap: cRT.texture, envMapIntensity: 1.2 });
        const sMat = new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness: 0, roughness: 0, clearcoat: 1.0, clearcoatRoughness: 0, emissive: 0xFF1493, emissiveIntensity: 2, envMap: cRT.texture, envMapIntensity: 1.0 });

        const gnd = new THREE.Mesh(
          new THREE.PlaneGeometry(40, 100),
          new THREE.MeshStandardMaterial({ color: 0x0f0f1f, roughness: 0.85, metalness: 0.95, envMapIntensity: 1.3 })
        );
        gnd.rotation.x = -Math.PI / 2;
        gnd.position.y = -4;
        gnd.receiveShadow = true;
        sc.add(gnd);

        const gB = new CANNON.Body({ mass: 0, material: mat });
        gB.addShape(new CANNON.Plane());
        gB.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        gB.position.set(0, -4, 0);
        world.addBody(gB);

        const gridGrp = new THREE.Group();
        sc.add(gridGrp);

        function createGrid(scale) {
            while(gridGrp.children.length){ 
                const o = gridGrp.children[0]; 
                if(o.geometry) o.geometry.dispose();
                if(o.material) o.material.dispose();
                gridGrp.remove(o); 
            }
            
            let step, range, labelStep, textFunc;
            if (scale === 'day') { step=2; range=40; labelStep=4; textFunc = (z) => `${Math.abs(z)}H`; } 
            else if (scale === 'week') { step=10; range=100; labelStep=20; textFunc = (z) => `D${Math.abs(z/10)}`; } 
            else { step=20; range=200; labelStep=40; textFunc = (z) => ['JAN','FEB','MAR','APR','MAY','JUN'][Math.floor(Math.abs(z)/40)%6]; }

            for (let z = -range; z <= range; z += step) {
                const isMain = (z % labelStep === 0);
                const g = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-20, -3.9, z), new THREE.Vector3(20, -3.9, z)]);
                gridGrp.add(new THREE.Line(g, new THREE.LineBasicMaterial({ color: isMain ? 0x444466 : 0x2a2a3e })));
                if (isMain) {
                    const c = document.createElement('canvas'); c.width = 128; c.height = 64;
                    const x = c.getContext('2d'); x.fillStyle = '#666688'; x.font = 'bold 32px monospace'; x.textAlign = 'center'; x.fillText(textFunc(z), 64, 40);
                    const s = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(c), transparent:true, opacity:0.8 }));
                    s.position.set(22, -3.5, z); s.scale.set(4, 2, 1);
                    gridGrp.add(s);
                }
            }
        }
        createGrid('day');

        const ringGeo = new THREE.RingGeometry(1.8, 2.2, 32); ringGeo.rotateX(-Math.PI/2);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x39FF14, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
        const selRing = new THREE.Mesh(ringGeo, ringMat); selRing.visible = false; sc.add(selRing);

        class Cube {
          constructor(x, y, z, sz = 1.5) {
              this.sz = sz;
              this.pri = y;
              this.puls = false;
              this.st = 'def';

              const g = new THREE.BoxGeometry(sz, sz, sz);

              const hue = Math.random();
              const color = new THREE.Color().setHSL(hue, 1.0, 0.5);
              const baseMat = new THREE.MeshPhysicalMaterial({
                  color: color,
                  metalness: 1.0,
                  roughness: 0.05,
                  clearcoat: 1.0,
                  clearcoatRoughness: 0.0,
                  emissive: color,
                  emissiveIntensity: 3.0,
                  envMap: cRT.texture,
                  envMapIntensity: 1.6
              });

              this.baseMat = baseMat;
              this.pMat = pMat.clone();
              this.sMat = sMat.clone();
              this.oMat = Array(6).fill(this.baseMat);
              this.intensities = { def: 3.0, pk: 0.6, sup: 2.0 };

              this.m = new THREE.Mesh(g, this.oMat);
              this.m.position.set(x, y, z);
              this.m.castShadow = true;
              this.m.receiveShadow = true;
              this.m.userData.cube = this;

              const ed = new THREE.LineSegments(new THREE.EdgesGeometry(g), new THREE.LineBasicMaterial({ color: 0xffffff }));
              ed.visible = false;
              this.ed = ed;
              this.m.add(ed);
              sc.add(this.m);

              const sh = new CANNON.Box(new CANNON.Vec3(sz / 2, sz / 2, sz / 2));
              this.b = new CANNON.Body({ mass: 2, material: mat, type: CANNON.Body.DYNAMIC });
              this.b.addShape(sh);
              this.b.position.set(x, y, z);
              this.b.linearDamping = 0.3;
              this.b.angularDamping = 0.3;
              world.addBody(this.b);
          }
          updateTextSprite() {
              if (this.textSprite) this.m.remove(this.textSprite);
              if (!this.text) return;
              const canvas = document.createElement('canvas');
              canvas.width = 256;
              canvas.height = 128;
              const ctx = canvas.getContext('2d');
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 32px sans-serif';
              ctx.textAlign = 'center';
              ctx.fillText(this.text, 128, 64);
              const map = new THREE.CanvasTexture(canvas);
              const spriteMat = new THREE.SpriteMaterial({map});
              this.textSprite = new THREE.Sprite(spriteMat);
              this.textSprite.scale.set(4,2,1);
              this.textSprite.position.set(0, this.sz/2 + 1, 0);
              this.m.add(this.textSprite);
          }
          click() {
              if (this.st === 'def') {
                  this.m.material = Array(6).fill(this.pMat);
                  this.st = 'pk';
                  gsap.to(this.m.scale, { x: 1.1, y: 1.1, z: 1.1, duration: 0.2, ease: "back.out" });
              } else if (this.st === 'pk') {
                  this.m.material = Array(6).fill(this.sMat);
                  this.st = 'sup';
                  gsap.to(this.m.scale, { x: 1.3, y: 1.3, z: 1.3, duration: 0.3, yoyo: true, repeat: 5, ease: "sine.inOut" });
              } else {
                  this.m.material = Array(6).fill(this.baseMat);
                  this.st = 'def';
                  gsap.to(this.m.scale, { x: 1, y: 1, z: 1, duration: 0.2, ease: "power2.out" });
              }
          }
          sel() {
              this.ed.visible = true;
              tm.sel = this;
              this.upd();
          }
          desel() {
              this.ed.visible = false;
              if (tm.sel === this) { tm.sel = null; document.getElementById('info').classList.remove('active'); }
          }
          hov() {
              this.m.material.forEach(m => { if (m) m.emissiveIntensity = this.intensities[this.st] * 1.5; });
          }
          unhov() {
              this.m.material.forEach(m => { if (m) m.emissiveIntensity = this.intensities[this.st]; });
          }
          launch(tp) {
              const d = new THREE.Vector3().subVectors(tp, this.b.position);
              const ds = d.length();
              const imp = new CANNON.Vec3(d.x * 8, Math.sqrt(ds * 15) + 5, d.z * 8);
              this.b.applyImpulse(imp, this.b.position);
              this.b.angularVelocity.set((Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15);
          }
          sPri(p) {
              this.pri = p;
              gsap.to(this.b.position, {
                  y: p,
                  duration: 1.4,
                  ease: "elastic.out(1,0.4)",
                  onUpdate: () => this.b.wakeUp()
              });
          }
          tPuls() {
              this.puls = !this.puls;
              if (this.puls) {
                  const p = () => {
                      if (!this.puls) return;
                      gsap.to(this.m.scale, { x: 1.15, y: 1.15, z: 1.15, duration: 0.6, yoyo: true, repeat: 1, onComplete: p })
                  };
                  p();
              } else {
                  gsap.to(this.m.scale, { x: 1, y: 1, z: 1, duration: 0.3 });
              }
          }
          upd() {
              const pn = document.getElementById('info');
              pn.classList.add('active');
              document.getElementById('iTitle').textContent = 'Cube #' + (tm.cubes.indexOf(this) + 1);
              document.getElementById('iText').textContent = this.text || '-';
              document.getElementById('iPos').textContent = `${this.b.position.x.toFixed(1)},${this.b.position.y.toFixed(1)},${this.b.position.z.toFixed(1)}`;
              document.getElementById('iPri').textContent = this.pri > 3 ? 'High' : this.pri > 0 ? 'Normal' : 'Low';
              document.getElementById('iTime').textContent = `${Math.abs(this.b.position.z).toFixed(1)}Y`;
              document.getElementById('iState').textContent = this.st === 'def' ? 'Default' : this.st === 'pk' ? 'Pink' : 'Super';
              document.getElementById('iHard').textContent = this.hard ? this.hard + 'H' : 'None';
          }
          tick() {
              this.m.position.copy(this.b.position);
              this.m.quaternion.copy(this.b.quaternion);
          }
          rm() {
              sc.remove(this.m);
              world.removeBody(this.b);
              const i = tm.cubes.indexOf(this);
              if (i > -1) tm.cubes.splice(i, 1);
          }
      }

        const saved = localStorage.getItem('punt-tasks');
        if (saved) {
            const data = JSON.parse(saved);
            data.forEach(d => {
                const c = new Cube(d.pos.x, d.pos.y, d.pos.z);
                c.text = d.text;
                c.updateTextSprite();
                c.b.quaternion.set(d.quat.x, d.quat.y, d.quat.z, d.quat.w);
                c.pri = d.pri;
                c.sPri(d.pri);
                c.st = d.st;
                if (c.st === 'pk') c.m.material = Array(6).fill(c.pMat);
                else if (c.st === 'sup') c.m.material = Array(6).fill(c.sMat);
                c.puls = d.puls;
                if (c.puls) c.tPuls();
                c.z_target = d.z_target;
                c.hard = d.hard;
                tm.cubes.push(c);
            });
        } else {
            for (let i = 0; i < 12; i++) {
                const c = new Cube((Math.random() - 0.5) * 20, Math.random() * 4 + 1, (Math.random() - 0.5) * 60);
                tm.cubes.push(c);
            }
        }

        function shake() {
            tm.cubes.forEach(c => {
                c.b.wakeUp();
                const im = new CANNON.Vec3((Math.random() - 0.5) * 60, 30 + Math.random() * 70, (Math.random() - 0.5) * 60);
                c.b.applyImpulse(im, c.b.position);
                c.b.angularVelocity.set((Math.random() - 0.5) * 120, (Math.random() - 0.5) * 120, (Math.random() - 0.5) * 120);
            });
        }

        const rc = new THREE.Raycaster(), ms = new THREE.Vector2(), intersect = new THREE.Vector3();
        function upMs(e) { ms.x = (e.clientX / innerWidth) * 2 - 1; ms.y = -(e.clientY / innerHeight) * 2 + 1; }
        function getC() { rc.setFromCamera(ms, cam); const in_ = rc.intersectObjects(tm.cubes.map(c => c.m)); return in_.length > 0 ? in_[0].object.userData.cube : null; }
        function getG(e) {
            upMs(e);
            rc.setFromCamera(ms, cam);
            const planeY = tm.drag ? tm.drag.b.position.y : 0;
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -planeY);
            if (rc.ray.intersectPlane(plane, intersect)) return intersect;
            return null;
        }

        addEventListener('wheel', e => {
            e.preventDefault();
            if (e.shiftKey) {
                cam.fov += e.deltaY * 0.05;
                cam.fov = Math.max(10, Math.min(120, cam.fov));
                cam.updateProjectionMatrix();
            } else {
                distanceScale += e.deltaY * 0.001;
                distanceScale = Math.max(0.2, Math.min(10, distanceScale));
            }
        });

        addEventListener('mousemove', e => {
            upMs(e);
            const hc = getC();
            if (hc !== tm.hov) { if (tm.hov) tm.hov.unhov(); tm.hov = hc; if (hc) hc.hov(); }
            if (tm.drag && e.buttons & 1) {
                const gp = getG(e);
                if (gp) {
                    tm.drag.b.position.copy(gp);
                }
            } else if (isPanning && e.buttons & 1) {
                const gp = getG(e);
                if (gp && panStartIntersect) {
                    const delta = new THREE.Vector3().subVectors(gp, panStartIntersect);
                    rig.tPiv.sub(delta);
                    panStartIntersect.copy(gp);
                }
            }
        });

        addEventListener('mousedown', e => {
            upMs(e);
            if (tm.launch && tm.lSrc) {
                const gp = getG(e);
                if (gp) {
                    gp.y = tm.lSrc.b.position.y;
                    tm.lSrc.launch(gp);
                    tm.launch = false; tm.lSrc = null;
                    document.getElementById('launch').classList.remove('active');
                }
                return;
            }
            const c = getC();
            if (c) {
                if (tm.sel && tm.sel !== c) tm.sel.desel();
                c.click();
                c.sel();
                tm.drag = c;
                c.originalY = c.b.position.y;
                c.b.type = CANNON.Body.KINEMATIC;
                gsap.to(c.b.position, { y: c.originalY + 3, duration: 0.2, ease: "power2.out" });
            } else {
                const gp = getG(e);
                if (gp) {
                    isPanning = true;
                    panStartIntersect = gp.clone();
                } else {
                    if (tm.sel) tm.sel.desel();
                }
            }
        });

        addEventListener('mouseup', () => {
            if (tm.drag) {
                const c = tm.drag;
                gsap.to(c.b.position, { y: c.originalY, duration: 0.3, ease: "power1.in", onComplete: () => {
                    c.b.type = CANNON.Body.DYNAMIC;
                } });
            }
            tm.drag = null;
            isPanning = false;
            panStartIntersect = null;
        });
        addEventListener('contextmenu', e => { e.preventDefault(); upMs(e); const c = getC(); if (c) { const m = document.getElementById('ctx'); m.style.left = e.clientX + 'px'; m.style.top = e.clientY + 'px'; m.classList.add('active'); tm.sel = c; } });
        addEventListener('click', () => { document.getElementById('ctx').classList.remove('active'); });

        document.querySelectorAll('.ctx-item').forEach(it => {
            it.addEventListener('click', e => {
                e.stopPropagation();
                const a = it.dataset.a, c = tm.sel;
                if (!c) return;
                switch (a) {
                    case 'clone':
                        const cl = new Cube(c.b.position.x + 2, c.b.position.y, c.b.position.z, c.sz);
                        cl.text = c.text;
                        cl.updateTextSprite();
                        tm.cubes.push(cl);
                        break;
                    case 'priority': c.sPri((c.pri + 2) % 6); break;
                    case 'pulse': c.tPuls(); break;
                    case 'del': c.rm(); tm.sel = null; document.getElementById('info').classList.remove('active'); break;
                }
            });
        });

        const k = {};
        addEventListener('keydown', e => {
            k[e.key] = true;
            if (e.key === 'Shift') { rig.mode = 'eye'; document.getElementById('mode').classList.add('active'); }
            if (e.key === 'c' || e.key === 'C') {
                const c = new Cube(rig.piv.x + (Math.random() - 0.5) * 10, rig.piv.y + Math.random() * 4 + 1, rig.piv.z + (Math.random() - 0.5) * 10);
                c.text = 'New Task';
                c.updateTextSprite();
                tm.cubes.push(c);
            }
            if (e.key === 'l' || e.key === 'L') {
                if (tm.sel) { tm.launch = true; tm.lSrc = tm.sel; document.getElementById('launch').classList.add('active'); }
            }
            if (e.key === ' ') { e.preventDefault(); shake(); }
            if (e.key === 'Escape' && tm.launch) { tm.launch = false; tm.lSrc = null; document.getElementById('launch').classList.remove('active'); }
        });
        addEventListener('keyup', e => { k[e.key] = false; if (e.key === 'Shift') { rig.mode = 'std'; document.getElementById('mode').classList.remove('active'); } });

        setInterval(() => {
            const s = 0.8;
            if (rig.preset === 'side' && tm.sel) {
                if (k.ArrowLeft) tm.sel.b.position.z -= s;
                if (k.ArrowRight) tm.sel.b.position.z += s;
                if (k.ArrowUp) tm.sel.b.position.y += s;
                if (k.ArrowDown) tm.sel.b.position.y -= s;
                tm.sel.b.wakeUp();
            } else {
                if (k.ArrowUp) rig.tPiv.z -= s;
                if (k.ArrowDown) rig.tPiv.z += s;
                if (k.ArrowLeft) rig.tPiv.x -= s;
                if (k.ArrowRight) rig.tPiv.x += s;
            }
        }, 16);

        document.querySelectorAll('[data-p]').forEach(b => {
            b.addEventListener('click', () => {
                document.querySelectorAll('[data-p]').forEach(x => x.classList.remove('active'));
                b.classList.add('active');
                rig.preset = b.dataset.p;
            });
        });

        document.querySelectorAll('[data-s]').forEach(b => {
            b.addEventListener('click', () => {
                document.querySelectorAll('[data-s]').forEach(x => x.classList.remove('active'));
                b.classList.add('active');
                currentScale = b.dataset.s;
                createGrid(currentScale);
            });
        });

        const taskInput = document.getElementById('task-input');
        const addTaskBtn = document.getElementById('add-task');
        function addTask() {
            let text = taskInput.value.trim();
            if (!text) return;
            taskInput.value = '';

            let z_target;
            const hMatch = text.match(/h\/(\d+)/);
            if (hMatch) {
                z_target = parseInt(hMatch[1]);
                text = text.replace(/h\/\d+/, '').trim();
            }
            const dMatch = text.match(/d\/(\d+)/);
            if (dMatch) {
                z_target = parseInt(dMatch[1]) * 24;
                text = text.replace(/d\/\d+/, '').trim();
            }
            let hard;
            const hardMatch = text.match(/hard\/(\d+)(h|d)?/);
            if (hardMatch) {
                const num = parseInt(hardMatch[1]);
                const unit = hardMatch[2] || 'h';
                hard = num * (unit === 'd' ? 24 : 1);
                text = text.replace(/hard\/\d+(h|d)?/, '').trim();
            }

            const c = new Cube((Math.random() - 0.5) * 20, Math.random() * 4 + 1, (Math.random() - 0.5) * 10);
            c.text = text || 'Task';
            c.updateTextSprite();
            if (z_target !== undefined) c.z_target = z_target;
            if (hard !== undefined) c.hard = hard;
            tm.cubes.push(c);
        }
        addTaskBtn.addEventListener('click', addTask);
        taskInput.addEventListener('keydown', e => { if (e.key === 'Enter') addTask(); });

        document.querySelectorAll('.pills .btn').forEach(b => {
            b.addEventListener('click', () => {
                const t = b.dataset.t, u = b.dataset.u;
                const c = new Cube(rig.piv.x, Math.random() * 4 + 1, rig.piv.z);
                c.z_target = parseInt(t) * (u === 'd' ? 24 : 1);
                c.text = `${t}${u} Task`;
                c.updateTextSprite();
                tm.cubes.push(c);
            });
        });

        document.getElementById('search').addEventListener('input', e => {
            const val = e.target.value.toLowerCase();
            tm.cubes.forEach(c => {
                const show = !val || c.text.toLowerCase().includes(val);
                c.m.visible = show;
                if (c.textSprite) c.textSprite.visible = show;
            });
        });

        const tl = 14, h = document.getElementById('cursor');
        for (let i = 0; i < tl; i++) { const d = document.createElement('div'); d.className = 'c-circle'; h.appendChild(d); }
        const cs = h.querySelectorAll('.c-circle');
        let mX = innerWidth / 2, mY = innerHeight / 2;
        const hist = Array(tl).fill(0).map(() => ({ x: mX, y: mY }));
        addEventListener('pointermove', e => { mX = e.clientX; mY = e.clientY; }, { passive: true });
        function cTick() {
            hist.shift(); hist.push({ x: mX, y: mY });
            cs.forEach((c, i) => {
                const cur = hist[i];
                const nx = hist[i + 1] || hist[tl - 1];
                cur.x += (nx.x - cur.x) * 0.35;
                cur.y += (nx.y - cur.y) * 0.35;
                const s = Math.max(0.22, (tl - i) / tl * 1.2);
                c.style.transform = `translate(calc(${cur.x}px - 50%), calc(${cur.y}px - 50%)) scale(${s})`;
            });
            requestAnimationFrame(cTick);
        }
        cTick();

        addEventListener('beforeunload', () => {
            const data = tm.cubes.map(c => ({
                text: c.text,
                pos: { x: c.b.position.x, y: c.b.position.y, z: c.b.position.z },
                quat: { x: c.b.quaternion.x, y: c.b.quaternion.y, z: c.b.quaternion.z, w: c.b.quaternion.w },
                pri: c.pri,
                st: c.st,
                puls: c.puls,
                z_target: c.z_target,
                hard: c.hard
            }));
            localStorage.setItem('punt-tasks', JSON.stringify(data));
        });

        const joy = { el: document.getElementById('joy-cube'), zone: document.getElementById('joystick'), active: false, start: {x:0, y:0} };

        function handleJoy(x, y) {
            const max = 40;
            let dx = x - joy.start.x, dy = y - joy.start.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist > max) { const r = max/dist; dx*=r; dy*=r; }

            joy.el.style.transform = `rotateX(${-25 + (dy/max*45)}deg) rotateY(${-45 + (dx/max*45)}deg)`;
            
            const speed = 0.8;
            if (rig.preset === 'side' && tm.sel) {
                tm.sel.b.position.y -= dy / max * speed;
                tm.sel.b.position.z -= dx / max * speed;
                tm.sel.b.wakeUp();
            } else {
                rig.tPiv.z += dy / max * speed;
                rig.tPiv.x += dx / max * speed;
            }
        }

        function startJoy(x, y) {
            joy.active = true; joy.start = {x, y};
            joy.el.style.transition = 'none';
            document.body.classList.add('fab-active'); 
        }

        function endJoy() {
            joy.active = false;
            joy.el.style.transition = 'transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
            joy.el.style.transform = `rotateX(-25deg) rotateY(-45deg)`;
            document.body.classList.remove('fab-active');
        }

        joy.zone.addEventListener('mousedown', e => { startJoy(e.clientX, e.clientY); e.stopPropagation(); });
        joy.zone.addEventListener('touchstart', e => { startJoy(e.touches[0].clientX, e.touches[0].clientY); e.stopPropagation(); });
        
        addEventListener('mousemove', e => { if(joy.active) handleJoy(e.clientX, e.clientY); });
        addEventListener('touchmove', e => { if(joy.active && e.touches.length === 1) handleJoy(e.touches[0].clientX, e.touches[0].clientY); });
        
        addEventListener('mouseup', endJoy);
        addEventListener('touchend', endJoy);

        let lt = 0;
        const coordD = document.getElementById('coord-display');
        function anim() {
            requestAnimationFrame(anim);
            const ct = performance.now() / 1000, dt = Math.min(ct - lt, 0.1); lt = ct;

            world.step(1 / 60, dt, 3);
            tm.cubes.forEach(c => c.tick());

            rig.piv.lerp(rig.tPiv, 0.1);

            const p = CFG.preset[rig.preset];

            if (rig.mode === 'eye') {
                const height = CFG.cam.eye.y * distanceScale;
                cam.position.lerp(new THREE.Vector3(rig.piv.x, height, rig.piv.z), 0.1);
                cam.lookAt(rig.piv);
            } else {
                const offset = p.o.clone().multiplyScalar(distanceScale);
                const tp = new THREE.Vector3().copy(rig.piv).add(offset);
                cam.position.lerp(tp, 0.1);
                cam.rotation.x += (p.r.x - cam.rotation.x) * 0.1;
                cam.rotation.y += (p.r.y - cam.rotation.y) * 0.1;
                cam.rotation.z += (p.r.z - cam.rotation.z) * 0.1;
            }

            cCam.update(rend, sc);

            if (tm.sel && (rig.preset === 'top' || rig.preset === 'side')) {
                selRing.visible = true;
                selRing.position.copy(tm.sel.m.position);
                selRing.position.y = -3.99;
                const s = 1 + Math.sin(ct * 2) * 0.1;
                selRing.scale.set(s, 1, s);
            } else {
                selRing.visible = false;
            }

            coordD.textContent = `X:${rig.piv.x.toFixed(1)} Y:${rig.piv.y.toFixed(1)} Z:${rig.piv.z.toFixed(1)}`;

            rend.render(sc, cam);
        }

        addEventListener('resize', () => { cam.aspect = innerWidth / innerHeight; cam.updateProjectionMatrix(); rend.setSize(innerWidth, innerHeight); });
        anim();
    </script>
</body>
</html>
