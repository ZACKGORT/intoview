<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PUNT: Interactive TO-DO List</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
    <style>
        :root{--bg:#0f1014;--accent:#39FF14;--pink:#FF1493}
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:var(--bg);overflow:hidden;color:#fff;font-family:'JetBrains Mono',monospace;cursor:none}
        #canvas{display:block;width:100vw;height:100vh}
        .hud{position:fixed;bottom:1rem;left:20px;font-size:11px;opacity:0.6;z-index:100}
        .key{color:var(--accent);font-weight:bold}
        .mode-status{position:fixed;top:20px;left:50%;transform:translateX(-50%);background:rgba(255,255,255,0.05);padding:8px 16px;border-radius:20px;border:1px solid rgba(255,255,255,0.1);opacity:0;transition:0.3s;z-index:100}
        .mode-status.active{opacity:1;color:var(--pink);border-color:var(--pink)}
        .presets{position:fixed;top:20px;right:20px;display:flex;gap:8px;z-index:100}
        .scales{position:fixed;top:20px;left:20px;display:flex;gap:8px;z-index:100}
        .btn{background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);color:#fff;padding:8px 12px;border-radius:6px;cursor:pointer;font-size:10px;font-family:inherit;transition:0.2s}
        .btn:hover{background:rgba(255,255,255,0.1);border-color:var(--accent)}
        .btn.active{border-color:var(--pink);color:var(--pink)}
        .info{position:fixed;top:80px;right:20px;background:rgba(20,20,30,0.9);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.2);border-radius:8px;padding:16px;min-width:250px;opacity:0;transition:0.3s;z-index:100}
        .info.active{opacity:1}
        .info-title{font-size:14px;font-weight:bold;margin-bottom:8px;color:var(--accent)}
        .info-row{font-size:11px;margin:4px 0;display:flex;justify-content:space-between}
        .launch{position:fixed;bottom:60px;left:50%;transform:translateX(-50%);background:rgba(255,170,0,0.2);border:2px solid #fa0;color:#fa0;padding:12px 24px;border-radius:8px;font-size:12px;opacity:0;transition:0.3s;z-index:100}
        .launch.active{opacity:1}
        .ctx{position:fixed;background:rgba(20,20,30,0.95);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.2);border-radius:8px;padding:8px 0;min-width:180px;display:none;z-index:1000}
        .ctx.active{display:block}
        .ctx-item{padding:8px 16px;cursor:pointer;font-size:12px;transition:0.2s}
        .ctx-item:hover{background:rgba(255,255,255,0.1)}
        .ctx-div{height:1px;background:rgba(255,255,255,0.1);margin:4px 0}
        #cursor{position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:9999}
        .c-circle{position:absolute;width:20px;height:20px;border-radius:50%;background:radial-gradient(circle,var(--pink),transparent);opacity:0.6;mix-blend-mode:screen}
        .top-bar{position:fixed;top:60px;left:50%;transform:translateX(-50%);z-index:100}
        .top-bar input{background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);color:#fff;padding:8px 12px;border-radius:6px;font-family:inherit;width:200px;}
        .bottom-bar{position:fixed;bottom:5.5rem;left:50%;transform:translateX(-50%);display:flex;gap:8px;z-index:100}
        .bottom-bar input{background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);color:#fff;padding:8px 12px;border-radius:6px;font-family:inherit;width:300px;}
        .bottom-bar button{background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);color:#fff;padding:8px 12px;border-radius:6px;cursor:pointer;font-size:10px;font-family:inherit;transition:0.2s}
        .bottom-bar button:hover{background:rgba(255,255,255,0.1);border-color:var(--accent)}
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="cursor"></div>
    <div id="mode" class="mode-status">BIRDS-EYE / FOCAL MODE</div>
    <div class="hud">[SCROLL] Dolly · [SHIFT+SCROLL] Focal · [LMB DRAG EMPTY] Pan XY · [ARROWS] Nav · [C] Create · [L] Launch · [SPACE] Shake</div>
    <div class="scales">
        <button class="btn active" data-s="day">DAY</button>
        <button class="btn" data-s="week">WEEK</button>
        <button class="btn" data-s="month">MONTH</button>
    </div>
    <div class="presets">
        <button class="btn active" data-p="std">STD</button>
        <button class="btn" data-p="top">TOP</button>
        <button class="btn" data-p="side">SIDE</button>
        <button class="btn" data-p="iso">ISO</button>
    </div>
    <div class="top-bar">
        <input id="search" type="text" placeholder="Search tasks...">
    </div>
    <div class="bottom-bar">
        <input id="task-input" type="text" placeholder="Enter task... h/16 d/3 hard/48h">
        <button id="add-task">Add</button>
    </div>
    <div id="ctx" class="ctx">
        <div class="ctx-item" data-a="clone">Clone</div>
        <div class="ctx-item" data-a="priority">Priority</div>
        <div class="ctx-item" data-a="pulse">Pulse</div>
        <div class="ctx-div"></div>
        <div class="ctx-item" data-a="del">Delete</div>
    </div>
    <div id="info" class="info">
        <div class="info-title" id="iTitle">Task</div>
        <div class="info-row"><span style="opacity:0.6">Task:</span><span id="iText">-</span></div>
        <div class="info-row"><span style="opacity:0.6">Position:</span><span id="iPos">0,0,0</span></div>
        <div class="info-row"><span style="opacity:0.6">Priority:</span><span id="iPri">Normal</span></div>
        <div class="info-row"><span style="opacity:0.6">Time:</span><span id="iTime">0H</span></div>
        <div class="info-row"><span style="opacity:0.6">State:</span><span id="iState">Default</span></div>
        <div class="info-row"><span style="opacity:0.6">Deadline:</span><span id="iHard">None</span></div>
    </div>
    <div id="launch" class="launch">LAUNCH: Click target</div>
    <script>
        /* ---------- ThinFilm (kept) ---------- */
        class ThinFilm extends THREE.Texture {
            constructor(t=520){
                super();
                this.thickness = t;
                this.generate();
            }
            generate(){
                const w=512,h=1;
                const d=new Uint8Array(w*4);
                for(let i=0;i<w;i++){
                    const c=i/w;
                    const u=Math.pow(1-c,5);
                    const phase = this.thickness/100 * c * Math.PI * 2;
                    let r = 0.04 + 0.96*u + (Math.sin(phase)*0.5 + 0.5);
                    let g = u + (Math.sin(phase + 2*Math.PI/3)*0.5 + 0.5);
                    let b = u + (Math.sin(phase + 4*Math.PI/3)*0.5 + 0.5);
                    r = Math.max(0, Math.min(1, r));
                    g = Math.max(0, Math.min(1, g));
                    b = Math.max(0, Math.min(1, b));
                    d[i*4]=Math.floor(r*255);
                    d[i*4+1]=Math.floor(g*255);
                    d[i*4+2]=Math.floor(b*255);
                    d[i*4+3]=255;
                }
                this.image={data:d,width:w,height:h};
                this.magFilter=THREE.LinearFilter;
                this.minFilter=THREE.LinearFilter;
                this.wrapS=THREE.ClampToEdgeWrapping;
                this.wrapT=THREE.ClampToEdgeWrapping;
                this.needsUpdate=true;
            }
        }

        /* ---------- Config & Scene ---------- */
        const CFG={cam:{eye:{y:40}},preset:{std:{o:new THREE.Vector3(0,8,20),r:new THREE.Euler(-0.3,0,0)},top:{o:new THREE.Vector3(0,50,0.1),r:new THREE.Euler(-Math.PI/2,0,0)},side:{o:new THREE.Vector3(30,5,0),r:new THREE.Euler(0,-Math.PI/2,0)},iso:{o:new THREE.Vector3(20,20,20),r:new THREE.Euler(-0.6,-0.8,0)}}};

        const sc = new THREE.Scene();
        // Lighting look from the neon scene:
        sc.background = new THREE.Color(0x000000);
        sc.fog = new THREE.FogExp2(0x000000, 0.005);

        const cam = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
        cam.fov = 75;

        const rend = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        rend.setSize(innerWidth, innerHeight);
        rend.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        rend.shadowMap.enabled = true;
        rend.shadowMap.type = THREE.PCFSoftShadowMap;

        /* ---------- Physics world (unchanged) ---------- */
        const world = new CANNON.World();
        world.gravity.set(0, -19.81, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        const mat = new CANNON.Material();
        world.addContactMaterial(new CANNON.ContactMaterial(mat, mat, { friction: 0.3, restitution: 0.5 }));

        /* ---------- State ---------- */
        const rig = { mode: 'std', preset: 'std', piv: new THREE.Vector3(), tPiv: new THREE.Vector3() };
        const tm = { cubes: [], sel: null, hov: null, drag: null, launch: false, lSrc: null };

        let distanceScale = 1;
        let isPanning = false;
        let panStartIntersect = null;
        let currentScale = 'day';
        let lines = [];
        let labels = [];

        /* ---------- Lighting ---------- */
        sc.add(new THREE.AmbientLight(0xffffff, 0.8));
        sc.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));

        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(20, 50, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        sc.add(dirLight);

        /* ---------- Cube environment reflection (cube render target) ---------- */
        const cRT = new THREE.WebGLCubeRenderTarget(512, { format: THREE.RGBFormat, generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter });
        const cCam = new THREE.CubeCamera(0.1, 1000, cRT);
        sc.add(cCam);

        const fMap = new ThinFilm(520);

        /* ---------- Click / state materials (kept) ---------- */
        const pMat = new THREE.MeshPhysicalMaterial({ color: 0xFF1493, metalness: 0.1, roughness: 0.1, clearcoat: 1.0, clearcoatRoughness: 0, emissive: 0xFF1493, emissiveIntensity: 0.6, envMap: cRT.texture, envMapIntensity: 1.2 });
        const sMat = new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness: 0, roughness: 0, clearcoat: 1.0, clearcoatRoughness: 0, emissive: 0xFF1493, emissiveIntensity: 2, envMap: cRT.texture, envMapIntensity: 1.0 });

        /* ---------- Ground (material updated to neon scene style, but kept at same y -4) ---------- */
        const gnd = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 100),
            new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.85, metalness: 0.95, envMapIntensity: 1.3 })
        );
        gnd.rotation.x = -Math.PI / 2;
        gnd.position.y = -4;
        gnd.receiveShadow = true;
        sc.add(gnd);

        const gB = new CANNON.Body({ mass: 0, material: mat });
        gB.addShape(new CANNON.Plane());
        gB.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        gB.position.set(0, -4, 0);
        world.addBody(gB);

        /* ---------- Timeline grid lines & year markers (kept) ---------- */
        for (let i = -50; i <= 50; i += 5) {
            const g = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-20, -3.9, i), new THREE.Vector3(20, -3.9, i)]);
            sc.add(new THREE.Line(g, new THREE.LineBasicMaterial({ color: i % 10 === 0 ? 0x444466 : 0x2a2a3e })));
            if (i % 10 === 0) {
                const c = document.createElement('canvas'); c.width = 128; c.height = 64;
                const x = c.getContext('2d');
                x.fillStyle = '#666688';
                x.font = 'bold 32px JetBrains Mono';
                x.textAlign = 'center';
                x.fillText(Math.abs(i) + 'Y', 64, 40);
                const s = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(c) }));
                s.position.set(22, -3.5, i);
                s.scale.set(4, 2, 1);
                sc.add(s);
            }
        }

        /* ---------- Cube class: uses neon scene cube material style (random hue + strong emissive) ---------- */
        class Cube {
            constructor(x, y, z, sz = 1.5) {
                this.sz = sz;
                this.pri = y;
                this.puls = false;
                this.st = 'def';

                const g = new THREE.BoxGeometry(sz, sz, sz);

                // new neon cube material per cube (random hue, high emissive)
                const hue = Math.random();
                const color = new THREE.Color().setHSL(hue, 1.0, 0.5); // saturated neon-ish
                const baseMat = new THREE.MeshPhysicalMaterial({
                    color: color,
                    metalness: 1.0,
                    roughness: 0.05,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.0,
                    emissive: color,
                    emissiveIntensity: 3.0,
                    envMap: cRT.texture,
                    envMapIntensity: 1.6
                });

                this.oMat = Array(6).fill(baseMat);
                this.m = new THREE.Mesh(g, this.oMat);
                this.m.position.set(x, y, z);
                this.m.castShadow = true;
                this.m.receiveShadow = true;
                this.m.userData.cube = this;

                const ed = new THREE.LineSegments(new THREE.EdgesGeometry(g), new THREE.LineBasicMaterial({ color: 0xffffff }));
                ed.visible = false;
                this.ed = ed;
                this.m.add(ed);
                sc.add(this.m);

                const sh = new CANNON.Box(new CANNON.Vec3(sz / 2, sz / 2, sz / 2));
                this.b = new CANNON.Body({ mass: 2, material: mat });
                this.b.addShape(sh);
                this.b.position.set(x, y, z);
                this.b.linearDamping = 0.3;
                this.b.angularDamping = 0.3;
                world.addBody(this.b);
            }
            click() {
                if (this.st === 'def') {
                    this.m.material = Array(6).fill(pMat);
                    this.st = 'pk';
                    gsap.to(this.m.scale, { x: 1.1, y: 1.1, z: 1.1, duration: 0.2, ease: "back.out" });
                } else if (this.st === 'pk') {
                    this.m.material = Array(6).fill(sMat);
                    this.st = 'sup';
                    gsap.to(this.m.scale, { x: 1.3, y: 1.3, z: 1.3, duration: 0.3, yoyo: true, repeat: 5, ease: "sine.inOut" });
                } else {
                    this.m.material = this.oMat;
                    this.st = 'def';
                    gsap.to(this.m.scale, { x: 1, y: 1, z: 1, duration: 0.2, ease: "power2.out" });
                }
            }
            sel() {
                this.ed.visible = true;
                tm.sel = this;
                this.upd();
            }
            desel() {
                this.ed.visible = false;
                if (tm.sel === this) { tm.sel = null; document.getElementById('info').classList.remove('active'); }
            }
            hov() {
                this.m.material.forEach(m => { if (m && m.emissive) m.emissive.setHex(0x333333); });
            }
            unhov() {
                this.m.material.forEach(m => { if (m && m.emissive) m.emissive.setHex(0x000000); });
            }
            launch(tp) {
                const d = new THREE.Vector3().subVectors(tp, this.b.position);
                const ds = d.length();
                const imp = new CANNON.Vec3(d.x * 8, Math.sqrt(ds * 15) + 5, d.z * 8);
                this.b.applyImpulse(imp, this.b.position);
                this.b.angularVelocity.set((Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15);
            }
            sPri(p) {
                this.pri = p;
                gsap.to(this.b.position, {
                    y: p,
                    duration: 1.4,
                    ease: "elastic.out(1,0.4)",
                    onUpdate: () => this.b.wakeUp()
                });
            }
            tPuls() {
                this.puls = !this.puls;
                if (this.puls) {
                    const p = () => {
                        if (!this.puls) return;
                        gsap.to(this.m.scale, { x: 1.15, y: 1.15, z: 1.15, duration: 0.6, yoyo: true, repeat: 1, onComplete: p })
                    };
                    p();
                } else {
                    gsap.to(this.m.scale, { x: 1, y: 1, z: 1, duration: 0.3 });
                }
            }
            upd() {
                const pn = document.getElementById('info');
                pn.classList.add('active');
                document.getElementById('iTitle').textContent = 'Cube #' + (tm.cubes.indexOf(this) + 1);
                document.getElementById('iPos').textContent = `${this.b.position.x.toFixed(1)},${this.b.position.y.toFixed(1)},${this.b.position.z.toFixed(1)}`;
                document.getElementById('iPri').textContent = this.pri > 3 ? 'High' : this.pri > 0 ? 'Normal' : 'Low';
                document.getElementById('iTime').textContent = `${Math.abs(this.b.position.z).toFixed(1)}Y`;
                document.getElementById('iState').textContent = this.st === 'def' ? 'Default' : this.st === 'pk' ? 'Pink' : 'Super';
            }
            tick() {
                this.m.position.copy(this.b.position);
                this.m.quaternion.copy(this.b.quaternion);
            }
            rm() {
                sc.remove(this.m);
                world.removeBody(this.b);
                const i = tm.cubes.indexOf(this);
                if (i > -1) tm.cubes.splice(i, 1);
            }
        }

        /* ---------- Initial cubes ---------- */
        for (let i = 0; i < 12; i++) {
            const c = new Cube((Math.random() - 0.5) * 20, Math.random() * 4 + 1, (Math.random() - 0.5) * 60);
            tm.cubes.push(c);
        }

        function shake() {
            tm.cubes.forEach(c => {
                c.b.wakeUp();
                const im = new CANNON.Vec3((Math.random() - 0.5) * 60, 30 + Math.random() * 70, (Math.random() - 0.5) * 60);
                c.b.applyImpulse(im, c.b.position);
                c.b.angularVelocity.set((Math.random() - 0.5) * 120, (Math.random() - 0.5) * 120, (Math.random() - 0.5) * 120);
            });
        }

        /* ---------- Raycaster & helpers ---------- */
        const rc = new THREE.Raycaster(), ms = new THREE.Vector2();
        function upMs(e) { ms.x = (e.clientX / innerWidth) * 2 - 1; ms.y = -(e.clientY / innerHeight) * 2 + 1; }
        function getC() { rc.setFromCamera(ms, cam); const in_ = rc.intersectObjects(tm.cubes.map(c => c.m)); return in_.length > 0 ? in_[0].object.userData.cube : null; }
        function getG() { rc.setFromCamera(ms, cam); const in_ = rc.intersectObject(gnd); return in_.length > 0 ? in_[0].point : null; }

        /* ---------- Controls / events (kept) ---------- */
        addEventListener('wheel', e => {
            e.preventDefault();
            if (e.shiftKey) {
                cam.fov += e.deltaY * 0.05;
                cam.fov = Math.max(10, Math.min(120, cam.fov));
                cam.updateProjectionMatrix();
            } else {
                distanceScale += e.deltaY * 0.001;
                distanceScale = Math.max(0.2, Math.min(10, distanceScale));
            }
        });

        addEventListener('mousemove', e => {
            upMs(e);
            const hc = getC();
            if (hc !== tm.hov) { if (tm.hov) tm.hov.unhov(); tm.hov = hc; if (hc) hc.hov(); }
            if (tm.drag && e.buttons & 1) {
                const gp = getG();
                if (gp) {
                    tm.drag.b.position.x = gp.x;
                    tm.drag.b.position.z = gp.z;
                    tm.drag.b.velocity.x = 0;
                    tm.drag.b.velocity.z = 0;
                    tm.drag.b.wakeUp();
                }
            } else if (isPanning && e.buttons & 1) {
                const gp = getG();
                if (gp && panStartIntersect) {
                    const delta = new THREE.Vector3().subVectors(gp, panStartIntersect);
                    rig.tPiv.sub(delta);
                    panStartIntersect.copy(gp);
                }
            }
        });

        addEventListener('mousedown', e => {
            upMs(e);
            if (tm.launch && tm.lSrc) {
                const gp = getG();
                if (gp) {
                    gp.y = tm.lSrc.b.position.y;
                    tm.lSrc.launch(gp);
                    tm.launch = false; tm.lSrc = null;
                    document.getElementById('launch').classList.remove('active');
                }
                return;
            }
            const c = getC();
            if (c) {
                if (tm.sel && tm.sel !== c) tm.sel.desel();
                c.click();
                c.sel();
                tm.drag = c;
            } else {
                const gp = getG();
                if (gp) {
                    isPanning = true;
                    panStartIntersect = gp.clone();
                } else {
                    if (tm.sel) tm.sel.desel();
                }
            }
        });

        addEventListener('mouseup', () => { tm.drag = null; isPanning = false; panStartIntersect = null; });
        addEventListener('contextmenu', e => { e.preventDefault(); upMs(e); const c = getC(); if (c) { const m = document.getElementById('ctx'); m.style.left = e.clientX + 'px'; m.style.top = e.clientY + 'px'; m.classList.add('active'); tm.sel = c; } });
        addEventListener('click', () => { document.getElementById('ctx').classList.remove('active'); });

        document.querySelectorAll('.ctx-item').forEach(it => {
            it.addEventListener('click', e => {
                e.stopPropagation();
                const a = it.dataset.a, c = tm.sel;
                if (!c) return;
                switch (a) {
                    case 'clone':
                        const cl = new Cube(c.b.position.x + 2, c.b.position.y, c.b.position.z, c.sz);
                        tm.cubes.push(cl);
                        break;
                    case 'priority': c.sPri((c.pri + 2) % 6); break;
                    case 'pulse': c.tPuls(); break;
                    case 'del': c.rm(); tm.sel = null; document.getElementById('info').classList.remove('active'); break;
                }
            });
        });

        /* ---------- Keys & rigs ---------- */
        const k = {};
        addEventListener('keydown', e => {
            k[e.key] = true;
            if (e.key === 'Shift') { rig.mode = 'eye'; document.getElementById('mode').classList.add('active'); }
            if (e.key === 'c' || e.key === 'C') {
                const c = new Cube((Math.random() - 0.5) * 10, rig.piv.y + Math.random() * 4 + 1, rig.piv.z + (Math.random() - 0.5) * 10);
                c.text = 'New Task';
                c.updateTextSprite();
                tm.cubes.push(c);
            }
            if (e.key === 'l' || e.key === 'L') {
                if (tm.sel) { tm.launch = true; tm.lSrc = tm.sel; document.getElementById('launch').classList.add('active'); }
            }
            if (e.key === ' ') { e.preventDefault(); shake(); }
            if (e.key === 'Escape' && tm.launch) { tm.launch = false; tm.lSrc = null; document.getElementById('launch').classList.remove('active'); }
        });
        addEventListener('keyup', e => { k[e.key] = false; if (e.key === 'Shift') { rig.mode = 'std'; document.getElementById('mode').classList.remove('active'); } });

        setInterval(() => {
            const s = 0.8;
            if (k.ArrowUp) rig.tPiv.z -= s;
            if (k.ArrowDown) rig.tPiv.z += s;
            if (k.ArrowLeft) rig.tPiv.x -= s;
            if (k.ArrowRight) rig.tPiv.x += s;
        }, 16);

        document.querySelectorAll('[data-p]').forEach(b => {
            b.addEventListener('click', () => {
                document.querySelectorAll('[data-p]').forEach(x => x.classList.remove('active'));
                b.classList.add('active');
                rig.preset = b.dataset.p;
            });
        });

        document.querySelectorAll('[data-s]').forEach(b => {
            b.addEventListener('click', () => {
                document.querySelectorAll('[data-s]').forEach(x => x.classList.remove('active'));
                b.classList.add('active');
                currentScale = b.dataset.s;
                createGrid(currentScale);
            });
        });

        /* ---------- Task Entry ---------- */
        const taskInput = document.getElementById('task-input');
        const addTaskBtn = document.getElementById('add-task');
        function addTask() {
            let text = taskInput.value.trim();
            if (!text) return;
            taskInput.value = '';

            let z_target;
            const hMatch = text.match(/h\/(\d+)/);
            if (hMatch) {
                z_target = parseInt(hMatch[1]);
                text = text.replace(/h\/\d+/, '').trim();
            }
            const dMatch = text.match(/d\/(\d+)/);
            if (dMatch) {
                z_target = parseInt(dMatch[1]) * 24;
                text = text.replace(/d\/\d+/, '').trim();
            }
            let hard;
            const hardMatch = text.match(/hard\/(\d+)(h|d)?/);
            if (hardMatch) {
                const num = parseInt(hardMatch[1]);
                const unit = hardMatch[2] || 'h';
                hard = num * (unit === 'd' ? 24 : 1);
                text = text.replace(/hard\/\d+(h|d)?/, '').trim();
            }

            const c = new Cube((Math.random() - 0.5) * 20, Math.random() * 4 + 1, (Math.random() - 0.5) * 10);
            c.text = text || 'Task';
            c.updateTextSprite();
            if (z_target !== undefined) c.z_target = z_target;
            if (hard !== undefined) c.hard = hard;
            tm.cubes.push(c);
        }
        addTaskBtn.addEventListener('click', addTask);
        taskInput.addEventListener('keydown', e => { if (e.key === 'Enter') addTask(); });

        /* ---------- Search ---------- */
        document.getElementById('search').addEventListener('input', e => {
            const val = e.target.value.toLowerCase();
            tm.cubes.forEach(c => {
                const show = !val || c.text.toLowerCase().includes(val);
                c.m.visible = show;
                if (c.textSprite) c.textSprite.visible = show;
            });
        });

        /* ---------- Custom cursor trail (kept) ---------- */
        const tl = 14, h = document.getElementById('cursor');
        for (let i = 0; i < tl; i++) { const d = document.createElement('div'); d.className = 'c-circle'; h.appendChild(d); }
        const cs = h.querySelectorAll('.c-circle');
        let mX = innerWidth / 2, mY = innerHeight / 2;
        const hist = Array(tl).fill(0).map(() => ({ x: mX, y: mY }));
        addEventListener('pointermove', e => { mX = e.clientX; mY = e.clientY; }, { passive: true });
        function cTick() {
            hist.shift(); hist.push({ x: mX, y: mY });
            cs.forEach((c, i) => {
                const cur = hist[i], nx = hist[i + 1] || hist[tl - 1];
                cur.x += (nx.x - cur.x) * 0.35;
                cur.y += (nx.y - cur.y) * 0.35;
                const s = Math.max(0.22, (tl - i) / tl * 1.2);
                c.style.transform = `translate(calc(${cur.x}px - 50%), calc(${cur.y}px - 50%)) scale(${s})`;
            });
            requestAnimationFrame(cTick);
        }
        cTick();

        /* ---------- Save on unload ---------- */
        addEventListener('beforeunload', () => {
            const data = tm.cubes.map(c => ({
                text: c.text,
                pos: { x: c.b.position.x, y: c.b.position.y, z: c.b.position.z },
                quat: { x: c.b.quaternion.x, y: c.b.quaternion.y, z: c.b.quaternion.z, w: c.b.quaternion.w },
                pri: c.pri,
                st: c.st,
                puls: c.puls,
                z_target: c.z_target,
                hard: c.hard
            }));
            localStorage.setItem('punt-tasks', JSON.stringify(data));
        });

        /* ---------- Animation loop ---------- */
        let lt = 0;
        function anim() {
            requestAnimationFrame(anim);
            const ct = performance.now() / 1000, dt = Math.min(ct - lt, 0.1); lt = ct;

            world.step(1 / 60, dt, 3);
            tm.cubes.forEach(c => c.tick());

            rig.piv.lerp(rig.tPiv, 0.1);

            const p = CFG.preset[rig.preset];

            if (rig.mode === 'eye') {
                const height = CFG.cam.eye.y * distanceScale;
                cam.position.lerp(new THREE.Vector3(rig.piv.x, height, rig.piv.z), 0.1);
                cam.lookAt(rig.piv);
            } else {
                const offset = p.o.clone().multiplyScalar(distanceScale);
                const tp = new THREE.Vector3().copy(rig.piv).add(offset);
                cam.position.lerp(tp, 0.1);
                cam.rotation.x += (p.r.x - cam.rotation.x) * 0.1;
                cam.rotation.y += (p.r.y - cam.rotation.y) * 0.1;
                cam.rotation.z += (p.r.z - cam.rotation.z) * 0.1;
            }

            cCam.update(rend, sc);

            rend.render(sc, cam);
        }

        addEventListener('resize', () => { cam.aspect = innerWidth / innerHeight; cam.updateProjectionMatrix(); rend.setSize(innerWidth, innerHeight); });
        anim();
    </script>
</body>
</html>
