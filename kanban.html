<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>PUNT: Neon Kanban</title>
    <style>
        :root{--bg:#0f1014;--accent:#39FF14;--pink:#FF1493;--neon-blue:#00ffff;}
        *{margin:0;padding:0;box-sizing:border-box;user-select:none;-webkit-user-select:none;}
        body{background:var(--bg);overflow:hidden;color:#fff;font-family:'Courier New', Courier, monospace;cursor:none;overscroll-behavior:none;}
        #canvas{display:block;width:100vw;height:100vh;outline:none;}
        
        /* --- UI Overlay --- */
        .hud{position:fixed;bottom:1rem;left:20px;font-size:10px;opacity:0.6;z-index:90;pointer-events:none;font-family:sans-serif;}
        .mode-status{position:fixed;top:20px;left:50%;transform:translateX(-50%);background:rgba(255,255,255,0.05);padding:8px 16px;border-radius:20px;border:1px solid rgba(255,255,255,0.1);opacity:0;transition:0.3s;z-index:100;pointer-events:none;}
        .mode-status.active{opacity:1;color:var(--pink);border-color:var(--pink);box-shadow: 0 0 15px var(--pink);}
        
        /* --- LEFT RAIL (SPAWNERS) --- */
        .quad-left{position:fixed;top:50%;left:20px;transform:translateY(-50%);display:flex;flex-direction:column;gap:16px;z-index:100;}
        .quad-icon{width:40px;height:40px;position:relative;perspective:300px;cursor:pointer;transition:transform 0.2s;}
        .quad-icon:hover{transform:scale(1.2);}
        .quad-icon:active{transform:scale(0.9);}
        
        .quad-cube{width:100%;height:100%;transform-style:preserve-3d;transform:rotateX(-25deg) rotateY(-45deg);animation:spin 6s linear infinite;}
        @keyframes spin{to{transform:rotateX(-25deg) rotateY(315deg);}}
        
        .q-face{position:absolute;width:24px;height:24px;left:8px;top:8px;backface-visibility:visible;opacity:0.8;}
        .q-face:nth-child(1){transform:rotateY(0deg) translateZ(12px);}
        .q-face:nth-child(2){transform:rotateY(90deg) translateZ(12px);}
        .q-face:nth-child(3){transform:rotateY(180deg) translateZ(12px);}
        .q-face:nth-child(4){transform:rotateY(-90deg) translateZ(12px);}
        .q-face:nth-child(5){transform:rotateX(90deg) translateZ(12px);}
        .q-face:nth-child(6){transform:rotateX(-90deg) translateZ(12px);}
        
        /* Rail Colors */
        .quad-icon.todo .q-face{background:rgba(255,255,0,0.2);border:1px solid #ffff00;box-shadow:0 0 5px #ffff00;}
        .quad-icon.prog .q-face{background:rgba(0,255,255,0.2);border:1px solid #00ffff;box-shadow:0 0 5px #00ffff;}
        .quad-icon.done .q-face{background:rgba(0,255,0,0.2);border:1px solid #00ff00;box-shadow:0 0 5px #00ff00;}
        .quad-icon.back .q-face{background:rgba(255,0,68,0.2);border:1px solid #ff0044;box-shadow:0 0 5px #ff0044;}
        
        /* Right Controls */
        .presets{position:fixed;top:20px;right:20px;display:flex;gap:8px;z-index:100;}
        .btn{background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);color:#fff;padding:8px 12px;border-radius:6px;cursor:pointer;font-size:10px;font-family:inherit;transition:0.2s;text-transform:uppercase;letter-spacing:1px;}
        .btn:hover{background:rgba(255,255,255,0.1);border-color:var(--accent);}
        .btn.active{border-color:var(--pink);color:var(--pink);box-shadow:0 0 10px rgba(255,20,147,0.3);}
        
        .top-bar{position:fixed;top:60px;left:50%;transform:translateX(-50%);z-index:100;}
        .top-bar input{background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.2);color:#fff;padding:8px 12px;border-radius:6px;width:200px;text-align:center;font-size:12px;cursor:text;}
        
        /* FAB / Joystick */
        .fab-zone {position: fixed;bottom: 6.66rem;left: 50%;transform: translateX(-50%);width: 80px;height: 80px;z-index: 200;cursor: grab;perspective: 600px;}
        .fab-zone:active { cursor: grabbing; }
        .fab-cube {width: 100%;height: 100%;position: relative;transform-style: preserve-3d;transform: rotateX(-25deg) rotateY(-45deg);pointer-events: none;transition: transform 0.1s;}
        .f-face {position: absolute;width: 40px;height: 40px;background: rgba(255, 20, 147, 0.15);border: 2px solid var(--pink);box-shadow: 0 0 15px var(--pink), inset 0 0 10px var(--pink);left: 20px;top: 20px;display: flex;align-items: center;justify-content: center;font-size: 20px;color: #fff;backface-visibility: visible;}
        .f-face:nth-child(1) { transform: rotateY(0deg) translateZ(20px); }
        .f-face:nth-child(2) { transform: rotateY(90deg) translateZ(20px); }
        .f-face:nth-child(3) { transform: rotateY(180deg) translateZ(20px); }
        .f-face:nth-child(4) { transform: rotateY(-90deg) translateZ(20px); }
        .f-face:nth-child(5) { transform: rotateX(90deg) translateZ(20px); background: rgba(255, 20, 147, 0.3); }
        .f-face:nth-child(6) { transform: rotateX(-90deg) translateZ(20px); }
        .fab-hint {
      position: absolute;
      bottom: -16px;
      width: 100%;
      text-align: center;
      font-size: 9px;
      color: rgba(255,255,255,0.5);
      pointer-events: none;
    }

        /* Cursor & Info */
        #cursor{position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:9999;transition: opacity 0.2s;}
        .c-circle{position:absolute;width:20px;height:20px;border-radius:50%;background:radial-gradient(circle,var(--pink),transparent);opacity:0.6;mix-blend-mode:screen;}
        body.fab-active #cursor { opacity: 0; }
        body.fab-active .btn, body.fab-active input, body.fab-active .quad-icon { pointer-events: none; opacity: 0.5; }

        .info{position:fixed;top:80px;right:20px;background:rgba(20,20,30,0.9);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.2);border-radius:8px;padding:16px;min-width:250px;opacity:0;transition:0.3s;z-index:90;pointer-events:none;}
        .info.active{opacity:1;}
        .info-row{font-size:11px;margin:4px 0;display:flex;justify-content:space-between}
        
        .ctx{position:fixed;background:rgba(20,20,30,0.95);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.2);border-radius:8px;padding:8px 0;min-width:180px;display:none;z-index:1000}
        .ctx.active{display:block}
        .ctx-item{padding:8px 16px;cursor:pointer;font-size:12px;transition:0.2s}
        .ctx-item:hover{background:rgba(255,255,255,0.1)}
        .ctx-div{height:1px;background:rgba(255,255,255,0.1);margin:4px 0}
        
        .launch{position:fixed;bottom:60px;left:50%;transform:translateX(-50%);background:rgba(255,170,0,0.2);border:2px solid #fa0;color:#fa0;padding:12px 24px;border-radius:8px;font-size:12px;opacity:0;transition:0.3s;z-index:100}
        .launch.active{opacity:1}

        .coords {
            position: fixed; bottom: 20px; left: 20px;
            font-family: 'Courier New', Courier, monospace; font-size: 14px;
            color: var(--accent); background: rgba(0,0,0,0.6);
            padding: 4px 8px; border-radius: 4px;
            border: 1px solid rgba(57, 255, 20, 0.3); z-index: 90; pointer-events: none;
        }

        @media (max-width: 768px) {
            .hud { display: none; }
            .fab-zone { bottom: 20px; transform: translateX(-50%) scale(0.9); }
            .quad-left { left: 10px; transform:translateY(-50%) scale(0.8); }
            .top-bar { top: 70px; }
            .coords { bottom: 10px; left: 10px; font-size: 10px; }
        }
.fab-zone .coords { position: absolute; bottom: -40px; left:50%; transform:translateX(-50%); background:none; border:none; font-size:12px; color:rgba(255,255,255,0.5); }
.fab-halo { position: absolute; left: -20px; top: -20px; width: 120px; height: 120px; border-radius: 50%; background: radial-gradient(circle, rgba(255,20,147,0.2), transparent); opacity: 0; transition: opacity 0.1s; }
</style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="cursor"></div>
    <div id="mode" class="mode-status">FOCAL MODE ACTIVE</div>
    
    <div class="hud">[DRAG] Move 路 [CLICK RAIL] Spawn Cube 路 [SHIFT+SCROLL] Focal 路 [SPACE] Shake 路 [L] Launch</div>
    
    <div class="quad-left">
        <div class="quad-icon todo" onclick="spawn('todo')" title="Spawn To-Do"><div class="quad-cube"><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div></div></div>
        <div class="quad-icon prog" onclick="spawn('prog')" title="Spawn In-Progress"><div class="quad-cube"><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div></div></div>
        <div class="quad-icon done" onclick="spawn('done')" title="Spawn Completed"><div class="quad-cube"><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div></div></div>
        <div class="quad-icon back" onclick="spawn('back')" title="Spawn Backlog"><div class="quad-cube"><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div></div></div>
    </div>

    <div class="presets">
        <button class="btn active" data-p="std" title="Quarterback View">QB</button>
        <button class="btn" data-p="top" title="Skycam View">SKY</button>
        <button class="btn" data-p="side" title="Sideline Coach View">COACH</button>
    </div>

    <div class="top-bar">
        <input id="search" type="text" placeholder="Search Tasks...">
    </div>

    

    <div id="info" class="info">
        <div class="info-title" id="iTitle">Task</div>
        <div class="info-row"><span style="opacity:0.6">Task:</span><span id="iText">-</span></div>
        <div class="info-row"><span style="opacity:0.6">Position:</span><span id="iPos">0,0,0</span></div>
        <div class="info-row"><span style="opacity:0.6">Status:</span><span id="iState" style="color:var(--accent)">Default</span></div>
    </div>

    <div id="ctx" class="ctx">
        <div class="ctx-item" data-a="clone">Clone</div>
        <div class="ctx-item" data-a="edit">Edit Text</div>
        <div class="ctx-div"></div>
        <div class="ctx-item" data-a="del">Delete</div>
    </div>
    <div id="launch" class="launch">LAUNCH MODE: Click target on floor</div>

    <div class="fab-zone" id="joystick">
        <div class="fab-halo"></div><div class="fab-cube" id="joy-cube">
            <div class="f-face"></div><div class="f-face"></div><div class="f-face"></div>
            <div class="f-face"></div><div class="f-face"></div><div class="f-face"></div>
        </div>
        <div class="fab-hint">NAV</div>
<div class="coords" id="coord-display">X:0.0 Y:0.0 Z:0.0</div></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/BokehPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/BokehShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/VignetteShader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
    
    <script>
        class ThinFilm extends THREE.Texture {
          constructor(t=520){
              super();
              this.thickness = t;
              this.generate();
          }
          generate(){
              const w=512,h=1;
              const d=new Uint8Array(w*4);
              for(let i=0;i<w;i++){
                  const c=i/w;
                  const u=Math.pow(1-c,5);
                  const phase = this.thickness/100 * c * Math.PI * 2;
                  let r = 0.04 + 0.96*u + (Math.sin(phase)*0.5 + 0.5);
                  let g = u + (Math.sin(phase + 2*Math.PI/3)*0.5 + 0.5);
                  let b = u + (Math.sin(phase + 4*Math.PI/3)*0.5 + 0.5);
                  r = Math.max(0, Math.min(1, r));
                  g = Math.max(0, Math.min(1, g));
                  b = Math.max(0, Math.min(1, b));
                  d[i*4]=Math.floor(r*255);
                  d[i*4+1]=Math.floor(g*255);
                  d[i*4+2]=Math.floor(b*255);
                  d[i*4+3]=255;
              }
              this.image={data:d,width:w,height:h};
              this.magFilter=THREE.LinearFilter;
              this.minFilter=THREE.LinearFilter;
              this.wrapS=THREE.ClampToEdgeWrapping;
              this.wrapT=THREE.ClampToEdgeWrapping;
              this.needsUpdate=true;
          }
      }

        const CFG = {
            cam: { eye: {y:40} },
            preset: {
                std: { o: new THREE.Vector3(0,12,25), r: new THREE.Euler(-0.4,0,0) },
                top: { o: new THREE.Vector3(0,60,1), r: new THREE.Euler(-Math.PI/2,0,0) },
                side: { o: new THREE.Vector3(60, 5, 0), r: new THREE.Euler(0, Math.PI/2, 0) }
            },
            colors: {
                todo: 0xFFFF00, // Yellow
                prog: 0x00FFFF, // Cyan
                done: 0x00FF00, // Green
                back: 0xFF0044  // Red-Pink
            }
        };

        const sc = new THREE.Scene();
        sc.background = new THREE.Color(0x000000);
        sc.fog = new THREE.FogExp2(0x000000, 0.012);

        const cam = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 10077);

        const rend = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        rend.setSize(innerWidth, innerHeight);
        rend.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        rend.shadowMap.enabled = true;
        rend.shadowMap.type = THREE.PCFSoftShadowMap;var composer = new THREE.EffectComposer(rend);var renderPass = new THREE.RenderPass(sc, cam);composer.addPass(renderPass);var bokehPass = new THREE.BokehPass(sc, cam, { focus: 10, aperture: 0.00001, maxblur: 0.005 });composer.addPass(bokehPass);var vignettePass = new THREE.ShaderPass(THREE.VignetteShader);vignettePass.uniforms.offset.value = 1;vignettePass.uniforms.darkness.value = 1;composer.addPass(vignettePass);

        const world = new CANNON.World();
        world.gravity.set(0, -19.81, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        const mat = new CANNON.Material();
        world.addContactMaterial(new CANNON.ContactMaterial(mat, mat, { friction: 0.6, restitution: 0.2 }));

        const rig = { mode: 'std', preset: 'std', piv: new THREE.Vector3(), tPiv: new THREE.Vector3() };
        const tm = { cubes: [], sel: null, hov: null, drag: null, launch: false, lSrc: null };

        let distanceScale = 1;
        let isPanning = false;
        let panStartIntersect = null;

        sc.add(new THREE.AmbientLight(0xffffff, 0.4));

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.4);
        dirLight.position.set(20, 50, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        sc.add(dirLight);

        const neon1 = new THREE.PointLight(0x00ffff, 4, 90); neon1.position.set(-30, 15, -30); sc.add(neon1);
        const neon2 = new THREE.PointLight(0xff00ff, 4, 90); neon2.position.set(30, 15, 30); sc.add(neon2);
        
        const cRT = new THREE.WebGLCubeRenderTarget(512, { format: THREE.RGBFormat, generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter });
        const cCam = new THREE.CubeCamera(0.1, 1000, cRT);
        sc.add(cCam);

        // Floor
        const gnd = new THREE.Mesh(
          new THREE.PlaneGeometry(200, 200),
          new THREE.MeshStandardMaterial({ color: 0x050508, roughness: 0.8, metalness: 0.8, envMapIntensity: 0.5 })
        );
        gnd.rotation.x = -Math.PI / 2;
        gnd.position.y = -4;
        gnd.receiveShadow = true;
        sc.add(gnd);

        const gB = new CANNON.Body({ mass: 0, material: mat });
        gB.addShape(new CANNON.Plane());
        gB.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        gB.position.set(0, -4, 0);
        world.addBody(gB);

        // --- GRID: KANBAN LAYOUT ---
        const gridGrp = new THREE.Group();
        sc.add(gridGrp);

        function createGrid() {
            const mat = new THREE.LineBasicMaterial({ color: 0x222233 });
            const xLine = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-100, -3.9, 0), new THREE.Vector3(100, -3.9, 0)]);
            const zLine = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, -3.9, -100), new THREE.Vector3(0, -3.9, 100)]);
            gridGrp.add(new THREE.Line(xLine, mat));
            gridGrp.add(new THREE.Line(zLine, mat));

            const addLabel = (txt, x, z, col) => {
                const c = document.createElement('canvas'); c.width = 256; c.height = 64;
                const ctx = c.getContext('2d'); 
                ctx.fillStyle = col; ctx.font = 'bold 40px monospace'; ctx.textAlign = 'center'; 
                ctx.shadowColor = col; ctx.shadowBlur = 10;
                ctx.fillText(txt, 128, 48);
                const s = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(c), transparent:true, opacity:0.6 }));
                s.position.set(x, -3.8, z); 
                s.scale.set(12, 3, 1);
                gridGrp.add(s);
            }

            addLabel("TO DO", 25, -25, "#FFFF00");
            addLabel("IN PROGRESS", -25, -25, "#00FFFF");
            addLabel("DONE", 25, 25, "#00FF00");
            addLabel("BACKLOG", -25, 25, "#FF0044");
        }
        createGrid();

        const ringGeo = new THREE.RingGeometry(2.3, 2.7, 32); ringGeo.rotateX(-Math.PI/2);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x39FF14, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
        const selRing = new THREE.Mesh(ringGeo, ringMat); selRing.visible = false; sc.add(selRing);

        // --- CUBE LOGIC ---
        class Cube {
          constructor(x, y, z, sz = 2.5) {
              this.sz = sz;
              this.st = 'def';
              
              const baseMat = new THREE.MeshPhysicalMaterial({
                  color: 0x333333,
                  metalness: 0.1, roughness: 0.1,
                  clearcoat: 1.0, clearcoatRoughness: 0,
                  emissive: 0x000000, emissiveIntensity: 2.0,
                  envMap: cRT.texture, envMapIntensity: 1.5
              });

              this.mat = baseMat;
              this.m = new THREE.Mesh(new THREE.BoxGeometry(sz, sz, sz), baseMat);
              this.m.position.set(x, y, z);
              this.m.castShadow = true;
              this.m.receiveShadow = true;
              this.m.userData.cube = this;

              const ed = new THREE.LineSegments(new THREE.EdgesGeometry(this.m.geometry), new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 }));
              this.ed = ed;
              this.m.add(ed);
              sc.add(this.m);

              const sh = new CANNON.Box(new CANNON.Vec3(sz / 2, sz / 2, sz / 2));
              this.b = new CANNON.Body({ mass: 5, material: mat, type: CANNON.Body.DYNAMIC });
              this.b.addShape(sh);
              this.b.position.set(x, y, z);
              this.b.linearDamping = 0.4;
              this.b.angularDamping = 0.4; this.b.angularFactor = new CANNON.Vec3(0,0,0);
              world.addBody(this.b);
              
              this.updateColor(); 
          }

          updateTextSprite() {
              if (this.textSprite) this.m.remove(this.textSprite);
              if (!this.text) return;
              const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 128;
              const ctx = canvas.getContext('2d');
              ctx.fillStyle = '#ffffff'; ctx.font = 'bold 36px sans-serif'; ctx.textAlign = 'center';
              ctx.fillText(this.text, 128, 64);
              const map = new THREE.CanvasTexture(canvas);
              const spriteMat = new THREE.SpriteMaterial({map});
              this.textSprite = new THREE.Sprite(spriteMat);
              this.textSprite.scale.set(5,2.5,1);
              this.textSprite.position.set(0, this.sz/2 + 1, 0);
              this.m.add(this.textSprite);
          }

          getStatus() {
              const x = this.b.position.x;
              const z = this.b.position.z;
              if (x > 0 && z < 0) return 'todo';
              if (x < 0 && z < 0) return 'prog';
              if (x > 0 && z > 0) return 'done';
              return 'back';
          }

          updateColor() {
              const s = this.getStatus();
              if (this.lastStatus !== s) {
                  this.lastStatus = s;
                  const c = CFG.colors[s];
                  this.mat.color.setHex(c);
                  this.mat.emissive.setHex(c);
                  this.mat.emissiveIntensity = 0.6;
              }
          }

          click() {
              gsap.to(this.m.scale, { x: 1.1, y: 1.1, z: 1.1, duration: 0.1, yoyo: true, repeat: 1 });
          }

          sel() {
              this.ed.material.opacity = 1.0;
              tm.sel = this;
              this.upd();
          }

          desel() {
              this.ed.material.opacity = 0.2;
              if (tm.sel === this) { tm.sel = null; document.getElementById('info').classList.remove('active'); }
          }

          launch(tp) {
              const d = new THREE.Vector3().subVectors(tp, this.b.position);
              const ds = d.length();
              const imp = new CANNON.Vec3(d.x * 6, Math.sqrt(ds * 12) + 5, d.z * 6);
              this.b.applyImpulse(imp, this.b.position);
              this.b.angularVelocity.set((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10);
          }

          upd() {
              const pn = document.getElementById('info');
              pn.classList.add('active');
              document.getElementById('iTitle').textContent = 'Task #' + (tm.cubes.indexOf(this) + 1);
              document.getElementById('iText').textContent = this.text || '-';
              document.getElementById('iPos').textContent = `${this.b.position.x.toFixed(0)},${this.b.position.z.toFixed(0)}`;
              document.getElementById('iState').textContent = this.getStatus().toUpperCase();
          }

          tick() {
              this.m.position.copy(this.b.position);
              this.m.quaternion.copy(this.b.quaternion);
              if (!tm.drag || tm.drag !== this) this.updateColor();
          }

          rm() {
              sc.remove(this.m);
              world.removeBody(this.b);
              const i = tm.cubes.indexOf(this);
              if (i > -1) tm.cubes.splice(i, 1);
          }
      }

        // --- INIT DATA ---
        const saved = localStorage.getItem('punt-kanban');
        if (saved) {
            JSON.parse(saved).forEach(d => {
                const c = new Cube(d.pos.x, d.pos.y, d.pos.z);
                c.text = d.text;
                c.updateTextSprite();
                c.b.quaternion.set(d.quat.x, d.quat.y, d.quat.z, d.quat.w);
                tm.cubes.push(c);
            });
        } else {
            // Demo data
            [[15, -15, "Plan"], [-15, -15, "Coding"], [15, 15, "Deploy"]].forEach(d => {
                const c = new Cube(d[0], 5, d[1]);
                c.text = d[2];
                c.updateTextSprite();
                tm.cubes.push(c);
            });
        }

        // --- SPAWNER LOGIC ---
        window.spawn = function(zone) {
            let x, z;
            // Target specific zones
            switch(zone) {
                case 'todo': x = 25; z = -25; break;
                case 'prog': x = -25; z = -25; break;
                case 'done': x = 25; z = 25; break;
                case 'back': x = -25; z = 25; break;
            }
            // Add some jitter so they don't stack perfectly vertical if spammed
            x += (Math.random() - 0.5) * 5;
            z += (Math.random() - 0.5) * 5;
            
            // Drop from height 40
            const c = new Cube(x, 40, z);
            c.text = "New Task";
            c.updateTextSprite();
            c.b.angularVelocity.set(Math.random(), Math.random(), Math.random());
            tm.cubes.push(c);
            
            // Navigate camera slightly to show the drop if far away
            if (rig.tPiv.distanceTo(new THREE.Vector3(x, 0, z)) > 30) {
                gsap.to(rig.tPiv, {x:x, z:z, duration: 1.5, ease:"power2.out"});
            }
        }

        function shake() {
            tm.cubes.forEach(c => {
                c.b.wakeUp();
                const im = new CANNON.Vec3((Math.random()-0.5)*40, 40+Math.random()*40, (Math.random()-0.5)*40);
                c.b.applyImpulse(im, c.b.position);
            });
        }

        // --- INTERACTION ---
        const rc = new THREE.Raycaster(), ms = new THREE.Vector2(), intersect = new THREE.Vector3();
        function upMs(e) { ms.x = (e.clientX / innerWidth) * 2 - 1; ms.y = -(e.clientY / innerHeight) * 2 + 1; }
        function getC() { rc.setFromCamera(ms, cam); const in_ = rc.intersectObjects(tm.cubes.map(c => c.m)); return in_.length > 0 ? in_[0].object.userData.cube : null; }
        function getG(e) {
            upMs(e);
            rc.setFromCamera(ms, cam);
            const planeY = tm.drag ? tm.drag.b.position.y : 0;
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -planeY);
            if (rc.ray.intersectPlane(plane, intersect)) return intersect;
            return null;
        }

        addEventListener('wheel', e => {
            if (e.shiftKey) {
                cam.fov += e.deltaY * 0.05;
                cam.fov = Math.max(10, Math.min(120, cam.fov));
                cam.updateProjectionMatrix();
            } else {
                distanceScale += e.deltaY * 0.001;
                distanceScale = Math.max(0.3, Math.min(5, distanceScale));
            }
        });

        addEventListener('mousemove', e => {
            upMs(e);
            if (tm.drag && e.buttons & 1) {
                const gp = getG(e);
                if (gp) {
                    tm.drag.b.position.copy(gp);
                    tm.drag.upd();
                }
            } else if (isPanning && e.buttons & 1) {
                const gp = getG(e);
                if (gp && panStartIntersect) {
                    const delta = new THREE.Vector3().subVectors(gp, panStartIntersect);
                    rig.tPiv.sub(delta);
                    panStartIntersect.copy(gp);
                }
            }
        });

        addEventListener('mousedown', e => {
            upMs(e);
            if (tm.launch && tm.lSrc) {
                const gp = getG(e);
                if (gp) {
                    gp.y = tm.lSrc.b.position.y;
                    tm.lSrc.launch(gp);
                    tm.launch = false; tm.lSrc = null;
                    document.getElementById('launch').classList.remove('active');
                }
                return;
            }
            const c = getC();
            if (c) {
                if (tm.sel && tm.sel !== c) tm.sel.desel();
                c.click();
                c.sel();
                tm.drag = c;
                c.originalY = c.b.position.y;
                c.b.type = CANNON.Body.KINEMATIC;
                gsap.to(c.b.position, { y: 3.5, duration: 0.2, ease: "power2.out" });
            } else {
                const gp = getG(e);
                if (gp) {
                    isPanning = true;
                    panStartIntersect = gp.clone();
                    document.getElementById('info').classList.remove('active');
                }
            }
        });

        addEventListener('mouseup', () => {
            if (tm.drag) {
                const c = tm.drag;
                gsap.to(c.b.position, { y: 2, duration: 0.2, ease: "power1.in", onComplete: () => {
                    c.b.type = CANNON.Body.DYNAMIC;
                    c.b.wakeUp();
                }});
            }
            tm.drag = null;
            isPanning = false;
        });

        addEventListener('contextmenu', e => { 
            e.preventDefault(); 
            upMs(e); 
            const c = getC(); 
            if (c) { 
                const m = document.getElementById('ctx'); 
                m.style.left = e.clientX + 'px'; 
                m.style.top = e.clientY + 'px'; 
                m.classList.add('active'); 
                tm.sel = c; 
            } 
        });
        addEventListener('click', () => { document.getElementById('ctx').classList.remove('active'); });

        document.querySelectorAll('.ctx-item').forEach(it => {
            it.addEventListener('click', e => {
                e.stopPropagation();
                const a = it.dataset.a, c = tm.sel;
                if (!c) return;
                switch (a) {
                    case 'clone':
                        const cl = new Cube(c.b.position.x + 2, 5, c.b.position.z);
                        cl.text = c.text + " (Copy)";
                        cl.updateTextSprite();
                        tm.cubes.push(cl);
                        break;
                    case 'edit':
                        const n = prompt("Edit Task", c.text);
                        if(n) { c.text = n; c.updateTextSprite(); c.upd(); }
                        break;
                    case 'del': c.rm(); tm.sel = null; document.getElementById('info').classList.remove('active'); break;
                }
            });
        });

        let focal = false;
        let focalPos = new THREE.Vector3();
        let focalTarget = new THREE.Vector3();
        addEventListener('keydown', e => {
            if (e.key === 'Shift') { rig.mode = 'eye'; document.getElementById('mode').classList.add('active'); if(tm.sel){focal = true;focalPos.set(tm.sel.b.position.x, tm.sel.b.position.y + 2, tm.sel.b.position.z + 10);focalTarget.set(tm.sel.b.position.x, tm.sel.b.position.y + 1, tm.sel.b.position.z);gsap.to(bokehPass.uniforms.aperture, {value:0.01, duration:1});gsap.to(vignettePass.uniforms.darkness, {value:2, duration:1});gsap.to({val:distanceScale}, {val:0.3, duration:1, onUpdate:function(){distanceScale = this.targets()[0].val}});}}
            if (e.key === 'l' || e.key === 'L') {
                if (tm.sel) { tm.launch = true; tm.lSrc = tm.sel; document.getElementById('launch').classList.add('active'); }
            }
            if (e.key === ' ') { e.preventDefault(); shake(); }
            if (e.key === 'Escape') { tm.launch = false; tm.lSrc = null; document.getElementById('launch').classList.remove('active'); }
        });
        addEventListener('keyup', e => { if (e.key === 'Shift') { rig.mode = 'std'; document.getElementById('mode').classList.remove('active'); focal = false; gsap.to(bokehPass.uniforms.aperture, {value:0.00001, duration:1});gsap.to(vignettePass.uniforms.darkness, {value:1, duration:1});gsap.to({val:distanceScale}, {val:1, duration:1, onUpdate:function(){distanceScale = this.targets()[0].val}}); } });

        document.querySelectorAll('[data-p]').forEach(b => {
            b.addEventListener('click', () => {
                document.querySelectorAll('[data-p]').forEach(x => x.classList.remove('active'));
                b.classList.add('active');
                rig.preset = b.dataset.p;
            });
        });

        document.getElementById('search').addEventListener('input', e => {
            const val = e.target.value.toLowerCase();
            tm.cubes.forEach(c => {
                const show = !val || c.text.toLowerCase().includes(val);
                c.m.visible = show;
                if(show) c.b.wakeUp();
            });
        });

        const tl = 14, h = document.getElementById('cursor');
        for (let i = 0; i < tl; i++) { const d = document.createElement('div'); d.className = 'c-circle'; h.appendChild(d); }
        const cs = h.querySelectorAll('.c-circle');
        let mX = innerWidth / 2, mY = innerHeight / 2;
        const hist = Array(tl).fill(0).map(() => ({ x: mX, y: mY }));
        addEventListener('pointermove', e => { mX = e.clientX; mY = e.clientY; }, { passive: true });
        function cTick() {
            hist.shift(); hist.push({ x: mX, y: mY });
            cs.forEach((c, i) => {
                const cur = hist[i];
                const nx = hist[i + 1] || hist[tl - 1];
                cur.x += (nx.x - cur.x) * 0.35;
                cur.y += (nx.y - cur.y) * 0.35;
                const s = Math.max(0.22, (tl - i) / tl * 1.2);
                c.style.transform = `translate(calc(${cur.x}px - 50%), calc(${cur.y}px - 50%)) scale(${s})`;
            });
            requestAnimationFrame(cTick);
        }
        cTick();

        addEventListener('beforeunload', () => {
            const data = tm.cubes.map(c => ({
                text: c.text,
                pos: { x: c.b.position.x, y: c.b.position.y, z: c.b.position.z },
                quat: { x: c.b.quaternion.x, y: c.b.quaternion.y, z: c.b.quaternion.z, w: c.b.quaternion.w }
            }));
            localStorage.setItem('punt-kanban', JSON.stringify(data));
        });

        const joy = { el: document.getElementById('joy-cube'), zone: document.getElementById('joystick'), active: false, start: {x:0, y:0} };
        function handleJoy(x, y) {
            const max = 40;
            let dx = x - joy.start.x, dy = y - joy.start.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist > max) { const r = max/dist; dx*=r; dy*=r; }

            joy.el.style.transform = `rotateX(${-25 + (dy/max*45)}deg) rotateY(${-45 + (dx/max*45)}deg) translate(${dx/3}px, ${dy/3}px)`;document.querySelector('.fab-halo').style.opacity = dist / max *0.5;
            rig.tPiv.z += dy / max * 0.8;
            rig.tPiv.x += dx / max * 0.8;
        }
        function startJoy(x, y) { joy.active = true; joy.start = {x, y}; joy.el.style.transition = 'none'; document.body.classList.add('fab-active'); }
        function endJoy() { joy.active = false; joy.el.style.transition = 'transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)'; joy.el.style.transform = `rotateX(-25deg) rotateY(-45deg) translate(0px, 0px)`; document.querySelector('.fab-halo').style.opacity = 0; document.body.classList.remove('fab-active'); }
        joy.zone.addEventListener('mousedown', e => { startJoy(e.clientX, e.clientY); e.stopPropagation(); });
        addEventListener('mousemove', e => { if(joy.active) handleJoy(e.clientX, e.clientY); });
        addEventListener('mouseup', endJoy);

        let lt = 0;
        const coordD = document.getElementById('coord-display');
        function anim() {
            requestAnimationFrame(anim);
            const ct = performance.now() / 1000, dt = Math.min(ct - lt, 0.1); lt = ct;

            tm.cubes.forEach(c => {if (tm.drag !== c) {const s = c.getStatus();const cx = {todo:25, prog:-25, done:25, back:-25}[s];const cz = {todo:-25, prog:-25, done:25, back:25}[s];const dx = cx - c.b.position.x;const dz = cz - c.b.position.z;const force = new CANNON.Vec3(dx * 0.1, 0, dz * 0.1);c.b.applyForce(force, c.b.position);}});world.step(1 / 60, dt, 3);
            tm.cubes.forEach(c => c.tick());

            const boundX = 40, boundZ = 40;
            if(rig.tPiv.x > boundX) rig.tPiv.x += (boundX - rig.tPiv.x) * 0.1;
            if(rig.tPiv.x < -boundX) rig.tPiv.x += (-boundX - rig.tPiv.x) * 0.1;
            if(rig.tPiv.z > boundZ) rig.tPiv.z += (boundZ - rig.tPiv.z) * 0.1;
            if(rig.tPiv.z < -boundZ) rig.tPiv.z += (-boundZ - rig.tPiv.z) * 0.1;

            rig.piv.lerp(rig.tPiv, 0.1);

            const p = CFG.preset[rig.preset];
            if (rig.mode === 'eye') {
                if (focal) {
                    cam.position.lerp(focalPos, 0.1);
                    cam.lookAt(focalTarget);
                    bokehPass.uniforms.focus.value = cam.position.distanceTo(focalTarget);
                } else {
                    const height = CFG.cam.eye.y * distanceScale;
                    cam.position.lerp(new THREE.Vector3(rig.piv.x, height, rig.piv.z), 0.1);
                    cam.lookAt(rig.piv);
                    bokehPass.uniforms.focus.value = cam.position.distanceTo(rig.piv);
                }
            } else {
                const offset = p.o.clone().multiplyScalar(distanceScale);
                const tp = new THREE.Vector3().copy(rig.piv).add(offset);
                cam.position.lerp(tp, 0.1);
                cam.rotation.x += (p.r.x - cam.rotation.x) * 0.1;
                cam.rotation.y += (p.r.y - cam.rotation.y) * 0.1;
                cam.rotation.z += (p.r.z - cam.rotation.z) * 0.1;
            }

            cCam.update(rend, sc);

            if (tm.sel && (rig.preset === 'top' || rig.preset === 'side')) {
                selRing.visible = true;
                selRing.position.copy(tm.sel.m.position);
                selRing.position.y = -3.99;
                const s = 1 + Math.sin(ct * 2) * 0.1;
                selRing.scale.set(s, 1, s);
            } else {
                selRing.visible = false;
            }

            let coordText;if(rig.preset === 'top') coordText = `X:${rig.piv.x.toFixed(1)} Z:${rig.piv.z.toFixed(1)}`;else if(rig.preset === 'side') coordText = `Y:${rig.piv.y.toFixed(1)} Z:${rig.piv.z.toFixed(1)}`;else coordText = `X:${rig.piv.x.toFixed(1)} Y:${rig.piv.y.toFixed(1)} Z:${rig.piv.z.toFixed(1)}`;coordD.textContent = coordText;

            if(rig.mode === 'eye'){composer.render();} else {rend.render(sc, cam);}
        }

        addEventListener('resize', () => { cam.aspect = innerWidth / innerHeight; cam.updateProjectionMatrix(); rend.setSize(innerWidth, innerHeight); composer.setSize(innerWidth, innerHeight); });
        anim();
    </script>
</body>
</html>
