<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>PUNT: Neon Kanban</title>
    <style>
        :root{--bg:#0f1014;--accent:#39FF14;--pink:#FF1493;--neon-blue:#00ffff;--glass:rgba(20,20,30,0.85);}
        *{margin:0;padding:0;box-sizing:border-box;user-select:none;-webkit-user-select:none;}
        body{background:var(--bg);overflow:hidden;color:#fff;font-family:'Courier New', Courier, monospace;cursor:none;overscroll-behavior:none;}
        #canvas{display:block;width:100vw;height:100vh;outline:none;}
        
        /* --- UI Overlay --- */
        .hud{position:fixed;bottom:1rem;left:20px;font-size:10px;opacity:0.6;z-index:90;pointer-events:none;font-family:sans-serif; text-shadow: 0 0 5px #000;}
        
        /* Quadrant Nav (Left) */
        .quad-nav{position:fixed;top:50%;left:20px;transform:translateY(-50%);display:flex;flex-direction:column;gap:12px;z-index:100;}
        .q-btn{width:40px;height:40px;border-radius:8px;background:var(--glass);border:1px solid rgba(255,255,255,0.1);cursor:pointer;position:relative;transition:0.3s;display:flex;align-items:center;justify-content:center;font-size:18px;}
        .q-btn:hover{transform:scale(1.1);border-color:#fff;}
        .q-btn.todo{color:#ffff00;border-color:rgba(255,255,0,0.3);}
        .q-btn.prog{color:#00ffff;border-color:rgba(0,255,255,0.3);}
        .q-btn.done{color:#00ff00;border-color:rgba(0,255,0,0.3);}
        .q-btn.back{color:#ff0000;border-color:rgba(255,0,0,0.3);}
        .q-tooltip{position:absolute;left:50px;background:var(--glass);padding:4px 8px;border-radius:4px;font-size:10px;opacity:0;pointer-events:none;transition:0.2s;white-space:nowrap;border:1px solid rgba(255,255,255,0.1);}
        .q-btn:hover .q-tooltip{opacity:1;transform:translateX(5px);}

        /* View Presets (Right) */
        .presets{position:fixed;top:50%;right:20px;transform:translateY(-50%);display:flex;flex-direction:column;gap:8px;z-index:100;}
        .btn{background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);color:#fff;padding:8px 12px;border-radius:6px;cursor:pointer;font-size:10px;font-family:inherit;transition:0.2s;text-transform:uppercase;letter-spacing:1px;}
        .btn:hover{background:rgba(255,255,255,0.1);border-color:var(--accent);}
        .btn.active{border-color:var(--pink);color:var(--pink);box-shadow:0 0 10px rgba(255,20,147,0.3);}

        /* Top Bar */
        .top-bar{position:fixed;top:20px;left:50%;transform:translateX(-50%);display:flex;gap:10px;z-index:100;}
        .search-in{background:rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.2);color:#fff;padding:8px 12px;border-radius:6px;width:250px;text-align:center;font-size:12px;cursor:text;font-family:inherit;}
        .search-in:focus{border-color:var(--accent);outline:none;}

        /* FAB / Joystick */
        .fab-zone {position: fixed;bottom: 4rem;left: 50%;transform: translateX(-50%);width: 60px;height: 60px;z-index: 200;cursor: grab;perspective: 600px;}
        .fab-zone:active { cursor: grabbing; }
        .fab-cube {width: 100%;height: 100%;position: relative;transform-style: preserve-3d;transform: rotateX(-25deg) rotateY(-45deg);pointer-events: none;transition: transform 0.1s;}
        .f-face {position: absolute;width: 30px;height: 30px;background: rgba(255, 20, 147, 0.15);border: 2px solid var(--pink);box-shadow: 0 0 15px var(--pink), inset 0 0 10px var(--pink);left: 15px;top: 15px;display: flex;align-items: center;justify-content: center;backface-visibility: visible;}
        /* Cube construction */
        .f-face:nth-child(1) { transform: rotateY(0deg) translateZ(15px); }
        .f-face:nth-child(2) { transform: rotateY(90deg) translateZ(15px); }
        .f-face:nth-child(3) { transform: rotateY(180deg) translateZ(15px); }
        .f-face:nth-child(4) { transform: rotateY(-90deg) translateZ(15px); }
        .f-face:nth-child(5) { transform: rotateX(90deg) translateZ(15px); background: rgba(255, 20, 147, 0.3); }
        .f-face:nth-child(6) { transform: rotateX(-90deg) translateZ(15px); }

        /* Trash */
        .trash{position:fixed;bottom:30px;right:30px;width:60px;height:60px;border-radius:50%;border:2px dashed rgba(255,255,255,0.2);display:flex;align-items:center;justify-content:center;font-size:24px;transition:0.3s;opacity:0.5;z-index:90;}
        .trash.active{opacity:1;border-color:red;color:red;background:rgba(255,0,0,0.1);transform:scale(1.1);box-shadow:0 0 20px rgba(255,0,0,0.4);}

        /* Info Panel */
        .info{position:fixed;top:80px;right:20px;background:var(--glass);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.2);border-radius:8px;padding:16px;min-width:220px;opacity:0;transition:0.3s;z-index:90;pointer-events:none;transform:translateX(20px);}
        .info.active{opacity:1;transform:translateX(0);}
        .info h3{font-size:14px;margin-bottom:8px;color:var(--accent);border-bottom:1px solid rgba(255,255,255,0.1);padding-bottom:4px;}
        .info-row{font-size:11px;margin:4px 0;display:flex;justify-content:space-between;color:#ccc;}

        /* Context Menu */
        .ctx{position:fixed;background:rgba(10,10,15,0.95);border:1px solid rgba(255,255,255,0.15);border-radius:6px;padding:6px 0;min-width:140px;display:none;z-index:1000;box-shadow:0 4px 20px rgba(0,0,0,0.5);}
        .ctx.active{display:block;}
        .ctx-item{padding:8px 16px;cursor:pointer;font-size:11px;transition:0.2s;color:#eee;}
        .ctx-item:hover{background:rgba(255,255,255,0.1);color:var(--accent);}
        .ctx-div{height:1px;background:rgba(255,255,255,0.1);margin:4px 0;}

        /* Custom Cursor */
        #cursor{position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:9999;transition:opacity 0.2s;}
        .c-dot{position:absolute;width:6px;height:6px;background:var(--pink);border-radius:50%;transform:translate(-50%,-50%);box-shadow:0 0 10px var(--pink);}
        .c-ring{position:absolute;width:30px;height:30px;border:1px solid rgba(255,255,255,0.5);border-radius:50%;transform:translate(-50%,-50%);transition:0.1s;}
        body.hovering .c-ring{border-color:var(--accent);transform:translate(-50%,-50%) scale(1.5);}

        /* Coordinates */
        .coords {position:fixed;bottom:10px;left:10px;font-size:10px;color:rgba(255,255,255,0.4);pointer-events:none;}

        @media (max-width: 768px) {
            .hud, .coords { display: none; }
            .top-bar { top: 60px; width: 90%; }
            .search-in { width: 100%; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="cursor">
        <div class="c-dot"></div>
        <div class="c-ring"></div>
    </div>

    <div class="hud">[DRAG] Move Task · [R-CLICK] Menu · [SPACE] New Task · [SCROLL] Zoom</div>
    <div class="coords" id="coord-display">0, 0, 0</div>

    <div class="top-bar">
        <input id="search" class="search-in" type="text" placeholder="Filter tasks...">
    </div>

    <div class="quad-nav">
        <div class="q-btn todo" data-q="todo">? <span class="q-tooltip">To Do</span></div>
        <div class="q-btn prog" data-q="prog">~ <span class="q-tooltip">In Progress</span></div>
        <div class="q-btn done" data-q="done">✓ <span class="q-tooltip">Completed</span></div>
        <div class="q-btn back" data-q="back">! <span class="q-tooltip">Backlog</span></div>
    </div>

    <div class="presets">
        <button class="btn active" data-p="std">Free</button>
        <button class="btn" data-p="top">Board</button>
        <button class="btn" data-p="side">List</button>
    </div>

    <div class="trash" id="trash">✕</div>

    <div id="info" class="info">
        <h3 id="iTitle">Task Title</h3>
        <div class="info-row"><span>Status:</span><span id="iState" style="color:var(--accent)">-</span></div>
        <div class="info-row"><span>Pos:</span><span id="iPos">0,0</span></div>
        <div style="margin-top:8px;font-size:11px;opacity:0.7;line-height:1.4;" id="iDesc">Description goes here...</div>
    </div>

    <div id="ctx" class="ctx">
        <div class="ctx-item" data-a="edit">Edit Details</div>
        <div class="ctx-item" data-a="clone">Duplicate</div>
        <div class="ctx-div"></div>
        <div class="ctx-item" data-a="del" style="color:#ff4444">Delete</div>
    </div>

    <div class="fab-zone" id="joystick">
        <div class="fab-cube" id="joy-cube">
            <div class="f-face"></div><div class="f-face"></div><div class="f-face"></div>
            <div class="f-face"></div><div class="f-face"></div><div class="f-face"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>

    <script>
        // --- 1. CONFIG & STATE ---
        const CFG = {
            cam: { height: 40, damping: 0.1 },
            bounds: { x: 50, z: 40 }, // Magnetic perimeter limits
            colors: {
                todo: 0xffff00,    // Yellow
                prog: 0x00ffff,    // Cyan
                done: 0x00ff00,    // Green
                back: 0xff0000     // Red
            }
        };

        const STATE = {
            cubes: [],
            sel: null,   // Selected (clicked)
            hov: null,   // Hovered
            drag: null,  // Currently dragging
            panning: false,
            panStart: new THREE.Vector3()
        };

        // --- 2. SCENE SETUP (PUNT HIGH FIDELITY) ---
        const sc = new THREE.Scene();
        sc.background = new THREE.Color(0x0f1014);
        sc.fog = new THREE.FogExp2(0x0f1014, 0.015);

        const cam = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
        const rend = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        rend.setSize(innerWidth, innerHeight);
        rend.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        rend.shadowMap.enabled = true;
        rend.shadowMap.type = THREE.PCFSoftShadowMap;

        // Physics World (PUNT)
        const world = new CANNON.World();
        world.gravity.set(0, -19.81, 0); // Snappy gravity
        world.broadphase = new CANNON.NaiveBroadphase();
        const matDef = new CANNON.Material();
        const matWall = new CANNON.Material();
        // High friction, low bounce for stable stacking
        world.addContactMaterial(new CANNON.ContactMaterial(matDef, matDef, { friction: 0.5, restitution: 0.1 }));
        world.addContactMaterial(new CANNON.ContactMaterial(matDef, matWall, { friction: 0.0, restitution: 0.0 }));

        // Lighting (PUNT Neon)
        sc.add(new THREE.AmbientLight(0xffffff, 0.4));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(20, 50, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        sc.add(dirLight);

        // Neon ambient glow points
        const l1 = new THREE.PointLight(0x00ffff, 2, 60); l1.position.set(-30, 10, -30); sc.add(l1);
        const l2 = new THREE.PointLight(0xff00ff, 2, 60); l2.position.set(30, 10, 30); sc.add(l2);

        // Reflection Probe
        const cRT = new THREE.WebGLCubeRenderTarget(256, { generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter });
        const cCam = new THREE.CubeCamera(0.1, 500, cRT);
        sc.add(cCam);

        // Floor
        const gndGeo = new THREE.PlaneGeometry(200, 200);
        const gndMat = new THREE.MeshStandardMaterial({ 
            color: 0x080808, roughness: 0.4, metalness: 0.8, 
            envMap: cRT.texture, envMapIntensity: 0.5 
        });
        const gnd = new THREE.Mesh(gndGeo, gndMat);
        gnd.rotation.x = -Math.PI / 2;
        gnd.position.y = -4;
        gnd.receiveShadow = true;
        sc.add(gnd);

        const gndBody = new CANNON.Body({ mass: 0, material: matDef });
        gndBody.addShape(new CANNON.Plane());
        gndBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
        gndBody.position.set(0, -4, 0);
        world.addBody(gndBody);

        // Grid & Zones
        const gridGrp = new THREE.Group();
        sc.add(gridGrp);

        function drawGrid() {
            // Quadrant Lines
            const mat = new THREE.LineBasicMaterial({ color: 0x222233 });
            const geoX = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, -3.9, -CFG.bounds.z), new THREE.Vector3(0, -3.9, CFG.bounds.z)]);
            const geoZ = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-CFG.bounds.x, -3.9, 0), new THREE.Vector3(CFG.bounds.x, -3.9, 0)]);
            gridGrp.add(new THREE.Line(geoX, mat));
            gridGrp.add(new THREE.Line(geoZ, mat));
            
            // Labels
            const makeLabel = (txt, x, z, col) => {
                const cvs = document.createElement('canvas'); cvs.width=256; cvs.height=64;
                const ctx = cvs.getContext('2d');
                ctx.fillStyle = col; ctx.font = 'bold 40px monospace'; ctx.textAlign='center';
                ctx.fillText(txt, 128, 50);
                const sp = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(cvs), opacity:0.3, transparent:true }));
                sp.position.set(x, -3.8, z);
                sp.scale.set(10, 2.5, 1);
                gridGrp.add(sp);
            }
            makeLabel("TO DO", 15, -15, "#ffff00");
            makeLabel("IN PROGRESS", -15, -15, "#00ffff");
            makeLabel("COMPLETED", 15, 15, "#00ff00");
            makeLabel("BACKLOG", -15, 15, "#ff0000");
        }
        drawGrid();

        // --- 3. CUBE CLASS (KANBAN LOGIC + PUNT PHYSICS) ---
        const cubeGeo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
        const cubeEdge = new THREE.EdgesGeometry(cubeGeo);

        class TaskCube {
            constructor(x, y, z, title="Task", desc="") {
                this.title = title;
                this.desc = desc;
                this.id = Math.random().toString(36).substr(2, 9);
                
                // Visuals
                this.mat = new THREE.MeshPhysicalMaterial({
                    color: 0x333333, metalness: 0.1, roughness: 0.1,
                    clearcoat: 1.0, envMap: cRT.texture, envMapIntensity: 1.5,
                    emissive: 0x000000, emissiveIntensity: 0.5
                });
                
                this.mesh = new THREE.Mesh(cubeGeo, this.mat);
                this.mesh.position.set(x, y, z);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                this.mesh.userData.task = this;

                // Glowing edges
                this.edges = new THREE.LineSegments(cubeEdge, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 }));
                this.mesh.add(this.edges);

                // Text Label
                this.updateLabel();
                sc.add(this.mesh);

                // Physics
                const shape = new CANNON.Box(new CANNON.Vec3(0.75, 0.75, 0.75));
                this.body = new CANNON.Body({ mass: 5, material: matDef });
                this.body.addShape(shape);
                this.body.position.set(x, y, z);
                this.body.linearDamping = 0.5; // Heavy feel
                this.body.angularDamping = 0.5;
                world.addBody(this.body);

                this.updateStatus(); // Set initial color based on pos
            }

            updateLabel() {
                if(this.lbl) this.mesh.remove(this.lbl);
                const cvs = document.createElement('canvas'); cvs.width=256; cvs.height=128;
                const ctx = cvs.getContext('2d');
                ctx.fillStyle='#fff'; ctx.font='bold 28px sans-serif'; ctx.textAlign='center';
                ctx.fillText(this.title.substring(0, 15), 128, 64);
                const sp = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(cvs) }));
                sp.scale.set(3, 1.5, 1);
                sp.position.y = 1.2;
                this.lbl = sp;
                this.mesh.add(sp);
            }

            getStatusFromPos() {
                const {x, z} = this.body.position;
                if(x > 0 && z < 0) return 'todo';
                if(x < 0 && z < 0) return 'prog';
                if(x > 0 && z > 0) return 'done';
                return 'back';
            }

            updateStatus() {
                const stat = this.getStatusFromPos();
                if(this.status !== stat) {
                    this.status = stat;
                    const col = CFG.colors[stat];
                    this.mat.color.setHex(col);
                    this.mat.emissive.setHex(col);
                }
            }

            hover(bool) {
                document.body.classList.toggle('hovering', bool);
                this.mat.emissiveIntensity = bool ? 1.5 : 0.5;
            }

            tick() {
                this.mesh.position.copy(this.body.position);
                this.mesh.quaternion.copy(this.body.quaternion);
                if(!STATE.drag) this.updateStatus();
            }

            remove() {
                sc.remove(this.mesh);
                world.removeBody(this.body);
            }
        }

        // --- 4. INTERACTION & CAMERA RIG ---
        const rig = {
            target: new THREE.Vector3(0, 0, 0), // Where we look
            actual: new THREE.Vector3(0, 0, 0), // Smoothed lookAt
            offset: new THREE.Vector3(0, 15, 20), // Camera offset
            zoom: 1.0,
            preset: 'std'
        };

        const ray = new THREE.Raycaster();
        const ptr = new THREE.Vector2();
        const dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        
        // Raycasting helper
        function cast(e) {
            ptr.x = (e.clientX / innerWidth) * 2 - 1;
            ptr.y = -(e.clientY / innerHeight) * 2 + 1;
            ray.setFromCamera(ptr, cam);
            // Cubes
            const hits = ray.intersectObjects(STATE.cubes.map(c=>c.mesh));
            if(hits.length) return { type: 'cube', obj: hits[0].object.userData.task, pt: hits[0].point };
            // Ground
            const target = new THREE.Vector3();
            ray.ray.intersectPlane(dragPlane, target);
            if(target) return { type: 'ground', pt: target };
            return null;
        }

        // Input Listeners
        window.addEventListener('mousemove', e => {
            // Update custom cursor
            const cur = document.getElementById('cursor');
            const ring = cur.querySelector('.c-ring');
            const dot = cur.querySelector('.c-dot');
            dot.style.transform = `translate(${e.clientX}px, ${e.clientY}px)`;
            ring.style.transform = `translate(${e.clientX}px, ${e.clientY}px)`;

            const hit = cast(e);
            
            // Hover logic
            if(hit && hit.type === 'cube' && !STATE.drag) {
                if(STATE.hov && STATE.hov !== hit.obj) STATE.hov.hover(false);
                STATE.hov = hit.obj;
                STATE.hov.hover(true);
            } else if(STATE.hov && (!hit || hit.type !== 'cube')) {
                STATE.hov.hover(false);
                STATE.hov = null;
            }

            // Drag Logic
            if(STATE.drag) {
                const gHit = cast(e); // Get ground point
                if(gHit && gHit.pt) {
                    // Smooth lerp for kinematic drag
                    const targetPos = gHit.pt.clone();
                    targetPos.y = 2.5; // Lift height
                    STATE.drag.body.position.set(targetPos.x, targetPos.y, targetPos.z);
                    STATE.drag.body.velocity.set(0,0,0);
                    STATE.drag.body.angularVelocity.set(0,0,0);
                    
                    // Update Info Panel live
                    STATE.drag.updateStatus();
                    showInfo(STATE.drag);

                    // Trash Hover
                    const el = document.elementFromPoint(e.clientX, e.clientY);
                    document.getElementById('trash').classList.toggle('active', el && el.id === 'trash');
                }
            } 
            // Pan Logic
            else if(STATE.panning) {
                if(hit && hit.pt) {
                    const delta = hit.pt.clone().sub(STATE.panStart).multiplyScalar(0.5); // 0.5 dampens pan speed
                    rig.target.sub(new THREE.Vector3(delta.x, 0, delta.z));
                    // Re-read start point to avoid continuous acceleration
                    const newHit = cast(e);
                    if(newHit && newHit.pt) STATE.panStart.copy(newHit.pt);
                }
            }
        });

        window.addEventListener('mousedown', e => {
            if(e.button !== 0) return; // Only left click
            const hit = cast(e);
            if(hit && hit.type === 'cube') {
                STATE.drag = hit.obj;
                STATE.drag.body.type = CANNON.Body.KINEMATIC; // Take control
                STATE.drag.body.wakeUp();
                showInfo(STATE.drag);
                STATE.sel = STATE.drag;
            } else if(hit) {
                STATE.panning = true;
                STATE.panStart.copy(hit.pt);
                document.getElementById('info').classList.remove('active');
            }
        });

        window.addEventListener('mouseup', e => {
            if(STATE.drag) {
                STATE.drag.body.type = CANNON.Body.DYNAMIC; // Release control
                
                // Check Trash
                const el = document.elementFromPoint(e.clientX, e.clientY);
                if(el && el.id === 'trash') {
                    const idx = STATE.cubes.indexOf(STATE.drag);
                    if(idx > -1) STATE.cubes.splice(idx, 1);
                    STATE.drag.remove();
                    document.getElementById('info').classList.remove('active');
                    save();
                }

                STATE.drag = null;
                document.getElementById('trash').classList.remove('active');
                save();
            }
            STATE.panning = false;
        });

        window.addEventListener('contextmenu', e => {
            e.preventDefault();
            const hit = cast(e);
            if(hit && hit.type === 'cube') {
                STATE.sel = hit.obj;
                const m = document.getElementById('ctx');
                m.style.left = e.clientX + 'px';
                m.style.top = e.clientY + 'px';
                m.classList.add('active');
            }
        });

        window.addEventListener('wheel', e => {
            rig.zoom += e.deltaY * 0.001;
            rig.zoom = Math.max(0.2, Math.min(2.0, rig.zoom));
        });

        // Click outside context menu to close
        window.addEventListener('click', () => document.getElementById('ctx').classList.remove('active'));

        // --- 5. LOGIC & UI FUNCTIONS ---

        function showInfo(t) {
            const p = document.getElementById('info');
            p.classList.add('active');
            document.getElementById('iTitle').innerText = t.title;
            document.getElementById('iDesc').innerText = t.desc || "No description provided.";
            document.getElementById('iState').innerText = t.status.toUpperCase();
            document.getElementById('iPos').innerText = `${t.body.position.x.toFixed(1)}, ${t.body.position.z.toFixed(1)}`;
        }

        // Context Menu Actions
        document.querySelectorAll('.ctx-item').forEach(el => {
            el.addEventListener('click', () => {
                if(!STATE.sel) return;
                const act = el.dataset.a;
                if(act === 'del') {
                    STATE.cubes = STATE.cubes.filter(c => c !== STATE.sel);
                    STATE.sel.remove();
                } else if(act === 'clone') {
                    const p = STATE.sel.body.position;
                    const c = new TaskCube(p.x, p.y+2, p.z, STATE.sel.title, STATE.sel.desc);
                    STATE.cubes.push(c);
                } else if(act === 'edit') {
                    const t = prompt("Task Title:", STATE.sel.title);
                    if(t) {
                        STATE.sel.title = t;
                        STATE.sel.desc = prompt("Description:", STATE.sel.desc) || "";
                        STATE.sel.updateLabel();
                        showInfo(STATE.sel);
                    }
                }
                save();
            });
        });

        // View Presets
        document.querySelectorAll('.btn[data-p]').forEach(b => {
            b.addEventListener('click', () => {
                document.querySelectorAll('.btn').forEach(bb=>bb.classList.remove('active'));
                b.classList.add('active');
                rig.preset = b.dataset.p;
            });
        });

        // Quadrant Jump
        const quadPos = {
            todo: {x: 10, z: -10},
            prog: {x: -10, z: -10},
            done: {x: 10, z: 10},
            back: {x: -10, z: 10}
        };
        document.querySelectorAll('.q-btn').forEach(b => {
            b.addEventListener('click', () => {
                const t = quadPos[b.dataset.q];
                gsap.to(rig.target, {x: t.x, z: t.z, duration: 1, ease: "power2.out"});
            });
        });

        // Keyboard
        window.addEventListener('keydown', e => {
            if(e.key === ' ') {
                const c = new TaskCube(rig.target.x, 5, rig.target.z, "New Task", "Created via spacebar");
                STATE.cubes.push(c);
                save();
            }
        });

        // Search
        document.getElementById('search').addEventListener('input', e => {
            const v = e.target.value.toLowerCase();
            STATE.cubes.forEach(c => {
                const match = c.title.toLowerCase().includes(v);
                c.mesh.visible = match;
                if(match) c.body.wakeUp(); // Jiggle to show presence
            });
        });

        // --- 6. PERSISTENCE ---
        function save() {
            const data = STATE.cubes.map(c => ({
                t: c.title, d: c.desc, 
                p: {x: c.body.position.x, y: c.body.position.y, z: c.body.position.z},
                q: {x: c.body.quaternion.x, y: c.body.quaternion.y, z: c.body.quaternion.z, w: c.body.quaternion.w}
            }));
            localStorage.setItem('punt_kanban', JSON.stringify(data));
        }

        function load() {
            const s = localStorage.getItem('punt_kanban');
            if(s) {
                JSON.parse(s).forEach(d => {
                    const c = new TaskCube(d.p.x, d.p.y, d.p.z, d.t, d.d);
                    c.body.quaternion.set(d.q.x, d.q.y, d.q.z, d.q.w);
                    STATE.cubes.push(c);
                });
            } else {
                // Initial Demo Data
                STATE.cubes.push(new TaskCube(10, 2, -10, "Design UI", "Make it neon"));
                STATE.cubes.push(new TaskCube(-10, 2, -10, "Physics", "Implement Cannon.js"));
                STATE.cubes.push(new TaskCube(10, 2, 10, "Deploy", "Ship it"));
            }
        }

        // --- 7. ANIMATION LOOP ---
        
        // Joystick logic (Visual only for now, mapped to arrow keys essentially)
        const joy = { el: document.getElementById('joy-cube'), active: false, start: {x:0,y:0} };
        const joyZone = document.getElementById('joystick');
        
        joyZone.addEventListener('mousedown', e=>{ joy.active=true; joy.start={x:e.clientX, y:e.clientY}; joy.el.style.transition='none'; });
        window.addEventListener('mouseup', ()=>{ joy.active=false; joy.el.style.transform='rotateX(-25deg) rotateY(-45deg)'; joy.el.style.transition='0.3s'; });
        window.addEventListener('mousemove', e=>{
            if(!joy.active) return;
            const dx = e.clientX - joy.start.x;
            const dy = e.clientY - joy.start.y;
            joy.el.style.transform = `rotateX(${-25 + dy/2}deg) rotateY(${-45 + dx/2}deg)`;
            rig.target.x += dx * 0.005;
            rig.target.z += dy * 0.005;
        });

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);

            // Step Physics
            world.step(1/60, dt, 3);
            STATE.cubes.forEach(c => c.tick());

            // Camera Logic (The Magnetic Bounds)
            // 1. Soft clamp target to bounds
            const bx = CFG.bounds.x;
            const bz = CFG.bounds.z;
            
            // Magnetic pull back to center if out of bounds
            if(rig.target.x > bx) rig.target.x += (bx - rig.target.x) * 0.05;
            if(rig.target.x < -bx) rig.target.x += (-bx - rig.target.x) * 0.05;
            if(rig.target.z > bz) rig.target.z += (bz - rig.target.z) * 0.05;
            if(rig.target.z < -bz) rig.target.z += (-bz - rig.target.z) * 0.05;

            // 2. Interpolate Actual position
            rig.actual.lerp(rig.target, 0.08);

            // 3. Determine Offset based on preset
            let targetOffset = new THREE.Vector3();
            if(rig.preset === 'std') targetOffset.set(0, 15, 20);
            if(rig.preset === 'top') targetOffset.set(0, 40, 1); // Almost vertical
            if(rig.preset === 'side') targetOffset.set(30, 5, 0); // Side view

            // Apply Zoom
            const finOffset = targetOffset.clone().multiplyScalar(rig.zoom);
            
            // Apply to Camera
            cam.position.lerp(rig.actual.clone().add(finOffset), 0.1);
            cam.lookAt(rig.actual);

            // UI Updates
            const coord = document.getElementById('coord-display');
            coord.innerText = `X:${rig.actual.x.toFixed(0)} Z:${rig.actual.z.toFixed(0)}`;

            cCam.update(rend, sc);
            rend.render(sc, cam);
        }

        // Init
        load();
        animate();
        
        // Resize
        window.addEventListener('resize', () => {
            cam.aspect = innerWidth / innerHeight;
            cam.updateProjectionMatrix();
            rend.setSize(innerWidth, innerHeight);
        });

    </script>
</body>
</html>
