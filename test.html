<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Hybrid Neon Blocks: Smoother Drag</title>
  
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.babylonjs.com/cannon.js"></script>

  <style>
    :root {
      --bg: #000000;
      --accent: #00ff88;
      --glass: rgba(10, 10, 20, 0.85);
      --border: rgba(80, 80, 100, 0.4);
    }
    body { margin: 0; overflow: hidden; background: var(--bg); font-family: system-ui, -apple-system, sans-serif; color: #eee; user-select: none; }
    canvas { display: block; width: 100vw; height: 100vh; outline: none; cursor: grab; }
    canvas.grabbing { cursor: grabbing; }
    
    #ui-layer {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none;
      padding: 20px;
      box-sizing: border-box;
    }

    #status-panel {
      position: fixed;
      top: 20px; left: 20px;
      background: var(--glass);
      backdrop-filter: blur(10px);
      padding: 15px 20px;
      border-radius: 12px;
      border: 1px solid var(--border);
      font-size: 14px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      min-width: 200px;
    }

    .status-row { display: flex; justify-content: space-between; margin-bottom: 8px; }
    .status-label { opacity: 0.7; }
    .status-val { font-weight: bold; color: var(--accent); }

    #controls-hint {
      position: fixed;
      bottom: 20px; left: 20px;
      color: rgba(255,255,255,0.4);
      font-size: 12px;
      line-height: 1.5;
    }

    /* Floating Action Button */
    #fab {
      position: fixed;
      bottom: 32px; right: 32px;
      width: 60px; height: 60px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      color: #000;
      font-size: 30px;
      font-weight: 700;
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 0 20px rgba(0,255,136,0.4);
      transition: transform 0.2s;
      display: flex; align-items: center; justify-content: center;
    }
    #fab:hover { transform: scale(1.1); box-shadow: 0 0 40px rgba(0,255,136,0.6); }
    #fab:active { transform: scale(0.95); }
  </style>
</head>
<body>

  <div id="ui-layer">
    <div id="status-panel">
      <div class="status-row">
        <span class="status-label">BLOCKS</span>
        <span class="status-val" id="blockCount">0</span>
      </div>
      <div class="status-row">
        <span class="status-label">VIEW</span>
        <span class="status-val" id="viewStatus">BIRD'S EYE</span>
      </div>
    </div>
    <div id="controls-hint">
      SHIFT: Toggle Ground View<br>
      L-CLICK DRAG: Grab & Move Block (Fixed!)<br>
      R-CLICK: Spawn / Nudge<br>
      SPACE: Stack<br>
      EDGE: Pan
    </div>
  </div>

  <button id="fab" title="Spawn Random">+</button>
  <canvas id="canvas"></canvas>

<script>
/**
 * HYBRID NEON BLOCKS - SMOOTHER DRAG VERSION
 */

const CONFIG = {
  cubeSize: 2,
  boundary: 90,
  edgePanMargin: 50,
  edgePanSpeed: 0.8,
};

// Original Camera Configuration
let currentCamConfig = {
    y: 62,
    z: 0.001,
    rotX: -Math.PI / 2 + 0.0001
};

const groundCamConfig = {
    y: 9.5,
    z: 27,
    rotX: -0.43
};

// State
let scene, camera, renderer, world;
let raycaster, mouse = new THREE.Vector2();
let mouseScreen = { x: 0, y: 0 };
let cubes = [];
let isShiftPressed = false;

// Interactions
let isDragging = false;
let isRightDragging = false;
let lastMousePos = { x: 0, y: 0 };
let rightClickStart = { x: 0, y: 0 };
let mouseConstraint = null;

// New state for stable dragging
let camToGrabDistance = 0;

// Camera Rig
const Rig = {
  pivot: new THREE.Vector3(0, 0, 0),
  targetPivot: new THREE.Vector3(0, 0, 0),
  zoom: 0,
  targetZoom: 0
};

// --- INITIALIZATION ---

function init() {
  // 1. Scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  scene.fog = new THREE.FogExp2(0x000000, 0.005);

  // 2. Camera
  camera = new THREE.PerspectiveCamera(68, window.innerWidth / window.innerHeight, 0.1, 1000);

  // 3. Renderer
  const canvas = document.getElementById('canvas');
  renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: 'high-performance' });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  // 4. Physics
  world = new CANNON.World();
  world.gravity.set(0, -125, 0); 
  world.broadphase = new CANNON.NaiveBroadphase();
  world.solver.iterations = 15;

  // 5. Lighting
  scene.add(new THREE.AmbientLight(0xffffff, 0.5));
  const dirLight = new THREE.DirectionalLight(0xffffff, 1.6);
  dirLight.position.set(15, 40, 15);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 2048;
  dirLight.shadow.mapSize.height = 2048;
  scene.add(dirLight);

  const neon1 = new THREE.PointLight(0x00ffff, 5, 80); neon1.position.set(-25, 20, -25); scene.add(neon1);
  const neon2 = new THREE.PointLight(0xff00ff, 5, 80); neon2.position.set(25, 20, 25); scene.add(neon2);
  const neon3 = new THREE.PointLight(0x00ff88, 4.5, 70); neon3.position.set(0, 30, 0); scene.add(neon3);

  // 6. Environment
  createGround();
  createWalls();

  raycaster = new THREE.Raycaster();
  
  // Mouse Constraint Body (The invisible point we drag the cube toward)
  const mouseBody = new CANNON.Body({ mass: 0 });
  mouseBody.addShape(new CANNON.Sphere(0.1));
  mouseBody.position.set(0,0,0);
  world.addBody(mouseBody);
  window.mouseConstraintBody = mouseBody;

  setupInputs();
  
  // Initial cubes
  for(let i=0; i<10; i++) setTimeout(() => createCube(), i*100);

  updateStatus();
  animate();
}

function createGround() {
  const geo = new THREE.PlaneGeometry(220, 220);
  const mat = new THREE.MeshStandardMaterial({ color: 0x0f0f1f, roughness: 0.85, metalness: 0.95, envMapIntensity: 1.3 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.rotation.x = -Math.PI/2;
  mesh.position.y = -10;
  mesh.receiveShadow = true;
  scene.add(mesh);

  const grid = new THREE.GridHelper(220, 110, 0x004444, 0x002222);
  grid.position.y = -9.98;
  scene.add(grid);

  // Physics Ground
  const body = new CANNON.Body({ mass: 0, material: new CANNON.Material({ friction: 0.4, restitution: 0 }) });
  body.addShape(new CANNON.Plane());
  body.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
  body.position.y = -10;
  world.addBody(body);
}

function createWalls() {
  const wallMat = new CANNON.Material({ friction: 0.3, restitution: 0.5 });
  const thickness = 8, height = 80, limit = CONFIG.boundary;
  
  const addWall = (x, z, w, d) => {
    const shape = new CANNON.Box(new CANNON.Vec3(w/2, height/2, d/2));
    const body = new CANNON.Body({ mass: 0, material: wallMat });
    body.addShape(shape);
    body.position.set(x, -10 + height/2, z);
    world.addBody(body);
  };

  addWall(0, limit+4, limit*2+20, thickness);
  addWall(0, -(limit+4), limit*2+20, thickness);
  addWall(limit+4, 0, thickness, limit*2+20);
  addWall(-(limit+4), 0, thickness, limit*2+20);
}

// --- CUBE LOGIC ---

function createCube(pos) {
  const position = pos || new THREE.Vector3(
    (Math.random()-0.5)*50, 
    25 + Math.random()*20, 
    (Math.random()-0.5)*50
  );

  // Mesh
  const geo = new THREE.BoxGeometry(CONFIG.cubeSize, CONFIG.cubeSize, CONFIG.cubeSize);
  const color = new THREE.Color().setHSL(Math.random(), 1.0, 0.5);
  const mat = new THREE.MeshPhysicalMaterial({
    color: color, metalness: 1.0, roughness: 0.05,
    emissive: color, emissiveIntensity: 3.0, envMapIntensity: 1.6
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.copy(position);
  mesh.castShadow = true; mesh.receiveShadow = true;
  scene.add(mesh);

  // Body
  const shape = new CANNON.Box(new CANNON.Vec3(CONFIG.cubeSize/2, CONFIG.cubeSize/2, CONFIG.cubeSize/2));
  const body = new CANNON.Body({ mass: 1.5 });
  body.addShape(shape);
  body.position.copy(position);
  
  body.linearDamping = 0.25;
  body.angularDamping = 0.3;
  
  world.addBody(body);

  const cube = { mesh, body };
  mesh.userData.cube = cube;
  cubes.push(cube);
  
  // Pop in effect
  mesh.scale.set(0,0,0);
  gsap.to(mesh.scale, { x:1, y:1, z:1, duration: 0.4, ease: "back.out(1.5)" });
  
  updateStatus();
  return cube;
}

function spawnStackAtCursor() {
  raycaster.setFromCamera(mouse, camera);
  const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
  const hit = new THREE.Vector3();
  raycaster.ray.intersectPlane(plane, hit);
  
  if (hit) {
    // Snap to grid
    const gx = Math.round(hit.x / CONFIG.cubeSize) * CONFIG.cubeSize;
    const gz = Math.round(hit.z / CONFIG.cubeSize) * CONFIG.cubeSize;
    
    // Find highest cube
    let highestY = -9;
    
    cubes.forEach(c => {
      if (Math.abs(c.body.position.x - gx) < 1 && Math.abs(c.body.position.z - gz) < 1) {
        if (c.body.position.y > highestY) highestY = c.body.position.y;
      }
    });

    // Gap: 0 (touching) if in ground view, 1.5 (floating) if in bird's eye view
    const gap = isShiftPressed ? 0 : 1.5; 
    const newY = highestY + CONFIG.cubeSize + gap;
    
    const newCube = createCube(new THREE.Vector3(gx, newY, gz));
    
    if (!isShiftPressed) {
      newCube.body.velocity.set(0,0,0);
      newCube.body.angularVelocity.set(0,0,0);
      newCube.body.sleep();
    }
  }
}

function nudgeCube(cube, faceNormal) {
  const worldNormal = faceNormal.clone().transformDirection(cube.mesh.matrixWorld).round();
  
  const targetPos = cube.body.position.clone().vadd(worldNormal.clone().multiplyScalar(CONFIG.cubeSize));
  
  gsap.to(cube.body.position, {
    x: targetPos.x,
    y: targetPos.y,
    z: targetPos.z,
    duration: 0.2,
    ease: "power2.out",
    onUpdate: () => {
      cube.body.velocity.set(0,0,0);
      cube.body.angularVelocity.set(0,0,0);
    }
  });
  
  cube.body.wakeUp();
}

function updateStatus() {
  document.getElementById('blockCount').textContent = cubes.length;
  document.getElementById('viewStatus').textContent = isShiftPressed ? 'GROUND VIEW' : 'BIRD\'S EYE';
}

// --- CONTROLS ---

function setupInputs() {
  document.getElementById('fab').addEventListener('click', () => createCube());
  
  // Keyboard (Shift to toggle view)
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Shift') {
      e.preventDefault(); 
      if (!isShiftPressed) {
          isShiftPressed = true;
          gsap.to(currentCamConfig, { ...groundCamConfig, duration: 0.7, ease: "power2.out" });
          updateStatus();
      }
    }
    if (e.code === 'Space') {
       e.preventDefault();
       spawnStackAtCursor();
    }
  });

  window.addEventListener('keyup', (e) => {
    if (e.key === 'Shift') {
      if (isShiftPressed) {
          isShiftPressed = false;
          gsap.to(currentCamConfig, { 
            y: 62, 
            z: 0.001, 
            rotX: -Math.PI / 2 + 0.0001, 
            duration: 0.8, 
            ease: "power2.inOut" 
          });
          updateStatus();
      }
    }
  });

  // Mouse / Touch
  const cvs = document.getElementById('canvas');

  cvs.addEventListener('mousedown', (e) => {
    if (e.button === 2) { // Right Click for Camera Drag
      isRightDragging = true;
      rightClickStart = { x: e.clientX, y: e.clientY };
      lastMousePos = { x: e.clientX, y: e.clientY };
      cvs.style.cursor = 'grabbing';
      return;
    }
    
    // Left Click Drag (Physics) - FIX APPLIED HERE
    if (e.button === 0) {
        const hits = getIntersects(e);
        if (hits.length > 0) {
            const hit = hits[0];
            const obj = hit.object.userData.cube;
            if (obj) {
                isDragging = true;
                
                // 1. Calculate and store the distance from the camera to the grab point
                camToGrabDistance = camera.position.distanceTo(hit.point); 
                
                // 2. Set the initial position of the mouse anchor body
                window.mouseConstraintBody.position.copy(hit.point);

                // 3. Create the constraint
                const pivot = hit.point.clone().sub(obj.body.position);
                
                mouseConstraint = new CANNON.PointToPointConstraint(obj.body, pivot, window.mouseConstraintBody, new CANNON.Vec3(0,0,0));
                
                // 4. Limit force to prevent erratic jittering
                mouseConstraint.setMaxForce(1500); 
                
                world.addConstraint(mouseConstraint);
                obj.body.wakeUp();
            }
        }
    }
  });

  cvs.addEventListener('mousemove', (e) => {
    mouseScreen.x = e.clientX;
    mouseScreen.y = e.clientY;
    
    // 1. Right Drag (Camera)
    if (isRightDragging) {
      const dx = e.clientX - lastMousePos.x;
      const dy = e.clientY - lastMousePos.y;
      
      Rig.targetPivot.x -= dx * 0.12;
      Rig.targetPivot.z -= dy * 0.12;
      
      const limit = CONFIG.boundary;
      Rig.targetPivot.x = Math.max(-limit, Math.min(limit, Rig.targetPivot.x));
      Rig.targetPivot.z = Math.max(-limit, Math.min(limit, Rig.targetPivot.z));
      
      lastMousePos = { x: e.clientX, y: e.clientY };
    }

    // 2. Left Drag (Physics) - FIX APPLIED HERE
    if (isDragging && mouseConstraint) {
        raycaster.setFromCamera(mouse, camera);
        
        // Project the ray forward by the stored distance to get the new stable target
        const newTarget = raycaster.ray.at(camToGrabDistance, new THREE.Vector3());
        
        // Update the constraint anchor position
        window.mouseConstraintBody.position.copy(newTarget);
    }
  });

  window.addEventListener('mouseup', (e) => {
    if (e.button === 2) { // Right Click End
      const dx = Math.abs(e.clientX - rightClickStart.x);
      const dy = Math.abs(e.clientY - rightClickStart.y);
      
      if (dx < 10 && dy < 10) {
        // It's a CLICK (Spawn / Nudge)
        const hits = getIntersects(e);
        if (hits.length > 0) {
          const cube = hits[0].object.userData.cube;
          const face = hits[0].face.normal;
          nudgeCube(cube, face);
        } else {
          // Clicked Ground -> Spawn
          raycaster.setFromCamera(mouse, camera);
          const plane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
          const hit = new THREE.Vector3();
          if (raycaster.ray.intersectPlane(plane, hit)) {
             hit.y += 5;
             createCube(hit);
          }
        }
      }
      
      isRightDragging = false;
      cvs.style.cursor = 'grab';
    }
    
    // Left Click Release
    if (e.button === 0 && isDragging) {
      isDragging = false;
      if(mouseConstraint) world.removeConstraint(mouseConstraint);
    }
  });

  window.addEventListener('contextmenu', e => e.preventDefault());
  
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
  
  window.addEventListener('wheel', e => {
    Rig.targetZoom += e.deltaY * 0.002;
    Rig.targetZoom = Math.max(-0.5, Math.min(1.6, Rig.targetZoom));
  });
}

function getIntersects(e) {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  return raycaster.intersectObjects(cubes.map(c => c.mesh));
}

// --- ANIMATION ---

function animate() {
  requestAnimationFrame(animate);
  
  // Physics Step
  world.step(1/60);
  
  // Sync
  cubes.forEach(c => {
    c.mesh.position.copy(c.body.position);
    c.mesh.quaternion.copy(c.body.quaternion);
  });
  
  // Edge Panning
  handleEdgePan();
  
  // Camera Rig
  Rig.pivot.lerp(Rig.targetPivot, 0.1);
  Rig.zoom += (Rig.targetZoom - Rig.zoom) * 0.1;
  
  let y = currentCamConfig.y;
  let z = currentCamConfig.z;
  const zoomFactor = 0.5 + Rig.zoom * 0.9;
  y *= zoomFactor;
  z *= zoomFactor;
  
  camera.position.set(Rig.pivot.x, Rig.pivot.y + y, Rig.pivot.z + z);
  camera.rotation.x = currentCamConfig.rotX;
  camera.lookAt(Rig.pivot);
  
  renderer.render(scene, camera);
}

function handleEdgePan() {
  const margin = CONFIG.edgePanMargin;
  const speed = CONFIG.edgePanSpeed;
  
  let mx = 0, mz = 0;
  
  if (mouseScreen.x < margin) mx = -1;
  if (mouseScreen.x > window.innerWidth - margin) mx = 1;
  if (mouseScreen.y < margin) mz = -1;
  if (mouseScreen.y > window.innerHeight - margin) mz = 1;
  
  if (mx !== 0 || mz !== 0) {
    Rig.targetPivot.x += mx * speed;
    Rig.targetPivot.z += mz * speed;
    
    const limit = CONFIG.boundary;
    Rig.targetPivot.x = Math.max(-limit, Math.min(limit, Rig.targetPivot.x));
    Rig.targetPivot.z = Math.max(-limit, Math.min(limit, Rig.targetPivot.z));
  }
}

init();
</script>
</body>
</html>
