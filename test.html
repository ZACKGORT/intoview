<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
    <title>intoview • note — Phantom Card Archive (Interactive)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">

    <style>
:root{
  --paper:#000; --ink:#FFFFFF; --ink-2:#9F9F9F; --ink-3:#6C6C6C;
  --accent:#59D2C8; --danger:#FF6363;
  --curve-k:1;

  /* Phantom-esque global effects */
  --vig-opacity: 1;
  --vig-inner:   20%;
  --vig-mid:     52%;
  --vig-outer:   100%;

  /* Heavier edge blur (dramatic but tasteful) */
  --edge-blur:   50px;
  --edge-mask-i: 30%;
  --edge-mask-o: 99.5%;

  /* Layering */
  --z-content: 0;
  --z-grain: 149;
  --z-blur: 150;
  --z-vig: 151;
  --z-ui: 220;
  --z-cursor: 230; /* gooey cursor above UI */

  /* FAB sizing + bottom-anchored placement */
  --fab-size: 120px;
  --fab-bottom: calc(env(safe-area-inset-bottom) + clamp(16px, 3vh, 32px));

  /* Vertical zoom rail sizing/placement */
  --rail-height-desktop: 60vh;
  --rail-height-mobile:  52vh;
  --rail-right: clamp(12px, 2vw, 20px);

  /* Gooey cursor */
  --cursor-size: 28px;
}

*{box-sizing:border-box}
html,body,#root{height:100%}
body{
  margin:0; background:#000; color:var(--ink);
  font:14px/1.4 Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial;
  overflow:hidden; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
}

/* ===== Layers ===== */
.canvas-wrap{position:absolute; inset:0; z-index:var(--z-content)}
.canvas-wrap canvas{ touch-action:none; cursor:grab; background:#000 }
.canvas-wrap canvas.dragging{ cursor:grabbing }
.fallback-grid{
  position:absolute; inset:0; z-index:var(--z-content); pointer-events:none; opacity:.06;
  background-image:
    repeating-linear-gradient(to right, #fff 0 1px, transparent 1px 48px),
    repeating-linear-gradient(to bottom, #fff 0 1px, transparent 1px 48px);
}

/* Global effects above content, below UI */
.edge-blur{
  position:fixed; inset:0; pointer-events:none; z-index:var(--z-blur);
  background: rgba(0,0,0,0.001);
  backdrop-filter: blur(var(--edge-blur));
  -webkit-backdrop-filter: blur(var(--edge-blur));
  mask: radial-gradient(90% 70% at 50% 50%, transparent var(--edge-mask-i), white var(--edge-mask-o));
  -webkit-mask: radial-gradient(90% 70% at 50% 50%, transparent var(--edge-mask-i), white var(--edge-mask-o));
}
.vignette{
  position:fixed; inset:0; pointer-events:none; z-index:var(--z-vig);
  background:
    radial-gradient(120% 90% at 50% 50%,
      rgba(0,0,0,0) var(--vig-inner),
      rgba(0,0,0,0.58) var(--vig-mid),
      rgba(0,0,0,0.98) var(--vig-outer));
  opacity:calc(var(--vig-opacity) * var(--curve-k));
  mix-blend-mode: normal;
}
@supports not ((backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px))) {
  .vignette{ opacity:calc((var(--vig-opacity) + .10) * var(--curve-k)); }
}

/* Subtle grain */
body::after{
  content:""; position:fixed; inset:0; pointer-events:none; z-index:var(--z-grain); opacity:.06;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.45'/%3E%3C/svg%3E");
  background-size: 120px 120px;
}

/* Curved DOM aesthetic */
.curved{
  transform-style:preserve-3d;
  transform:
    perspective(1000px)
    translateZ(calc(-200px * var(--curve-k)))
    scale(calc(1 + var(--curve-k) * 0.06));
  will-change:transform;
}

/* Header (UI above effects) */
.header{
  position:fixed; inset:0 0 auto 0;
  z-index:var(--z-ui);
  display:flex; align-items:center; justify-content:space-between;
  gap:12px; padding:12px 14px;
  pointer-events:none;
}
.brand{
  display:flex; align-items:center; gap:10px; text-decoration:none; color:inherit; user-select:none; pointer-events:auto;
}
.brand img{ display:block; height:40px; width:auto; filter:none !important; mix-blend-mode:normal; }

.controls{ display:flex; gap:8px; align-items:center; pointer-events:auto; }
.icon-btn{
  appearance:none; cursor:pointer; border:0px solid var(--ink-2);
  background:rgba(0,0,0,.35); color:var(--ink);
  padding:8px; border-radius:10px; display:inline-flex; align-items:center; justify-content:center;
  transition:transform .12s ease, border-color .12s ease, background .12s ease, color .12s ease;
  position:relative; z-index:1;
}
.icon-btn:hover{ transform:translateY(-1px); background:rgba(255,255,255,.06); }
.icon-btn.active{ outline:0px solid color-mix(in oklab, var(--danger), white 10%); outline-offset:1px; }
.icon-btn svg{ display:block; width:18px; height:18px; }

/* ===== Vertical Zoom rail — hugs right edge ===== */
.zoom-rail{
  position:fixed;
  right: var(--rail-right);
  top: 50%;
  transform: translateY(-50%);
  height: var(--rail-height-desktop);
  width: 2px;
  z-index: var(--z-ui);
  pointer-events:auto;
  touch-action: none;
  font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
}
.zoom-rail__track{
  position:relative;
  width: 2px;
  height: 100%;
  background: rgba(255,255,255,.18);
  border-radius: 2px;
}
.zoom-rail__progress{
  position:absolute; left:0; bottom:0; width:100%;
  height: var(--zoom-pct, 0%);
  background: rgba(255,255,255,.9);
  border-radius: 2px;
}
.zoom-rail__thumb{
  position:absolute; left:50%;
  top: calc(100% - var(--zoom-pct, 0%));
  transform: translate(-50%, -50%);
  width:10px; height:10px; border-radius:50%;
  background:var(--ink);
  box-shadow:0 0 0 1px rgba(0,0,0,.85), 0 4px 18px rgba(0,0,0,.45);
}
.zoom-rail__tooltip{
  position:absolute;
  top: calc(100% - var(--zoom-pct, 0%));
  left: -44px;
  transform: translateY(-50%);
  font-weight:700; font-size:12px; color:var(--ink-2);
  text-shadow:0 1px 2px rgba(0,0,0,.55);
  user-select:none;
}

@media (max-width:768px){
  .zoom-rail{ height: var(--rail-height-mobile); }
  .zoom-rail__tooltip{ left: -40px; }
}

/* Overlays (UI above effects) */
.overlay{
  position:fixed; inset:72px 16px 16px 16px; z-index:var(--z-ui);
  display:none; pointer-events:auto;
}
.overlay.open{ display:grid; place-items:center; }
.sheet{
  width:min(860px, 100%); background:#0b0b0d; color:#f3f3f5; border:1px solid #2a2a2e; border-radius:12px; padding:16px;
  box-shadow:0 20px 60px rgba(0,0,0,.35), 0 2px 10px rgba(0,0,0,.25);
}
.row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
.grid{display:grid; gap:12px}
.cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}
.label{font-weight:600; opacity:.9}
.input,.textarea{width:100%; border:1px solid #3b3b40; background:#101015; color:#fff; border-radius:8px; padding:10px 12px; font:inherit;}
.textarea{min-height:96px; resize:vertical}
.btn{appearance:none; cursor:pointer; border:1px solid #3b3b40; background:#141419; color:#fff; padding:10px 14px; border-radius:10px; font-weight:600; position:relative; z-index:1;}
.btn.ghost{ background:transparent } .btn.primary{ border-color:var(--accent); background:var(--accent); color:#0b0b0d }
.hint{color:#c9c9cf; font-size:12px}
.vf{position:relative; aspect-ratio:4/3; width:100%; border:1px solid #2a2a2e; border-radius:10px; overflow:hidden; background:#000;}
video{display:block; width:100%; height:100%; object-fit:cover; filter:grayscale(1) contrast(1.04) brightness(.98)}
.preview{position:relative; width:100%; aspect-ratio:1/1; border:1px solid #2a2a2e; border-radius:10px; overflow:hidden; background:#000; display:block;}
.titlebar{display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px}
.titlebar h2{margin:0; font-size:16px}
.tight{gap:6px} .hidden{display:none !important} .sheet :focus{outline:2px solid color-mix(in oklab, var(--accent), white 10%); outline-offset:2px}

/* Film strip chrome */
.vf::before, .vf::after{
  content:""; position:absolute; left:0; right:0; height:22px; pointer-events:none; z-index:1;
  background:linear-gradient(#000,#000) padding-box, linear-gradient(to bottom, #ffffff26, #ffffff10) border-box;
  border-top:1px solid #2a2a2e; border-bottom:1px solid #2a2a2e;
}
.vf::before{ top:0; }
.vf::after{ bottom:0; }
.vf .perfs{
  position:absolute; inset:0; pointer-events:none; z-index:1;
  background:
    radial-gradient(circle 3px at 8px 14px, #000 0 2.2px, transparent 2.2px) repeat-y left / 16px 28px,
    radial-gradient(circle 3px at calc(100% - 8px) 14px, #000 0 2.2px, transparent 2.2px) repeat-y right / 16px 28px;
  opacity:.85;
}

/* ===== Leveler (bubble vial) ===== */
.leveler{
  position:absolute; left:50%; bottom:10px; transform:translateX(-50%);
  width:min(260px, 72%); height:30px; border-radius:999px;
  background:rgba(0,0,0,.45); border:1px solid #2a2a2e; box-shadow:inset 0 0 0 1px rgba(255,255,255,.04);
  display:flex; align-items:center; justify-content:center; z-index:2; pointer-events:auto;
}
.leveler .vial{ position:absolute; inset:4px; border-radius:999px; background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06)); }
.leveler .bubble{
  position:absolute; top:50%; transform:translate(-50%,-50%);
  left:var(--bubble-x, 50%);
  width:22px; height:22px; border-radius:999px;
  background:#ffe066; box-shadow:0 0 0 1px rgba(0,0,0,.4), 0 2px 10px rgba(0,0,0,.35);
}
.leveler .deg{
  position:absolute; right:8px; top:50%; transform:translateY(-50%);
  font:600 12px/1 Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  color:#cfcfcf; text-shadow:0 1px 1px rgba(0,0,0,.5);
}
.leveler.good .vial{ outline:2px solid rgba(120,255,120,.35); outline-offset:-2px; }
.leveler .enable{
  position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
  background:linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.35));
  backdrop-filter: blur(2px); -webkit-backdrop-filter: blur(2px);
  color:#fff; font-weight:600; font-size:12px; border-radius:inherit; cursor:pointer;
  border:1px solid #2a2a2e;
}

/* ===== FAB (button + inline label) ===== */
.fab-wrap{
  position:fixed;
  left:50%;
  bottom: var(--fab-bottom);
  transform: translateX(-50%);
  z-index:var(--z-ui);
  display:flex; flex-direction:column; align-items:center;
}
.fab{
  width:var(--fab-size); height:var(--fab-size); border-radius:999px;
  background:none; color:#fff; border:0px solid rgb(255 255 255 / .14);
  display:flex; flex-direction:column; align-items:center; justify-content:center; gap:6px;
  cursor:pointer;
  box-shadow:0 16px 36px rgba(0,0,0,.05), 0 0 0 1px rgba(255,255,255,.06) inset;
  transition:background .15s ease, color .15s ease, transform .1s ease, border-color .15s ease, box-shadow .15s ease;
  padding:0;
}
.fab:focus-visible{ outline:2px solid color-mix(in oklab, var(--accent), white 10%); outline-offset:2px; }
.fab:active{ transform:translateY(1px) }
.fab:hover{ background:rgba(255,255,255,.10); border-color:rgb(255 255 255 / .22); }
.fab svg{ width:58%; height:auto; display:block }
.fab .cube--dark{ display:none }
.fab:hover .cube--light{ display:none }
.fab:hover .cube--dark{ display:inline }

/* correct selector (label sits outside .fab) */
.fab-label{
  margin-top:6px;
  font:500 10px/1 JetBrains Mono, ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  color:#fff; opacity:.8; letter-spacing:0; user-select:none; pointer-events:none;
  text-shadow:0 1px 2px rgba(0,0,0,.55);
}

/* Mobile tweaks */
@media (max-width:768px){
  :root{
    --fab-size: 128px;
    --fab-bottom: calc(env(safe-area-inset-bottom) + clamp(14px, 3.5vh, 36px));
  }
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce){
  .edge-blur{ backdrop-filter:none; -webkit-backdrop-filter:none; }
}

/* ===== Gooey cursor (HighFlyer pen, adapted) ===== */
#cursor{
  position:fixed;
  top: calc(var(--cursor-size) * -0.5);
  left: calc(var(--cursor-size) * -0.5);
  pointer-events:none;
  filter:url(#goo);
  mix-blend-mode:difference;
  z-index:var(--z-cursor);
}
.cursor-circle{
  position:absolute;
  top:0; left:0;
  width:var(--cursor-size);
  height:var(--cursor-size);
  border-radius:999px;
  background:#fff;
  transform-origin:center center;
}
.goo{ display:none; }
@media (pointer: coarse){
  #cursor{ display:none; } /* hide on touch-only devices */
}
    </style>
  </head>
  <body>
    <!-- SVG filter for gooey blending -->
    <svg xmlns="http://www.w3.org/2000/svg" class="goo" width="0" height="0" aria-hidden="true">
      <defs>
        <filter id="goo">
          <feGaussianBlur in="SourceGraphic" stdDeviation="6" result="blur"></feGaussianBlur>
          <feColorMatrix in="blur" mode="matrix"
            values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 35 -15"
            result="goo"></feColorMatrix>
          <feComposite in="SourceGraphic" in2="goo" operator="atop"></feComposite>
        </filter>
      </defs>
    </svg>

    <!-- Gooey cursor host (filled by script) -->
    <div id="cursor" aria-hidden="true"></div>

    <div id="root"></div>

    <script type="module">
/* React + Three deps */
import React,{useEffect,useMemo,useRef,useState,Suspense} from "https://esm.sh/react@18.3.1";
import { createRoot } from "https://esm.sh/react-dom@18.3.1/client";
import * as THREE from "https://esm.sh/three@0.160.1";
import { Canvas, useFrame, useThree } from "https://esm.sh/@react-three/fiber@8.16.0?deps=react@18.3.1,react-dom@18.3.1,three@0.160.1";
import gsap from "https://esm.sh/gsap@3.12.5";
import { EffectComposer } from "https://esm.sh/three@0.160.1/examples/jsm/postprocessing/EffectComposer.js?deps=three@0.160.1";
import { RenderPass } from "https://esm.sh/three@0.160.1/examples/jsm/postprocessing/RenderPass.js?deps=three@0.160.1";
import { ShaderPass } from "https://esm.sh/three@0.160.1/examples/jsm/postprocessing/ShaderPass.js?deps=three@0.160.1";
import { OutputPass } from "https://esm.sh/three@0.160.1/examples/jsm/postprocessing/OutputPass.js?deps=three@0.160.1";

/* ========= Seed images ========= */
const SEED = [
  {src:'https://i.ibb.co/xSCsZcyn/wmzWGlaw.webp', title:'wmzWGlaw', caption:'—'},
  {src:'https://i.ibb.co/Hpt4F9Kb/IMG-8403.webp', title:'IMG-8403', caption:'—'},
  {src:'https://i.ibb.co/vC0H3LTF/DSC08656.webp', title:'DSC08656', caption:'—'},
  {src:'https://i.ibb.co/bMJNnQtg/DSC08604.webp', title:'DSC08604', caption:'—'},
  {src:'https://i.ibb.co/qLWQC0cN/DSC08358.webp', title:'DSC08358', caption:'—'},
  {src:'https://i.ibb.co/rRdNxC5g/DSC08300.webp', title:'DSC08300', caption:'—'},
  {src:'https://i.ibb.co/MD923R2f/DSC08254.webp', title:'DSC08254', caption:'—'},
  {src:'https://i.ibb.co/TBtrSYKc/DSC08233.webp', title:'DSC08233', caption:'—'},
  {src:'https://i.ibb.co/23QsQrCG/DSC05954.webp', title:'DSC05954', caption:'—'},
  {src:'https://i.ibb.co/ym1z1pyb/DSC05994.webp', title:'DSC05994', caption:'—'},
  {src:'https://i.ibb.co/bjMXB8HJ/2328964849369731672-5144774570.webp', title:'2328964849…4570', caption:'—'},
  {src:'https://i.ibb.co/fd1SDQQs/2399506735674938043-5144774570.webp', title:'2399506735…4570', caption:'—'},
  {src:'https://i.ibb.co/0pNWKFbk/2319420263505008414-5144774570.webp', title:'2319420263…4570', caption:'—'},
  {src:'https://i.ibb.co/WvW71PR3/2288089293770285108-5144774570.webp', title:'2288089293…4570', caption:'—'},
  {src:'https://i.ibb.co/1YyFqBj3/2278120764300123596-5144774570.webp', title:'2278120764…4570', caption:'—'},
  {src:'https://i.ibb.co/99B3hgp3/2274809041971350857-5144774570.webp', title:'2274809041…4570', caption:'—'},
  {src:'https://i.ibb.co/HpnrrYMR/2269419019461331921-5144774570.webp', title:'2269419019…4570', caption:'—'},
  {src:'https://i.ibb.co/6Rqf37ft/6039d4bbb15be328fc33b54d-IMG-6478.webp', title:'IMG-6478', caption:'—'},
  {src:'https://i.ibb.co/k2svMNFv/603d10120fba838e599b6b5e-IMG-1563.webp', title:'IMG-1563', caption:'—'},
  {src:'https://i.ibb.co/WNtnFQqP/603d1185cafcb2591f42b1ad-IMG-3932.webp', title:'IMG-3932', caption:'—'},
  {src:'https://i.ibb.co/pvFThr4K/603d1185b8ec32082f451ba9-IMG-3882.webp', title:'IMG-3882', caption:'—'},
  {src:'https://i.ibb.co/N2cSNMf4/603d102d9f59a611886a6893-IMG-2151.webp', title:'IMG-2151', caption:'—'},
  {src:'https://i.ibb.co/KjzkkW68/603d102d0f02c70fdf7d84eb-IMG-4696.webp', title:'IMG-4696', caption:'—'},
  {src:'https://i.ibb.co/DPyhP1T7/603d100d889053cc334ee5fc-IMG-2083.webp', title:'IMG-2083', caption:'—'},
  {src:'https://i.ibb.co/Fbr1sSb6/603d8d7a3a6df470a4a661a1-DSC00726.webp', title:'DSC00726', caption:'—'},
  {src:'https://i.ibb.co/5gddKNw3/603d0bb2331da47ee88db089-DSC02085.webp', title:'DSC02085', caption:'—'},
  {src:'https://i.ibb.co/9HZMK0nw/603d0b8b038105ae6904872a-DSC08334.webp', title:'DSC08334', caption:'—'},
  {src:'https://i.ibb.co/yFz4P7cG/603d0b8b04655c6fd42d2253-DSC08281.webp', title:'DSC08281', caption:'—'},
  {src:'https://i.ibb.co/QvHqKh2P/603afe37ba16f8f9174cf501-IMG-1878.webp', title:'IMG-1878', caption:'—'},
  {src:'https://i.ibb.co/tpK7LjSv/603a967ac64cec73069e2454-ZAX09877.webp', title:'ZAX09877', caption:'—'},
  {src:'https://i.ibb.co/0yjJ4j8L/603a967a5dc3e982f571b744-ZAX00968.webp', title:'ZAX00968', caption:'—'},
  {src:'https://i.ibb.co/zWBgb5Sj/603a95ee83ba30ff4ac9bc6a-DSC00423-1.webp', title:'DSC00423-1', caption:'—'},
  {src:'https://i.ibb.co/FLS6ZdgN/603a95ed29478f4bc91875b5-DSC08933.webp', title:'DSC08933', caption:'—'},
  {src:'https://i.ibb.co/5Xr0MDSw/603a93f06a41f45766a3361a-DSC09212.webp', title:'DSC09212', caption:'—'},
  {src:'https://i.ibb.co/wNFR8hJR/603a93f1d03490ae9d2aa64a-IMG-3824.webp', title:'IMG-3824', caption:'—'},
  {src:'https://i.ibb.co/39wDDcbS/603a93f0e815e830d1783e07-IMG-2033.webp', title:'IMG-2033', caption:'—'},
  {src:'https://i.ibb.co/PztRrNhR/603a93eddcd3ab104d64fcbb-ZAX09767.webp', title:'ZAX09767', caption:'—'},
];

/* ========= Config ========= */
const STORAGE_KEY = "intoview_archive_cards_v6";
const CONFIG = {
  cols:10, rows:7, tile:0.32, gap:0.08,
  ambient:0.20, dragEase:0.14, velEase:0.92,
  zoomOut:1.85,
  distortion:{ flat:0.0, curved:0.46 },

  clickBounceDelta: 0.25,
  longPressMsMouse: 380,
  longPressMsTouch: 520,
  clickMovePx: 6,
  clickMovePxTouch: 12,
  dragMultMouse: 6.0,
  dragMultTouch: 4.0,
  touchDragEase: 0.18,

  zoomMin: 0.45,
  zoomMax: 3.00,
  wheelScale: 0.0015
};

/* ========= Utilities ========= */
const TEX_SIZE=768, HAIR=1, BAR_H=28, PAD=12, CAP_SIZE=18, TITLE_SIZE=20;
const MONO="JetBrains Mono, ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
const UI="Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif";
const isBlobOrData = u => /^blob:|^data:/i.test(u);
function nowTS(){ const d=new Date(), y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,"0"),
  day=String(d.getDate()).padStart(2,"0"), hh=String(d.getHours()).padStart(2,"0"), mm=String(d.getMinutes()).padStart(2,"0");
  return `${y}-${m}-${day} • ${hh}:${mm}`; }
function loadImage(url){ return new Promise((res,rej)=>{ const img=new Image(); if(!isBlobOrData(url)) img.crossOrigin="anonymous";
  img.onload=()=>res(img); img.onerror=()=>rej(new Error("img load failed: "+url)); img.src=url; }); }
function drawHair(ctx,x,y,w){ ctx.fillStyle="rgba(255,255,255,0.6)"; ctx.fillRect(x,y,w,HAIR); }
function coverImage(ctx,img,x,y,w,h){
  const iw=img?.naturalWidth||img?.width||0, ih=img?.naturalHeight||img?.height||0;
  if(!iw||!ih){ ctx.fillStyle="#111"; ctx.fillRect(x,y,w,h); return; }
  const ir=iw/ih, ar=w/h; let dw,dh,dx,dy;
  if(ir>ar){ dh=h; dw=ir*h; dx=x+(w-dw)/2; dy=y; } else { dw=w; dh=w/ir; dx=x; dy=y+(h-dh)/2; }
  ctx.imageSmoothingQuality="high"; ctx.drawImage(img,dx,dy,dw,dh);
}
function drawCameraIcon(ctx,cx,cy,s=44){ ctx.save(); ctx.translate(cx,cy); ctx.strokeStyle="#fff"; ctx.lineWidth=1.5; ctx.lineCap="round"; ctx.lineJoin="round";
  const w=s*1.6,h=s*1.0; ctx.beginPath(); ctx.rect(-w/2,-h/2,w,h); ctx.stroke(); ctx.beginPath(); ctx.arc(0,0,s*0.35,0,Math.PI*2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(w*0.25,-h*0.45); ctx.lineTo(w*0.45,-h*0.45); ctx.stroke(); ctx.restore(); }
function makeCardCanvas({img,title="[ title ]",caption="[ caption ]",gps="",ts=nowTS()}) {
  const s=TEX_SIZE, c=document.createElement("canvas"); c.width=s; c.height=s; const ctx=c.getContext("2d");
  ctx.fillStyle="#000"; ctx.fillRect(0,0,s,s); ctx.strokeStyle="#fff"; ctx.lineWidth=1; ctx.strokeRect(0.5,0.5,s-1,s-1);
  ctx.fillStyle="#000"; ctx.fillRect(0,0,s,BAR_H); ctx.font=`600 ${TITLE_SIZE}px ${UI}`; ctx.fillStyle="#e6e6e6"; ctx.textBaseline="top"; ctx.textAlign="left";
  ctx.fillText(title, PAD, Math.floor((BAR_H-TITLE_SIZE)/2));
  if(gps){ ctx.font=`500 12px ${MONO}`; ctx.textBaseline="middle"; ctx.textAlign="right"; ctx.fillStyle="#cfcfcf"; ctx.fillText(gps, s-PAD, BAR_H/2); ctx.textAlign="left"; }
  drawHair(ctx,0,BAR_H,s);
  const imgTop=BAR_H+HAIR, imgH=s-imgTop-(BAR_H+HAIR);
  if(img){ coverImage(ctx,img,0,imgTop,s,imgH); ctx.fillStyle="rgba(0,0,0,0.03)"; ctx.fillRect(0, imgTop, s, imgH); }
  else{ ctx.fillStyle="#111"; ctx.fillRect(0,imgTop,s,imgH); drawCameraIcon(ctx,s/2,imgTop+imgH/2,40); }
  drawHair(ctx,0,s-BAR_H-HAIR,s);
  ctx.fillStyle="#000"; ctx.fillRect(0,s-BAR_H,s,BAR_H); ctx.font=`500 ${CAP_SIZE}px ${UI}`; ctx.fillStyle="#e6e6e6"; ctx.textBaseline="middle"; ctx.textAlign="left";
  ctx.fillText(caption, PAD, s-BAR_H/2); ctx.font=`500 12px ${MONO}`; ctx.fillStyle="#cfcfcf"; ctx.textAlign="right"; ctx.fillText(ts, s-PAD, s-BAR_H/2);
  return c;
}
function makeCardTextureFromCanvas(cnv){ const tex=new THREE.CanvasTexture(cnv); tex.colorSpace=THREE.SRGBColorSpace; tex.anisotropy=8; tex.needsUpdate=true; return tex; }
function makeEmptyTexture(){ return makeCardTextureFromCanvas(makeCardCanvas({img:null,title:"",caption:"",gps:"",ts:""})); }
async function textureForItem(item){
  if(!item||!item.src) return makeEmptyTexture();
  if(item.baked){ try{ const img=await loadImage(item.src); const tex=new THREE.Texture(img); tex.colorSpace=THREE.SRGBColorSpace; tex.anisotropy=8; tex.needsUpdate=true; return tex; } catch (e){ console.warn(e); return makeEmptyTexture(); } }
  const img=await loadImage(item.src).catch(e=>{ console.warn(e); return null; });
  return makeCardTextureFromCanvas(makeCardCanvas({img, title:item.title||"", caption:item.caption||"—", gps:item.gps||"", ts:item.ts||nowTS()}));
}
async function buildRowMajorTextures(items,totalTiles){
  const empty=makeEmptyTexture(); const texs=new Array(totalTiles).fill(empty); const count=Math.min(items.length,totalTiles);
  for(let i=0;i<count;i++){ try{ texs[i]=await textureForItem(items[i]); }catch(e){ console.warn(e); } }
  return texs;
}

/* ========= Post shader (distortion only) ========= */
class DistortionShader extends THREE.ShaderMaterial{
  constructor(){ super({
    name:"DistortionShader",
    uniforms:{ tDiffuse:{value:null}, distortion:{value:new THREE.Vector2(0,0)} },
    vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.0); }`,
    fragmentShader:`precision highp float; uniform sampler2D tDiffuse; uniform vec2 distortion; varying vec2 vUv;
    vec2 s(vec2 uv){ return 2.0*(uv-0.5);} vec2 u(vec2 suv){ return suv*0.5+0.5;}
    void main(){ vec2 suv=s(vUv); suv*=(0.88 + distortion*dot(suv,suv)); vec2 uv2=u(suv);
      vec3 col=texture2D(tDiffuse, uv2).rgb; gl_FragColor=vec4(col,1.0); }`
  }); this._dist=0; this.update(); }
  update(){ const w=innerWidth,h=innerHeight,r=Math.min(w,h)/Math.max(w,h); this.uniforms.distortion.value.set(this._dist*r,this._dist*r); }
  setDistortion(v){ gsap.to(this,{ _dist:v,duration:1,ease:"power2.out", onUpdate:()=>this.update() }); }
}

/* ========= Grid with hover bg + scroll/pinch zoom ========= */
class Grid extends THREE.Group{
  constructor(canvas,camera,opts){ super();
    this.canvas=canvas; this.camera=camera; this.opts=opts;
    this.pointerUv=new THREE.Vector2(0.5,0.5);
    this.isPointerDown=false; this.isTouch=false;
    this.velocity=new THREE.Vector2(); this.offset=new THREE.Vector2();
    this.viewW=1; this.viewH=1; this._lastPX=null; this._lastPY=null;
    this.tiles=[]; this.bgTiles=[]; this.groups=[]; this.tileItems=[]; this.ray=new THREE.Raycaster();
    this.manageMode=false; this.onTileSelect=null;
    this.onZoomChange=null; this._lastZ=this.camera.position.z;
    this.tileGeom=new THREE.PlaneGeometry(opts.tile,opts.tile,1,1);
    this.bgGeom=new THREE.PlaneGeometry(opts.tile,opts.tile,1,1);
    this.currentDragEase = opts.dragEase;
    this.hoverIdx=-1;

    /* click / long-press tracking */
    this.downTime=0; this.downX=0; this.downY=0; this.longPressTimer=null; this.longPressFired=false;

    /* pinch support */
    this.pointerMap=new Map();
    this.pinchDist0=null; this.cameraZ0=null;

    this.layout();

    this.onPointerMove=this.onPointerMove.bind(this);
    this.onPointerDown=this.onPointerDown.bind(this);
    this.onPointerUp=this.onPointerUp.bind(this);
    this.onWheel=this.onWheel.bind(this);

    canvas.addEventListener("pointermove",this.onPointerMove,{passive:true});
    canvas.addEventListener("pointerdown",this.onPointerDown,{passive:true});
    window.addEventListener("pointerup",this.onPointerUp,{passive:true});
    window.addEventListener("pointercancel",this.onPointerUp,{passive:true});
    canvas.addEventListener("wheel",this.onWheel,{passive:false});
  }
  dispose(){
    this.canvas.removeEventListener("pointermove",this.onPointerMove);
    this.canvas.removeEventListener("pointerdown",this.onPointerDown);
    window.removeEventListener("pointerup",this.onPointerUp);
    window.removeEventListener("pointercancel",this.onPointerUp);
    this.canvas.removeEventListener("wheel",this.onWheel);
    this.tileGeom.dispose(); this.bgGeom.dispose();
    this.tiles.forEach(m=>m.material&&m.material.dispose());
    this.bgTiles.forEach(m=>m.material&&m.material.dispose());
  }
  setViewport(w,h){ this.viewW=w; this.viewH=h; }
  setManageMode(f){ this.manageMode=!!f; }

  layout(){
    const {cols,rows,tile,gap}=this.opts;
    const stepX=tile+gap, stepY=tile+gap;
    const sizeX=stepX*(cols-1), sizeY=stepY*(rows-1);
    this.groups.forEach(g=>this.remove(g));
    this.tiles=[]; this.bgTiles=[]; this.groups=[]; this.tileItems=[];

    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = c*stepX - sizeX/2;
        const y = sizeY/2 - r*stepY;

        const group=new THREE.Group();
        group.position.set(x,y,0);

        // Hover background (semi-transparent, behind note)
        const bgMat=new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.0 });
        const bgMesh=new THREE.Mesh(this.bgGeom,bgMat);
        bgMesh.position.set(0,0,-0.0005);

        const imgMat=new THREE.MeshBasicMaterial({ color:0xffffff }); // map set later
        const imgMesh=new THREE.Mesh(this.tileGeom,imgMat);

        group.add(bgMesh); group.add(imgMesh);
        this.add(group);

        this.groups.push(group);
        this.bgTiles.push(bgMesh);
        this.tiles.push(imgMesh);
        this.tileItems.push(null);
      }
    }
  }

  async setItems(items){
    const total=this.tiles.length;
    const texs=await buildRowMajorTextures(items,total);
    for(let i=0;i<total;i++){
      const old=this.tiles[i].material; old?.dispose?.();
      this.tiles[i].material=new THREE.MeshBasicMaterial({ map:texs[i] });
      this.tileItems[i]= i<items.length ? items[i] : null;
    }
  }

  _pxToNorm(dx,dy){ const s=Math.min(this.viewW,this.viewH); return new THREE.Vector2(dx/s, dy/s); }
  _ndcFromClient(clientX, clientY){
    const rect=this.canvas.getBoundingClientRect();
    return { x: ((clientX-rect.left)/rect.width)*2-1, y: -((clientY-rect.top)/rect.height)*2+1 };
  }
  _hitTileAt(clientX, clientY){
    const ndc=this._ndcFromClient(clientX, clientY);
    this.ray.setFromCamera(ndc,this.camera);
    const hit=this.ray.intersectObjects(this.tiles,false)[0];
    if(!hit) return { idx:-1, mesh:null };
    const idx=this.tiles.indexOf(hit.object);
    return { idx, mesh:this.tiles[idx] };
  }
  _setHover(idx){
    if(this.hoverIdx===idx) return;
    if(this.hoverIdx>=0 && this.bgTiles[this.hoverIdx]){
      gsap.to(this.bgTiles[this.hoverIdx].material,{ opacity:0.0, duration:0.15, ease:"power2.out" });
    }
    this.hoverIdx=idx;
    if(idx>=0 && this.bgTiles[idx]){
      this.bgTiles[idx].material.color.set(0xffffff);
      gsap.to(this.bgTiles[idx].material,{ opacity:0.2, duration:0.12, ease:"power2.out" });
    }
  }
  centerTileByIndex(idx, dur=0.7){
    if(idx<0||idx>=this.tiles.length) return;
    const p=this.groups[idx].position;
    gsap.to(this.offset, { x:-p.x, y:-p.y, duration:dur, ease:"power2.out" });
  }
  zoomToFitTile(idx, margin=1.25, dur=0.7){
    if(idx<0||idx>=this.tiles.length) return;
    this.centerTileByIndex(idx, dur*0.8);
    const tileSize = this.opts.tile * margin;
    const aspect = this.viewW / this.viewH;
    const fov = this.camera.fov * Math.PI/180;
    const neededHeight = tileSize * (aspect < 1 ? (1/aspect) : 1);
    const z = Math.max(CONFIG.zoomMin, Math.min(CONFIG.zoomMax, neededHeight / (2 * Math.tan(fov/2))));
    gsap.to(this.camera.position, { z, duration:dur, ease:"power2.out" });
  }
  _clampZ(z){ return Math.max(CONFIG.zoomMin, Math.min(CONFIG.zoomMax, z)); }

  onWheel(e){
    if(this.manageMode) return;
    e.preventDefault();
    const cur = this.camera.position.z;
    const dz = e.deltaY * CONFIG.wheelScale * Math.max(0.6, cur);
    const target = this._clampZ(cur + dz);
    gsap.to(this.camera.position, { z: target, duration: 0.16, ease:"power2.out" });
  }

  _updatePointer(e){ if(e.pointerType==="touch") this.pointerMap.set(e.pointerId, { x:e.clientX, y:e.clientY }); }
  _removePointer(e){ if(e.pointerType==="touch"){ this.pointerMap.delete(e.pointerId); if(this.pointerMap.size<2){ this.pinchDist0=null; this.cameraZ0=null; } } }
  _twoTouchDistance(){ const v=[...this.pointerMap.values()]; if(v.length<2) return null; const a=v[0],b=v[1]; return Math.hypot(b.x-a.x, b.y-a.y); }

  onPointerMove(e){
    const rect=this.canvas.getBoundingClientRect(), x=(e.clientX-rect.left)/rect.width, y=(e.clientY-rect.top)/rect.height;
    this.pointerUv.set(x,y);
    const hit = this._hitTileAt(e.clientX, e.clientY);
    this._setHover(hit.idx);

    if(this.manageMode) return;

    this._updatePointer(e);
    if(this.pointerMap.size>=2){
      const d=this._twoTouchDistance();
      if(d && !this.pinchDist0){ this.pinchDist0=d; this.cameraZ0=this.camera.position.z; }
      if(d && this.pinchDist0 && this.cameraZ0!=null){
        let factor = d / this.pinchDist0;
        const target = this._clampZ(this.cameraZ0 / Math.max(0.3, Math.min(3, factor)));
        gsap.to(this.camera.position, { z: target, duration: 0.08, ease:"power2.out" });
      }
      return;
    }

    if(this.isPointerDown){
      const dx=(this._lastPX===null?0:(e.clientX-this._lastPX)), dy=(this._lastPY===null?0:(e.clientY-this._lastPY));
      this._lastPX=e.clientX; this._lastPY=e.clientY;
      const d=this._pxToNorm(dx,dy);
      const mult = this.isTouch ? CONFIG.dragMultTouch : CONFIG.dragMultMouse;
      this.offset.x += d.x * mult;
      this.offset.y += -d.y * mult;
      const lerpAmt = 1 - (this.opts.velEase);
      this.velocity.lerp(new THREE.Vector2(d.x,-d.y), lerpAmt);
    }
  }

  onPointerDown(e){
    if(this.manageMode){
      const { idx, mesh } = this._hitTileAt(e.clientX, e.clientY);
      if(mesh){ const item=this.tileItems[idx]; this.onTileSelect?.(idx,item); }
      return;
    }
    this.isPointerDown=true;
    this.isTouch = (e.pointerType === "touch");
    this.canvas.classList.add("dragging");
    this._lastPX=e.clientX; this._lastPY=e.clientY;

    this.downTime = performance.now();
    this.downX = e.clientX; this.downY = e.clientY;
    this.longPressFired = false;

    this.currentDragEase = this.isTouch ? CONFIG.touchDragEase : this.opts.dragEase;

    this._updatePointer(e);
    if(this.pointerMap.size>=2){
      this.longPressFired = true;
      if(this.longPressTimer){ window.clearTimeout(this.longPressTimer); this.longPressTimer=null; }
      return;
    }

    const holdMs = this.isTouch ? CONFIG.longPressMsTouch : CONFIG.longPressMsMouse;
    this.longPressTimer = window.setTimeout(()=>{
      const dist = Math.hypot((this._lastPX - this.downX)||0, (this._lastPY - this.downY)||0);
      const thresh = this.isTouch ? CONFIG.clickMovePxTouch : CONFIG.clickMovePx;
      if(this.isPointerDown && dist <= thresh){
        const { idx } = this._hitTileAt(this._lastPX ?? this.downX, this._lastPY ?? this.downY);
        if(idx>=0){ this.longPressFired = true; this.zoomToFitTile(idx, 1.25, 0.7); }
      }
    }, holdMs);
  }

  onPointerUp(e){
    if(this.manageMode) return;
    this._removePointer(e);

    this.isPointerDown=false; this.canvas.classList.remove("dragging");
    const upTime = performance.now();
    const dt = upTime - this.downTime;
    const dist = Math.hypot((e.clientX - this.downX)||0, (e.clientY - this.downY)||0);
    const thresh = this.isTouch ? CONFIG.clickMovePxTouch : CONFIG.clickMovePx;

    window.clearTimeout(this.longPressTimer);
    this.longPressTimer = null;

    if(!this.longPressFired && dt < (this.isTouch ? CONFIG.longPressMsTouch : CONFIG.longPressMsMouse) && dist <= thresh){
      const { idx } = this._hitTileAt(e.clientX, e.clientY);
      if(idx>=0) this.centerTileByIndex(idx, 0.6);
    }
  }

  update(){
    const cursorOffset=this.pointerUv.clone().subScalar(0.5).multiplyScalar(-this.opts.ambient);
    if(!this.isPointerDown && !this.manageMode){
      this.offset.add(this.velocity.clone().multiplyScalar(5));
      this.velocity.multiplyScalar(this.opts.velEase);
    }
    const tx=this.offset.x+cursorOffset.x, ty=this.offset.y-cursorOffset.y;
    const ease = this.currentDragEase || this.opts.dragEase;
    this.position.x += (tx-this.position.x) * ease;
    this.position.y += (ty-this.position.y) * ease;

    const z = this.camera.position.z;
    if (Math.abs(z - (this._lastZ ?? z)) > 1e-3) {
      this._lastZ = z;
      this.onZoomChange?.(z, { min: CONFIG.zoomMin, max: CONFIG.zoomMax });
    }
  }

  resetPosition(){ this.offset.set(0,0); this.velocity.set(0,0); this._setHover(-1); }
}

/* ========= Postprocessing (distortion only) ========= */
function Postprocessing({ workgridState }){
  const { gl, scene, camera, size } = useThree();
  const { composer, shader } = useMemo(()=>{
    try{
      const renderPass=new RenderPass(scene,camera);
      const shader=new DistortionShader();
      const shaderPass=new ShaderPass(shader);
      const outputPass=new OutputPass();
      const composer=new EffectComposer(gl);
      composer.addPass(renderPass); composer.addPass(shaderPass); composer.addPass(outputPass);
      return { composer, shader };
    }catch(e){ console.warn("Composer init failed",e); return { composer:null, shader:null }; }
  },[gl,scene,camera]);
  useEffect(()=>{ if(!composer||!shader) return;
    const dpr=Math.min(2, gl.getPixelRatio?.()||1.5);
    composer.setPixelRatio?.(dpr);
    composer.setSize(size.width, size.height);
    shader.update();
  },[composer,shader,size,gl]);
  useEffect(()=>{ if(!shader) return;
    const base = (workgridState==="INTRO" ? CONFIG.distortion.flat : CONFIG.distortion.curved);
    const scale = size.width < 800 ? 0.75 : 1.0;
    shader.setDistortion(base * scale);
  },[workgridState,shader,size.width]);
  useFrame(()=>{ composer?.render(); }, 1);
  return null;
}

/* ========= Primitive wrapper ========= */
function ProjectsGridPrimitive({ workgridState, items, manageMode, onTileSelect, onZoomChange, controllerRef }){
  const { gl, camera, size } = useThree();
  const grid = useMemo(()=> new Grid(gl.domElement, camera, {
    cols:CONFIG.cols, rows:CONFIG.rows, tile:CONFIG.tile, gap:CONFIG.gap,
    ambient:CONFIG.ambient, dragEase:CONFIG.dragEase, velEase:CONFIG.velEase
  }),[gl,camera]);
  useFrame(()=>grid.update());
  useEffect(()=>{ grid.setViewport(size.width,size.height); },[size,grid]);
  useEffect(()=>{ grid.onTileSelect=onTileSelect; },[grid,onTileSelect]);
  useEffect(()=>{ grid.setManageMode(manageMode); },[manageMode,grid]);
  useEffect(()=>{ grid.setItems(items); },[items,grid]);
  useEffect(()=>{ grid.onZoomChange = (z)=> onZoomChange?.(z); return ()=>{ grid.onZoomChange=null; }; },[grid,onZoomChange]);
  useEffect(()=>{ if(workgridState==="RESET") grid.resetPosition(); },[workgridState,grid]);

  // Expose setter for zoom scrubbing
  useEffect(()=>{
    if(!controllerRef) return;
    controllerRef.current = {
      setZoom: (z) => {
        const clamped = Math.max(CONFIG.zoomMin, Math.min(CONFIG.zoomMax, z));
        gsap.to(camera.position, { z: clamped, duration: 0.12, ease: "power2.out" });
      }
    };
  },[controllerRef, camera]);

  return React.createElement("primitive",{object:grid});
}
function GridView(props){
  return React.createElement(Canvas,{
      gl:{ antialias:true, powerPreference:"high-performance" },
      camera:{ fov:35, position:[0,0,CONFIG.zoomOut] },
      dpr:[1, 2],
      onCreated:({ gl })=>{
        gl.setClearColor(0x000000, 1);
        gl.outputColorSpace = THREE.SRGBColorSpace;
        gl.toneMapping = THREE.NoToneMapping;
      }
    },
    React.createElement("ambientLight",{intensity:1}),
    React.createElement("directionalLight",{intensity:.7, position:[2,3,4]}),
    React.createElement(ProjectsGridPrimitive,props),
    React.createElement(Postprocessing,{workgridState:props.workgridState})
  );
}

/* ========= Help overlay ========= */
function HelpOverlay({ open, onClose }){
  if(!open) return null;
  return (
    React.createElement("div",{className:"overlay open curved"},
      React.createElement("div",{className:"sheet",role:"dialog","aria-modal":"true"},
        React.createElement("div",{className:"titlebar"},
          React.createElement("h2",null,"Controls"),
          React.createElement("button",{className:"btn ghost",onClick:onClose},"Close")
        ),
        React.createElement("div",{className:"grid"},
          React.createElement("div",null,"• Drag to pan"),
          React.createElement("div",null,"• Wheel / pinch to zoom"),
          React.createElement("div",null,"• Click a tile to center it"),
          React.createElement("div",null,"• Long-press a tile to fit view"),
          React.createElement("div",null,"• Toggle: square↔circle for distortion"),
          React.createElement("div",null,"• Trash: tap any tile to delete (while active)"),
          React.createElement("div",null,"• FAB block: new note"),
          React.createElement("div",null,"• Leveler: tap “Enable leveler” on the Viewfinder step"),
          React.createElement("div",null,"• Shortcuts: 1/2 = Flat/Curved, 0 = Reset, N = New, M = Manage, ? = Help")
        )
      )
    )
  );
}

/* ========= Camera + export ========= */
function useCamera(){
  const videoRef=useRef(null), streamRef=useRef(null), [error,setError]=useState("");
  const isHttps = () => location.protocol==="https:" || location.hostname==="localhost";
  const isIframe = () => window.top !== window.self;
  const stop=()=>{ streamRef.current?.getTracks?.().forEach(t=>t.stop()); streamRef.current=null; if(videoRef.current) videoRef.current.srcObject=null; };

  const start=async()=>{
    setError("");
    if(!isHttps()){ setError("Camera requires HTTPS (or localhost). Use Import instead."); return false; }
    const v = videoRef.current;
    if(!v){ setError("Video element missing."); return false; }

    try{
      // iOS/Safari quirks
      v.setAttribute("playsinline",""); v.setAttribute("autoplay",""); v.setAttribute("muted","");
      v.playsInline = true; v.muted = true;

      const constraints = {
        video: {
          facingMode: { ideal:"environment" },
          width:  { ideal:1920 },
          height: { ideal:1080 }
        },
        audio: false
      };
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      streamRef.current = stream;
      v.srcObject = stream;

      // Wait for metadata then play (Safari)
      await new Promise(res=>{
        const onReady = () => { v.removeEventListener("loadedmetadata", onReady); res(); };
        v.addEventListener("loadedmetadata", onReady);
      });
      await v.play().catch(()=>{ /* Safari may auto-play anyway */ });

      return true;
    }catch(e){
      console.warn("Camera error:", e);
      let msg = "Camera unavailable.";
      if(isIframe()){
        msg += " Tip: your preview may be sandboxed. Click “Open in new tab” below.";
      }
      if(e?.name==="NotAllowedError"){ msg = "Camera permission denied. Check browser permissions."; }
      if(e?.name==="NotFoundError"){ msg = "No suitable camera found."; }
      if(e?.name==="OverconstrainedError"){ msg = "Camera constraints not supported on this device."; }
      setError(msg);
      stop();
      return false;
    }
  };

  return { videoRef, start, stop, error };
}

async function exportCardPNGFromCanvas(sourceCanvas,title,caption,gps=""){
  const img = await new Promise((res,rej)=>{ const im=new Image(); im.onload=()=>res(im); im.onerror=rej; im.src=sourceCanvas.toDataURL("image/png"); });
  const cnv = makeCardCanvas({ img, title, caption, gps, ts:nowTS() });
  return new Promise(resolve=>{ cnv.toBlob(b=>{ const url=URL.createObjectURL(b); resolve({url,blob:b}); },"image/png",0.96); });
}

/* ========= Leveler ========= */
function Leveler(){
  const [enabled,setEnabled]=useState(false);
  const [deg,setDeg]=useState(0);

  useEffect(()=>{
    if(!enabled) return;
    const onOrient = (e)=>{
      const g = (typeof e.gamma === "number") ? e.gamma : 0;
      const clamped = Math.max(-45, Math.min(45, g));
      setDeg(clamped);
    };
    window.addEventListener("deviceorientation", onOrient, true);
    return ()=>window.removeEventListener("deviceorientation", onOrient, true);
  },[enabled]);

  const good = Math.abs(deg) <= 2;
  const xPct = ((deg + 45) / 90) * 100;
  const needPermission = typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function";

  const askPermission = async ()=>{
    try{
      if(needPermission){
        const st = await DeviceOrientationEvent.requestPermission();
        if(st === "granted") setEnabled(true);
      }else{
        setEnabled(true);
      }
    }catch{ /* ignore */ }
  };

  return (
    React.createElement("div",{ className:`leveler ${good?"good":""}` },
      React.createElement("div",{ className:"vial" }),
      React.createElement("div",{ className:"bubble", style:{ "--bubble-x": `${xPct}%` } }),
      React.createElement("div",{ className:"deg" }, `${deg.toFixed(1)}°`),
      !enabled && React.createElement("button",{ className:"enable", onClick:askPermission },
        "Enable leveler")
    )
  );
}

/* ========= Overlay flow (note capture) ========= */
function OverlayFlow({ open, onClose, onAddToArchive }){
  const [step,setStep]=useState(0), [title,setTitle]=useState(""), [caption,setCaption]=useState("A quick visual note");
  const [reviewCanvas,setReviewCanvas]=useState(null), [exportUrl,setExportUrl]=useState(""), [exporting,setExporting]=useState(false);
  const camera=useCamera(); const filePickRef=useRef(null); const sheetRef=useRef(null); const reviewMountRef=useRef(null);

  useEffect(()=>{ const mount=reviewMountRef.current; if(!mount) return; while(mount.firstChild) mount.removeChild(mount.firstChild);
    if(reviewCanvas && step===2){ reviewCanvas.style.width="100%"; reviewCanvas.style.height="100%"; mount.appendChild(reviewCanvas); } },[reviewCanvas,step]);

  useEffect(()=>{ if(!open) return; const root=sheetRef.current; if(!root) return;
    const focusables=()=>[...root.querySelectorAll("button,[href],input,textarea")].filter(el=>!el.disabled&&el.offsetParent!==null);
    const onKey=e=>{ if(e.key==="Escape"){ e.preventDefault(); onClose?.(); }
      if(e.key==="Tab"){ const fs=focusables(); if(!fs.length) return; const f=document.activeElement;
        if(e.shiftKey && f===fs[0]){ e.preventDefault(); fs[fs.length-1].focus(); }
        else if(!e.shiftKey && f===fs[fs.length-1]){ e.preventDefault(); fs[0].focus(); } } };
    root.addEventListener("keydown",onKey); return ()=>root.removeEventListener("keydown",onKey);
  },[open,onClose]);

  useEffect(()=>{ if(!open){ camera.stop(); setStep(0); setTitle(""); setCaption("A quick visual note"); setReviewCanvas(null); setExportUrl(""); setExporting(false);} },[open]);

  const startCamera=async()=>{ const ok=await camera.start(); setStep(ok?1:0); };
  const captureShot=()=>{ const v=camera.videoRef.current; if(!v||!v.videoWidth){ return; }
    const vw=v.videoWidth,vh=v.videoHeight,s=Math.min(vw,vh),sx=Math.floor((vw-s)/2),sy=Math.floor((vh-s)/2);
    const c=document.createElement("canvas"); c.width=s; c.height=s; const ctx=c.getContext("2d"); ctx.drawImage(v,sx,sy,s,s,0,0,s,s);
    setReviewCanvas(c); setStep(2);
  };
  const pickFile=()=>filePickRef.current?.click();
  const onFileChange=e=>{
    const f=e.target.files?.[0]; if(!f) return; const img=new Image(); const url=URL.createObjectURL(f);
    img.onload=()=>{ const s=Math.min(img.width,img.height), sx=Math.floor((img.width-s)/2), sy=Math.floor((img.height-s)/2);
      const c=document.createElement("canvas"); c.width=s; c.height=s; c.getContext("2d").drawImage(img,sx,sy,s,s,0,0,s,s);
      URL.revokeObjectURL(url); setReviewCanvas(c); setStep(2); }; img.src=url;
  };
  const doExport=async()=>{ if(!reviewCanvas) return; setExporting(true);
    const { url } = await exportCardPNGFromCanvas(reviewCanvas, title||"[ title ]", caption||"—");
    setExportUrl(url); setExporting(false); setStep(5);
    onAddToArchive?.({ id:"note_"+Date.now(), src:url, title:title||"[ title ]", caption:caption||"—", baked:true, ts:nowTS(), createdMs:Date.now() });
  };

  const openNewTab = ()=>{ const u = new URL(location.href); u.hash="#camera"; window.open(u.toString(), "_blank", "noopener,noreferrer"); };

  if(!open) return null;
  return (
    React.createElement("div",{className:"overlay open curved"},
      React.createElement("div",{className:"sheet",ref:sheetRef,role:"dialog","aria-modal":"true"},
        React.createElement("div",{className:"titlebar"},
          React.createElement("h2",null, ["Start","Viewfinder","Review","Details","Export","Done"][step] || "Start"),
          React.createElement("button",{className:"btn ghost",onClick:onClose},"Close")
        ),
        step===0 && React.createElement("div",{className:"grid"},
          camera.error ? React.createElement("div",{className:"hint", style:{color:"#ffb4b4"}}, camera.error) : null,
          React.createElement("div",{className:"grid cols-2"},
            React.createElement("button",{className:"btn primary",onClick:startCamera},"Open Camera"),
            React.createElement("button",{className:"btn",onClick:pickFile},"Import Photo")),
          React.createElement("div",{className:"row tight"},
            React.createElement("button",{className:"btn ghost",onClick:openNewTab},"Open in new tab (camera fix)"),
            React.createElement("span",{className:"hint"},"Useful if your preview iframe blocks camera.")
          ),
          React.createElement("input",{ref:filePickRef,type:"file",accept:"image/*",className:"hidden",onChange:onFileChange})
        ),
        step===1 && React.createElement(React.Fragment,null,
          React.createElement("div",{className:"vf"},
            React.createElement("video",{ref:camera.videoRef,playsInline:true,autoPlay:true,muted:true}),
            React.createElement("span",{className:"perfs","aria-hidden":"true"}),
            React.createElement(Leveler,null)
          ),
          React.createElement("div",{className:"row",style:{marginTop:"12px"}},
            React.createElement("button",{className:"btn",onClick:()=>{camera.stop(); setStep(0);}},"Back"),
            React.createElement("button",{className:"btn primary",onClick:captureShot,style:{marginLeft:"auto"}},"Capture"))
        ),
        step===2 && React.createElement(React.Fragment,null,
          React.createElement("div",{className:"preview",ref:reviewMountRef}),
          React.createElement("div",{className:"row",style:{marginTop:"12px"}},
            React.createElement("button",{className:"btn",onClick:()=>{camera.stop(); setStep(1);}},"Retake"),
            React.createElement("button",{className:"btn primary",onClick:()=>setStep(3),style:{marginLeft:"auto"}},"Keep"))
        ),
        step===3 && React.createElement(React.Fragment,null,
          React.createElement("label",{className:"label",htmlFor:"t"},"Title (40 cap)"),
          React.createElement("input",{id:"t",maxLength:40,className:"input",value:title,onChange:e=>setTitle(e.target.value)}),
          React.createElement("label",{className:"label",htmlFor:"c"},"Note (100 cap)"),
          React.createElement("textarea",{id:"c",maxLength:100,className:"textarea",value:caption,onChange:e=>setCaption(e.target.value)}),
          React.createElement("div",{className:"row",style:{marginTop:"6px"}},
            React.createElement("button",{className:"btn",onClick:()=>setStep(2)},"Back"),
            React.createElement("button",{className:"btn primary",onClick:()=>setStep(4),style:{marginLeft:"auto"}}, "Next")))
        ,
        step===4 && React.createElement("div",{className:"grid"},
          React.createElement("div",{className:"hint"},"Export generates a 1:1 card PNG and adds it to the archive."),
          React.createElement("div",{className:"row"},
            React.createElement("button",{className:"btn",onClick:()=>setStep(3)},"Back"),
            React.createElement("button",{className:"btn primary",disabled:exporting,onClick:doExport,style:{marginLeft:"auto"}},exporting?"Exporting…":"Export PNG & Save"))),
        step===5 && React.createElement("div",{className:"grid",style:{placeItems:"center",textAlign:"center"}},
          React.createElement("div",{className:"row",style:{justifyContent:"center"}},
            exportUrl ? React.createElement("a",{href:exportUrl,download:`intoview-note_${Date.now()}.png`,className:"btn"},"Download again") : null),
          React.createElement("div",{className:"row",style:{justifyContent:"center"}},
            React.createElement("button",{className:"btn",onClick:()=>{ setStep(0); setTitle(""); setCaption("A quick visual note"); setReviewCanvas(null); }},"intoview:note"),
            React.createElement("button",{className:"btn primary",onClick:onClose},"Close")))
      )
    )
  );
}

/* ========= Vertical Zoom Rail ========= */
function ZoomRail({ zoom, onScrub }) {
  const pctLabel = Math.round(zoom * 100);
  const clamped = Math.max(0, Math.min(1, (zoom - CONFIG.zoomMin) / (CONFIG.zoomMax - CONFIG.zoomMin)));
  const pct = clamped * 100;

  const trackRef = React.useRef(null);
  const toZoomFromClientY = (clientY) => {
    const el = trackRef.current; if(!el) return null;
    const r = el.getBoundingClientRect();
    const y = Math.max(0, Math.min(1, (clientY - r.top) / r.height)); // 0 at top, 1 at bottom
    const frac = 1 - y; // top = 1 (max), bottom = 0 (min)
    return CONFIG.zoomMin + frac * (CONFIG.zoomMax - CONFIG.zoomMin);
  };
  const onPointerDown = (e) => {
    if (!onScrub) return;
    const z = toZoomFromClientY(e.clientY); if (z!=null) onScrub(z);
    const move = (ev)=>{ const zz = toZoomFromClientY(ev.clientY); if(zz!=null) onScrub(zz); };
    const up = ()=>{ window.removeEventListener("pointermove",move); window.removeEventListener("pointerup",up); };
    window.addEventListener("pointermove",move,{passive:true});
    window.addEventListener("pointerup",up,{once:true});
  };

  return React.createElement("div", { className:"zoom-rail", "aria-label":"Zoom" },
    React.createElement("div", { className:"zoom-rail__track", ref:trackRef, onPointerDown, role:"slider",
      "aria-orientation":"vertical",
      "aria-valuemin":Math.round(CONFIG.zoomMin*100), "aria-valuemax":Math.round(CONFIG.zoomMax*100),
      "aria-valuenow":Math.round(zoom*100) },
      React.createElement("div", { className:"zoom-rail__progress", style:{ "--zoom-pct": `${pct}%` } }),
      React.createElement("div", { className:"zoom-rail__thumb", style:{ "--zoom-pct": `${pct}%` } }),
      React.createElement("div", { className:"zoom-rail__tooltip", style:{ "--zoom-pct": `${pct}%` } }, `${pctLabel}%`)
    )
  );
}

/* ========= Icons ========= */
function MorphDistortionIcon({ isCurved, onToggle }){
  const rectRef = useRef(null);
  useEffect(()=>{
    const target = isCurved ? 9 : 2;
    gsap.to(rectRef.current, { attr:{ rx: target, ry: target }, duration:0.25, ease:"power2.out" });
  },[isCurved]);

  return (
    React.createElement("button", { className:"icon-btn", title:isCurved?"Curved (click to go Flat)":"Flat (click to go Curved)", onClick:onToggle, "aria-label":"Toggle distortion" },
      React.createElement("svg",{viewBox:"0 0 24 24", role:"img","aria-hidden":"true"},
        React.createElement("rect",{ x:"4", y:"4", width:"16", height:"16", rx:isCurved?9:2, ry:isCurved?9:2,
          fill:"none", stroke:"currentColor", "stroke-width":"2", ref:rectRef })
      )
    )
  );
}
function ResetIcon({ onClick }){
  return (
    React.createElement("button",{ className:"icon-btn", onClick, title:"Reset view", "aria-label":"Reset view" },
      React.createElement("svg",{viewBox:"0 0 24 24", role:"img","aria-hidden":"true"},
        React.createElement("rect",{ x:"4", y:"4", width:"16", height:"16", fill:"none", stroke:"currentColor", "stroke-width":"2" }),
        React.createElement("circle",{ cx:"12", cy:"12", r:"5.5", fill:"none", stroke:"currentColor", "stroke-width":"2" })
      )
    )
  );
}
function TrashToggle({ active, onToggle }){
  return (
    React.createElement("button",{ className:`icon-btn ${active?"active":""}`, onClick:onToggle,
      title: active?"Delete mode (tap a tile) — Click to exit":"Delete notes (enter delete mode)", "aria-pressed":active, "aria-label":"Toggle delete mode" },
      React.createElement("svg",{viewBox:"0 0 24 24", role:"img","aria-hidden":"true"},
        React.createElement("path",{ d:"M3 6h18M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2M8 6h8m-8 0l1 14a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2L16 6M10 10v8M14 10v8",
          fill:"none", stroke:"currentColor", "stroke-width":"2", "stroke-linecap":"round", "stroke-linejoin":"round"})
      )
    )
  );
}

/* ========= App ========= */
function App(){
  const WorkgridState = { INTRO:"INTRO", DEFAULT:"DEFAULT", RESET:"RESET" };
  const [wgState,setWgState]=useState(WorkgridState.DEFAULT);
  const [overlayOpen,setOverlayOpen]=useState(false);
  const [manageMode,setManageMode]=useState(false);
  const [helpOpen,setHelpOpen]=useState(false);
  const [archive,setArchive]=useState(loadArchive());
  const [zoom, setZoom] = useState(CONFIG.zoomOut);
  const gridCtrl = useRef({ setZoom: (z)=>{} });
  useEffect(()=>{ saveArchive(archive); },[archive]);

  const sortedArchive=useMemo(()=>[...archive].map((it,i)=>({...it,createdMs:getCreatedMs(it,i)})).sort((a,b)=>b.createdMs-a.createdMs),[archive]);
  const combinedItems=useMemo(()=>[...sortedArchive, ...SEED], [sortedArchive]);

  useEffect(()=>{ document.documentElement.style.setProperty("--curve-k", String(wgState===WorkgridState.INTRO ? 0 : 1)); },[wgState]);

  useEffect(()=>{ const onKey=e=>{ if(overlayOpen||helpOpen) return;
      if(e.key==="1") setWgState(WorkgridState.INTRO);
      if(e.key==="2") setWgState(WorkgridState.DEFAULT);
      if(e.key==="0") setWgState(WorkgridState.RESET);
      if(e.key==="n"||e.key==="N") setOverlayOpen(true);
      if(e.key==="m"||e.key==="M") setManageMode(v=>!v);
      if(e.key==="?"||e.key==="h"||e.key==="H") setHelpOpen(true);
    }; window.addEventListener("keydown",onKey); return ()=>window.removeEventListener("keydown",onKey); },[overlayOpen,helpOpen]);

  // Auto-open overlay if #camera in URL
  useEffect(()=>{ if(location.hash==="#camera"){ setOverlayOpen(true); } },[]);

  const addNoteToArchive=note=> setArchive(arr=>[...arr, note]);
  const handleTileSelect=(tileIndex,item)=>{
    if(!manageMode||!item) return;
    if(item.id && String(item.id).startsWith("note_")){
      if(!confirm("Delete this note from the archive?")) return;
      setArchive(arr=>arr.filter(x=>x.id!==item.id));
    }
  };

  const isCurved = wgState === WorkgridState.DEFAULT;

  /* ===== Cursor XY for FAB label ===== */
  const [cursorXY, setCursorXY] = useState({ x: 0, y: 0 });
  useEffect(()=>{
    const onMove = (e)=> setCursorXY({ x: Math.round(e.clientX), y: Math.round(e.clientY) });
    window.addEventListener("pointermove", onMove, { passive:true });
    return ()=> window.removeEventListener("pointermove", onMove);
  },[]);

  return (
    React.createElement(React.Fragment,null,
      /* WebGL layer */
      React.createElement("div",{className:"canvas-wrap"},
        React.createElement("div",{className:"fallback-grid"}),
        React.createElement(Suspense,{fallback:null},
          React.createElement(GridView,{
            workgridState:wgState,
            items:combinedItems,
            manageMode,
            onTileSelect:handleTileSelect,
            onZoomChange:setZoom,
            controllerRef:gridCtrl
          })
        )
      ),

      /* Header */
      React.createElement("header",{className:"header"},
        React.createElement("a",{className:"brand", href:"#", "aria-label":"intoview home"},
          React.createElement("img",{
            id:"brandLogo",
            alt:"intoview",
            decoding:"async",
            src:"https://raw.githubusercontent.com/ZACKGORT/intoview/978224baf6a6bce81827044f742761d1bc39893e/intoview-horizontal-lockup-small.svg"
          })
        ),
        React.createElement("div",{className:"controls"},
          React.createElement(MorphDistortionIcon,{ isCurved, onToggle:()=>setWgState(isCurved?WorkgridState.INTRO:WorkgridState.DEFAULT) }),
          React.createElement(ResetIcon,{ onClick:()=>setWgState(WorkgridState.RESET) }),
          React.createElement(TrashToggle,{ active:manageMode, onToggle:()=>setManageMode(v=>!v) }),
          React.createElement("button",{className:"icon-btn","aria-label":"Info / Controls", onClick:()=>setHelpOpen(true), title:"Help / Controls"},
            React.createElement("svg",{viewBox:"0 0 24 24", role:"img","aria-hidden":"true"},
              React.createElement("circle",{cx:"12",cy:"12",r:"10", fill:"none", stroke:"currentColor","stroke-width":"2"}),
              React.createElement("line",{x1:"12",y1:"16",x2:"12",y2:"12", stroke:"currentColor","stroke-width":"2","stroke-linecap":"round"}),
              React.createElement("circle",{cx:"12", cy:"8", r:"1.2", fill:"currentColor"})
            )
          )
        )
      ),

      /* Modals */
      React.createElement(HelpOverlay,{ open:helpOpen, onClose:()=>setHelpOpen(false) }),
      React.createElement(OverlayFlow,{ open:overlayOpen, onClose:()=>setOverlayOpen(false), onAddToArchive:addNoteToArchive }),

      /* Global effects */
      React.createElement("div",{className:"edge-blur"}),
      React.createElement("div",{className:"vignette"}),

      /* Vertical zoom rail */
      React.createElement(ZoomRail,{ zoom, onScrub:(z)=> gridCtrl.current?.setZoom?.(z) }),

      /* FAB block (centered lower-third) */
      React.createElement("div",{ className:"fab-wrap" },
        React.createElement("button",{ className:"fab", onClick:()=>setOverlayOpen(true), title:"New note", "aria-label":"intoview:note" },
          React.createElement("svg",{viewBox:"0 0 100 100","aria-hidden":"true"},
            React.createElement("defs",null,
              React.createElement("linearGradient",{id:"cubeTop",x1:"0",x2:"1",y1:"0",y2:"1"},
                React.createElement("stop",{offset:"0","stop-color":"#fff","stop-opacity":"1"}),
                React.createElement("stop",{offset:"1","stop-color":"#dcdcdc","stop-opacity":"1"})
              ),
              React.createElement("linearGradient",{id:"cubeSide",x1:"0",x2:"1",y1:"0",y2:"1"},
                React.createElement("stop",{offset:"0","stop-color":"#e8e8e8"}),
                React.createElement("stop",{offset:"1","stop-color":"#bdbdbd"})
              ),
              React.createElement("linearGradient",{id:"cubeDark",x1:"0",x2:"1",y1:"0",y2:"1"},
                React.createElement("stop",{offset:"0","stop-color":"#8a8a8a"}),
                React.createElement("stop",{offset:"1","stop-color":"#4b4b4b"})
              ),
              React.createElement("filter",{id:"cubeGlow",x:"-50%",y:"-50%",width:"200%",height:"200%"},
                React.createElement("feDropShadow",{dx:"0",dy:"6","stdDeviation":"6","flood-color":"#000","flood-opacity":".45"})
              )
            ),
            React.createElement("g",{filter:"url(#cubeGlow)"},
              React.createElement("polygon",{fill:"url(#cubeTop)", points:"50,14 80,30 50,46 20,30"}),
              React.createElement("polygon",{fill:"url(#cubeSide)", points:"80,30 80,66 50,82 50,46"}),
              React.createElement("polygon",{fill:"url(#cubeDark)", points:"50,46 50,82 20,66 20,30"})
            )
          )
        ),
        React.createElement("div",{ className:"fab-label" }, `x ${cursorXY.x} • y ${cursorXY.y}`)
      )
    )
  );
}

/* ========= Persistence ========= */
function getCreatedMs(item, idx=0){
  if (typeof item?.createdMs==="number") return item.createdMs;
  if (item?.id){ const m=String(item.id).match(/^note_(\d+)$/); if(m){ const n=+m[1]; if(!Number.isNaN(n)) return n; } }
  if (item?.ts && /^\d{4}-\d{2}-\d{2} • \d{2}:\d{2}$/.test(item.ts)){
    const t=Date.parse(item.ts.replace(" • ","T")+":00"); if(!Number.isNaN(t)) return t;
  }
  return idx;
}
function loadArchive(){
  try{
    const raw=localStorage.getItem(STORAGE_KEY);
    if(!raw) return [];
    const parsed=JSON.parse(raw);
    if(!Array.isArray(parsed)) return [];
    return parsed.map((it,i)=>({ ...it, createdMs:getCreatedMs(it,i) }));
  }catch{ return []; }
}
function saveArchive(arr){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(arr)); }catch{} }

/* ========= Mount ========= */
const root = createRoot(document.getElementById("root"));
root.render(React.createElement(App));

/* ========= Gooey cursor init (HighFlyer pen, adapted) ========= */
(function initGooeyCursor(){
  const TAIL_LENGTH = 20;
  const host = document.getElementById('cursor');
  if(!host) return;

  // build tail
  for(let i=0;i<TAIL_LENGTH;i++){
    const d=document.createElement('div');
    d.className='cursor-circle';
    host.appendChild(d);
  }
  const circles = Array.from(host.querySelectorAll('.cursor-circle'));

  let mouseX = innerWidth/2, mouseY = innerHeight/2;
  let history = Array(TAIL_LENGTH).fill(0).map(()=>({ x: mouseX, y: mouseY }));

  const onMove = (e)=>{ mouseX = e.clientX; mouseY = e.clientY; };
  window.addEventListener('pointermove', onMove, { passive:true });

  function tick(){
    history.shift();
    history.push({ x: mouseX, y: mouseY });
    for(let i=0;i<TAIL_LENGTH;i++){
      const cur = history[i];
      const next = history[i+1] || history[TAIL_LENGTH-1];
      cur.x += (next.x - cur.x) * 0.35;
      cur.y += (next.y - cur.y) * 0.35;
      const s = Math.max(0.22, i/TAIL_LENGTH); // keep smallest dot visible
      circles[i].style.transform = `translate(${cur.x}px, ${cur.y}px) scale(${s})`;
    }
    requestAnimationFrame(tick);
  }
  tick();
})();
    </script>
  </body>
</html>
