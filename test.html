<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>PUNT: Neon Interactive</title>
    <style>
        :root{--bg:#0f1014;--accent:#39FF14;--pink:#FF1493;--neon-blue:#00ffff;}
        *{margin:0;padding:0;box-sizing:border-box;user-select:none;-webkit-user-select:none;}
        body{background:var(--bg);overflow:hidden;color:#fff;font-family:'Courier New', Courier, monospace;cursor:none;overscroll-behavior:none;}
        #canvas{display:block;width:100vw;height:100vh;outline:none;}
        
        /* --- UI Overlay --- */
        .hud{position:fixed;bottom:1rem;left:20px;font-size:10px;opacity:0.6;z-index:90;pointer-events:none;font-family:sans-serif;}
        .mode-status{position:fixed;top:20px;left:50%;transform:translateX(-50%);background:rgba(255,255,255,0.05);padding:8px 16px;border-radius:20px;border:1px solid rgba(255,255,255,0.1);opacity:0;transition:0.3s;z-index:100;pointer-events:none;}
        .mode-status.active{opacity:1;color:var(--pink);border-color:var(--pink);box-shadow: 0 0 15px var(--pink);}
        
        /* Left Rail Quadrant Toggle */
        .quad-left{position:fixed;top:50%;left:20px;transform:translateY(-50%);display:flex;flex-direction:column;gap:8px;background:rgba(255,255,255,0.05);padding:4px;border-radius:30px;z-index:100;}
        .quad-icon{width:30px;height:30px;position:relative;perspective:300px;cursor:pointer;}
        .quad-cube{width:100%;height:100%;transform-style:preserve-3d;transform:rotateX(-25deg) rotateY(-45deg);animation:spin 4s linear infinite;}
        @keyframes spin{to{transform:rotateX(-25deg) rotateY(315deg);}}
        .q-face{position:absolute;width:20px;height:20px;left:5px;top:5px;backface-visibility:visible;}
        .q-face:nth-child(1){transform:rotateY(0deg) translateZ(10px);}
        .q-face:nth-child(2){transform:rotateY(90deg) translateZ(10px);}
        .q-face:nth-child(3){transform:rotateY(180deg) translateZ(10px);}
        .q-face:nth-child(4){transform:rotateY(-90deg) translateZ(10px);}
        .q-face:nth-child(5){transform:rotateX(90deg) translateZ(10px);}
        .q-face:nth-child(6){transform:rotateX(-90deg) translateZ(10px);}
        .quad-icon.todo .q-face{background:rgba(255,255,0,0.2);border:1px solid #ffff00;box-shadow:0 0 5px #ffff00;}
        .quad-icon.inprogress .q-face{background:rgba(0,255,255,0.2);border:1px solid #00ffff;box-shadow:0 0 5px #00ffff;}
        .quad-icon.completed .q-face{background:rgba(0,255,0,0.2);border:1px solid #00ff00;box-shadow:0 0 5px #00ff00;}
        .quad-icon.backlog .q-face{background:rgba(255,0,0,0.2);border:1px solid #ff0000;box-shadow:0 0 5px #ff0000;}

        /* Right Rail View Toggles */
        .presets{position:fixed;top:50%;right:20px;transform:translateY(-50%);display:flex;flex-direction:column;gap:8px;z-index:100;}

        .btn{background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);color:#fff;padding:8px 12px;border-radius:6px;cursor:pointer;font-size:10px;font-family:inherit;transition:0.2s;text-transform:uppercase;letter-spacing:1px;}
        .btn:hover{background:rgba(255,255,255,0.1);border-color:var(--accent);}
        .btn.active{border-color:var(--pink);color:var(--pink);box-shadow:0 0 10px rgba(255,20,147,0.3);}

        /* Trash */
        .trash{position:fixed;bottom:20px;left:20px;z-index:100;font-size:20px;padding:8px;border-radius:50%;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);cursor:pointer;transition:0.2s;}
        .trash.active{background:rgba(255,0,0,0.2);border-color:#ff0000;animation:pulse 1s infinite;box-shadow:0 0 10px #ff0000;}
        @keyframes pulse{50%{transform:scale(1.1);}}

        /* Countdown */
        .countdown{position:fixed;top:60px;left:50%;transform:translateX(-50%);background:rgba(255,0,0,0.2);padding:8px 16px;border-radius:20px;color:#fff;z-index:100;opacity:0;transition:0.3s;pointer-events:none;}
        .countdown.active{opacity:1;}

        /* Input Bars */
        .top-bar{position:fixed;top:60px;left:50%;transform:translateX(-50%);z-index:100;}
        .top-bar input{background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.2);color:#fff;padding:8px 12px;border-radius:6px;width:200px;text-align:center;font-size:12px;cursor:text;}
        
        /* Coordinates */
        .coords {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            color: var(--accent);
            background: rgba(0,0,0,0.6);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(57, 255, 20, 0.3);
            z-index: 90;
            pointer-events: none;
        }

        /* --- FAB / Joystick --- */
        .fab-zone {
            position: fixed;
            bottom: 9.9rem;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 80px;
            z-index: 200;
            cursor: grab;
            perspective: 600px;
        }
        .fab-zone:active { cursor: grabbing; }

        .fab-cube {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transform: rotateX(-25deg) rotateY(-45deg);
            pointer-events: none;
            transition: transform 0.1s;
        }
        .f-face {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 20, 147, 0.15);
            border: 2px solid var(--pink);
            box-shadow: 0 0 15px var(--pink), inset 0 0 10px var(--pink);
            left: 20px;
            top: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #fff;
            backface-visibility: visible;
        }
        .f-face:nth-child(1) { transform: rotateY(0deg) translateZ(20px); }
        .f-face:nth-child(2) { transform: rotateY(90deg) translateZ(20px); }
        .f-face:nth-child(3) { transform: rotateY(180deg) translateZ(20px); }
        .f-face:nth-child(4) { transform: rotateY(-90deg) translateZ(20px); }
        .f-face:nth-child(5) { transform: rotateX(90deg) translateZ(20px); background: rgba(255, 20, 147, 0.3); }
        .f-face:nth-child(6) { transform: rotateX(-90deg) translateZ(20px); }

        .fab-hint {
            position: absolute;
            bottom: -16px;
            width: 100%;
            text-align: center;
            font-size: 9px;
            color: rgba(255,255,255,0.5);
            pointer-events: none;
        }

        body.fab-active .btn, body.fab-active input { pointer-events: none; opacity: 0.5; }

        /* Info */
        .info{position:fixed;top:80px;right:20px;background:rgba(20,20,30,0.9);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.2);border-radius:8px;padding:16px;min-width:250px;opacity:0;transition:0.3s;z-index:90;pointer-events:none;}
        .info.active{opacity:1;}
        .info-row{font-size:11px;margin:4px 0;display:flex;justify-content:space-between}
        
        /* Context Menu */
        .ctx{position:fixed;background:rgba(20,20,30,0.95);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.2);border-radius:8px;padding:8px 0;min-width:180px;display:none;z-index:1000}
        .ctx.active{display:block}
        .ctx-item{padding:8px 16px;cursor:pointer;font-size:12px;transition:0.2s}
        .ctx-item:hover{background:rgba(255,255,255,0.1)}
        .ctx-div{height:1px;background:rgba(255,255,255,0.1);margin:4px 0}
        
        /* Tooltip */
        #tooltip{position:fixed;background:rgba(20,20,30,0.95);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.2);border-radius:8px;padding:8px;max-width:200px;z-index:1000;display:none;pointer-events:none;}

        /* Glass Form - Hidden since bypassed */
        #create-form{display:none;}

        /* Zoom Controls */
        .zoom-controls{position:fixed;top:60px;right:20px;display:flex;flex-direction:column;gap:8px;z-index:100;}

        /* Crosshair Cursor */
        #crosshair{position:fixed;pointer-events:none;z-index:9999;width:20px;height:20px;transform:translate(-50%,-50%);}
        #crosshair .line-h{position:absolute;top:50%;left:0;width:100%;height:1px;background:var(--accent);transform:translateY(-50%);}
        #crosshair .line-v{position:absolute;left:50%;top:0;height:100%;width:1px;background:var(--accent);transform:translateX(-50%);}
        #crosshair.active .line-h, #crosshair.active .line-v{background:var(--pink);transform:scale(1.5) translateY(-50%);transition:transform 0.2s;}
        #crosshair.active .line-v{transform:scale(1.5) translateX(-50%);}

        /* Center Circle */
        #center-circle{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:10px;height:10px;border:1px solid var(--accent);border-radius:50%;opacity:0.5;pointer-events:none;animation:pulse 2s infinite;}
        @keyframes pulse{50%{transform:translate(-50%,-50%) scale(1.2);opacity:0.8;}}
        #center-circle.active{border-color:var(--pink);animation:pulse 1s infinite;}

        @media (max-width: 768px) {
            .hud { display: none; }
            .fab-zone { bottom: 20px; transform: translateX(-50%) scale(0.9); }
            .top-bar { top: 70px; }
            .coords { bottom: 10px; left: 10px; font-size: 10px; }
            .trash{bottom:80px;}
            .quad-left{left:10px;}
            .presets{right:10px;}
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="mode" class="mode-status">FOCAL MODE ACTIVE</div>
    
    <div class="hud">[SCROLL] Zoom 路 [SHIFT+SCROLL] Focal 路 [LMB DRAG] Pan/Drag Cube 路 [ARROWS] Nav 路 [SPACE] New Task</div>

    <div class="quad-left">
        <div class="quad-icon backlog" data-quad="backlog"><div class="quad-cube"><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div></div></div>
        <div class="quad-icon completed" data-quad="completed"><div class="quad-cube"><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div></div></div>
        <div class="quad-icon inprogress" data-quad="inprogress"><div class="quad-cube"><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div></div></div>
        <div class="quad-icon todo" data-quad="todo"><div class="quad-cube"><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div><div class="q-face"></div></div></div>
    </div>

    <div class="presets">
        <button class="btn active" data-p="std">STD</button>
        <button class="btn" data-p="top">TOP</button>
        <button class="btn" data-p="side">SIDE</button>
    </div>

    <div class="top-bar">
        <input id="search" type="text" placeholder="Search...">
    </div>

    <div class="zoom-controls">
        <button class="btn" data-zoom="micro">Micro</button>
        <button class="btn" data-zoom="macro">Macro</button>
        <button class="btn" data-zoom="up">+</button>
        <button class="btn" data-zoom="down">-</button>
    </div>

    <div class="coords" id="coord-display">X:0.0 Y:0.0 Z:0.0</div>

    <div id="info" class="info">
        <div class="info-title" id="iTitle">Task</div>
        <div class="info-row"><span style="opacity:0.6">Title:</span><span id="iText">-</span></div>
        <div class="info-row"><span style="opacity:0.6">Description:</span><span id="iDesc">-</span></div>
        <div class="info-row"><span style="opacity:0.6">Position:</span><span id="iPos">0,0,0</span></div>
        <div class="info-row"><span style="opacity:0.6">Status:</span><span id="iState">Default</span></div>
    </div>

    <div id="ctx" class="ctx">
        <div class="ctx-item" data-a="clone">Clone</div>
        <div class="ctx-item" data-a="edit">Edit</div>
        <div class="ctx-div"></div>
        <div class="ctx-item" data-a="del">Delete</div>
    </div>

    <div class="fab-zone" id="joystick">
        <div class="fab-cube" id="joy-cube">
            <div class="f-face"></div>
            <div class="f-face"></div>
            <div class="f-face"></div>
            <div class="f-face"></div>
            <div class="f-face"></div>
            <div class="f-face"></div>
        </div>
        <div class="fab-hint">NAV</div>
    </div>

    <div class="trash" id="trash"></div>
    <div class="countdown" id="countdown"></div>
    <div id="tooltip"></div>

    <!-- Hidden form -->
    <div id="create-form" style="display:none;"></div>

    <div id="crosshair">
        <div class="line-h"></div>
        <div class="line-v"></div>
    </div>
    <div id="center-circle"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
    
    <script>
        class ThinFilm extends THREE.Texture {
            constructor(t=520){
                super();
                this.thickness = t;
                this.generate();
            }
            generate(){
                const w=512,h=1;
                const d=new Uint8Array(w*4);
                for(let i=0;i<w;i++){
                    const c=i/w;
                    const u=Math.pow(1-c,5);
                    const phase = this.thickness/100 * c * Math.PI * 2;
                    let r = 0.04 + 0.96*u + (Math.sin(phase)*0.5 + 0.5);
                    let g = u + (Math.sin(phase + 2*Math.PI/3)*0.5 + 0.5);
                    let b = u + (Math.sin(phase + 4*Math.PI/3)*0.5 + 0.5);
                    r = Math.max(0, Math.min(1, r));
                    g = Math.max(0, Math.min(1, g));
                    b = Math.max(0, Math.min(1, b));
                    d[i*4]=Math.floor(r*255);
                    d[i*4+1]=Math.floor(g*255);
                    d[i*4+2]=Math.floor(b*255);
                    d[i*4+3]=255;
                }
                this.image={data:d,width:w,height:h};
                this.magFilter=THREE.LinearFilter;
                this.minFilter=THREE.LinearFilter;
                this.wrapS=THREE.ClampToEdgeWrapping;
                this.wrapT=THREE.ClampToEdgeWrapping;
                this.needsUpdate=true;
            }
        }

        const CFG = {
            cam: { eye: {y:40} },
            preset: {
                std: { o: new THREE.Vector3(0,8,20), r: new THREE.Euler(-0.3,0,0) },
                top: { o: new THREE.Vector3(0,50,0.1), r: new THREE.Euler(-Math.PI/2,0,0) },
                side: { o: new THREE.Vector3(80, 0, 0), r: new THREE.Euler(0, Math.PI/2, 0) }
            }
        };

        const quadrantCenters = {
            todo: new THREE.Vector3(10, 2, -10),
            inprogress: new THREE.Vector3(-10, 2, -10),
            completed: new THREE.Vector3(10, 2, 10),
            backlog: new THREE.Vector3(-10, 2, 10)
        };

        const quadrantColors = {
            todo: 0xffff00,
            inprogress: 0x00ffff,
            completed: 0x00ff00,
            backlog: 0xff0000
        };

        const quadrantNames = {
            todo: 'To-Do',
            inprogress: 'In-Progress',
            completed: 'Completed',
            backlog: 'Backlog'
        };

        const sc = new THREE.Scene();
        sc.background = new THREE.Color(0x000000);
        sc.fog = new THREE.FogExp2(0x000000, 0.009);

        const cam = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 10077);

        const rend = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        rend.setSize(innerWidth, innerHeight);
        rend.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        rend.shadowMap.enabled = true;
        rend.shadowMap.type = THREE.PCFSoftShadowMap;

        const world = new CANNON.World();
        world.gravity.set(0, -9.81, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        const mat = new CANNON.Material();
        world.addContactMaterial(new CANNON.ContactMaterial(mat, mat, { friction: 0.3, restitution: 0.0 }));

        const rig = { mode: 'std', preset: 'std', piv: new THREE.Vector3(), tPiv: new THREE.Vector3() };
        const tm = { cubes: [], sel: null, hov: null, drag: null };

        let distanceScale = 1;
        let isPanning = false;
        let panStartIntersect = null;

        sc.add(new THREE.AmbientLight(0xffffff, 0.5));

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.6);
        dirLight.position.set(15, 40, 15);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        sc.add(dirLight);

        const neon1 = new THREE.PointLight(0x00ffff, 5, 80); neon1.position.set(-25, 20, -25); sc.add(neon1);
        const neon2 = new THREE.PointLight(0xff00ff, 5, 80); neon2.position.set(25, 20, 25); sc.add(neon2);
        const neon3 = new THREE.PointLight(0x00ff88, 4.5, 70); neon3.position.set(0, 30, 0); sc.add(neon3);

        const cRT = new THREE.WebGLCubeRenderTarget(512, { format: THREE.RGBFormat, generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter });
        const cCam = new THREE.CubeCamera(0.1, 1000, cRT);
        sc.add(cCam);

        const fMap = new ThinFilm(520);

        const gnd = new THREE.Mesh(
          new THREE.PlaneGeometry(40, 40),
          new THREE.MeshStandardMaterial({ color: 0x010101, roughness: 0.85, metalness: 0.95, envMapIntensity: 1.3 })
        );
        gnd.rotation.x = -Math.PI / 2;
        gnd.position.y = -4;
        gnd.receiveShadow = true;
        sc.add(gnd);

        const gB = new CANNON.Body({ mass: 0, material: mat });
        gB.addShape(new CANNON.Plane());
        gB.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        gB.position.set(0, -4, 0);
        world.addBody(gB);

        // Walls
        const wallMat = new CANNON.Material();
        world.addContactMaterial(new CANNON.ContactMaterial(mat, wallMat, { friction: 0.3, restitution: 0.0 }));

        // Left wall
        const leftWall = new CANNON.Body({ mass: 0, material: wallMat });
        leftWall.addShape(new CANNON.Plane());
        leftWall.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI / 2);
        leftWall.position.set(-20, 0, 0);
        world.addBody(leftWall);

        // Right wall
        const rightWall = new CANNON.Body({ mass: 0, material: wallMat });
        rightWall.addShape(new CANNON.Plane());
        rightWall.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2);
        rightWall.position.set(20, 0, 0);
        world.addBody(rightWall);

        // Back wall
        const backWall = new CANNON.Body({ mass: 0, material: wallMat });
        backWall.addShape(new CANNON.Plane());
        backWall.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
        backWall.position.set(0, 0, 20);
        world.addBody(backWall);

        // Front wall
        const frontWall = new CANNON.Body({ mass: 0, material: wallMat });
        frontWall.addShape(new CANNON.Plane());
        frontWall.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        frontWall.position.set(0, 0, -20);
        world.addBody(frontWall);

        const gridGrp = new THREE.Group();
        sc.add(gridGrp);

        function createGrid() {
            while(gridGrp.children.length){ 
                const o = gridGrp.children[0]; 
                if(o.geometry) o.geometry.dispose();
                if(o.material) o.material.dispose();
                gridGrp.remove(o); 
            }
            
            const step = 5, rangeX = 20, rangeZ = 20;
            // X lines
            for (let x = -rangeX; x <= rangeX; x += step) {
                const g = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(x, -3.9, -rangeZ), new THREE.Vector3(x, -3.9, rangeZ)]);
                gridGrp.add(new THREE.Line(g, new THREE.LineBasicMaterial({ color: 0x2a2a3e })));
            }
            // Z lines
            for (let z = -rangeZ; z <= rangeZ; z += step) {
                const g = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-rangeX, -3.9, z), new THREE.Vector3(rangeX, -3.9, z)]);
                gridGrp.add(new THREE.Line(g, new THREE.LineBasicMaterial({ color: 0x2a2a3e })));
            }
            // Quadrant labels
            for (let q in quadrantCenters) {
                const c = document.createElement('canvas'); c.width = 256; c.height = 64;
                const x = c.getContext('2d'); x.fillStyle = `#${quadrantColors[q].toString(16)}`; x.font = 'bold 40px monospace'; x.textAlign = 'center'; x.fillText(quadrantNames[q], 128, 50);
                const s = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(c), transparent:true, opacity:0.8 }));
                s.position.set(quadrantCenters[q].x, -3.5, quadrantCenters[q].z);
                s.scale.set(10, 2.5, 1);
                gridGrp.add(s);
            }
        }
        createGrid();

        const ringGeo = new THREE.RingGeometry(1.8, 2.2, 32); ringGeo.rotateX(-Math.PI/2);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x39FF14, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
        const selRing = new THREE.Mesh(ringGeo, ringMat); selRing.visible = false; sc.add(selRing);

        class Cube {
            constructor(x, y, z, sz = 1.5) {
                this.sz = sz;
                this.title = '';
                this.desc = '';
                this.status = this.getQuadFromPos(new THREE.Vector3(x, y, z));

                const g = new THREE.BoxGeometry(sz, sz, sz);

                const color = quadrantColors[this.status];
                const baseMat = new THREE.MeshPhysicalMaterial({
                    color: color,
                    metalness: 1.0,
                    roughness: 0.05,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.0,
                    emissive: color,
                    emissiveIntensity: 3.0,
                    envMap: cRT.texture,
                    envMapIntensity: 1.6
                });

                this.baseMat = baseMat;
                this.oMat = Array(6).fill(this.baseMat);

                this.m = new THREE.Mesh(g, this.oMat);
                this.m.position.set(x, y, z);
                this.m.castShadow = true;
                this.m.receiveShadow = true;
                this.m.userData.cube = this;

                const ed = new THREE.LineSegments(new THREE.EdgesGeometry(g), new THREE.LineBasicMaterial({ color: 0xffffff }));
                ed.visible = false;
                this.ed = ed;
                this.m.add(ed);
                sc.add(this.m);

                const sh = new CANNON.Box(new CANNON.Vec3(sz / 2, sz / 2, sz / 2));
                this.b = new CANNON.Body({ mass: 1, material: mat, type: CANNON.Body.DYNAMIC });
                this.b.addShape(sh);
                this.b.position.set(x, y, z);
                this.b.linearDamping = 0.5;
                this.b.angularDamping = 0.5;
                world.addBody(this.b);
            }
            getQuadFromPos(p) {
                const x = p.x, z = p.z;
                if (x > 0 && z < 0) return 'todo';
                if (x < 0 && z < 0) return 'inprogress';
                if (x > 0 && z > 0) return 'completed';
                return 'backlog';
            }
            updateColor() {
                const color = quadrantColors[this.status];
                this.baseMat.color.set(color);
                this.baseMat.emissive.set(color);
            }
            updateTextSprite() {
                if (this.textSprite) this.m.remove(this.textSprite);
                if (!this.title) return;
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 32px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(this.title, 128, 64);
                const map = new THREE.CanvasTexture(canvas);
                const spriteMat = new THREE.SpriteMaterial({map});
                this.textSprite = new THREE.Sprite(spriteMat);
                this.textSprite.scale.set(4,2,1);
                this.textSprite.position.set(0, this.sz/2 + 1, 0);
                this.m.add(this.textSprite);
            }
            sel() {
                this.ed.visible = true;
                tm.sel = this;
                this.upd();
            }
            desel() {
                this.ed.visible = false;
                if (tm.sel === this) { tm.sel = null; document.getElementById('info').classList.remove('active'); }
            }
            hov() {
                this.baseMat.emissiveIntensity = 3.0 * 1.5;
            }
            unhov() {
                this.baseMat.emissiveIntensity = 3.0;
            }
            upd() {
                const pn = document.getElementById('info');
                pn.classList.add('active');
                document.getElementById('iText').textContent = this.title || '-';
                document.getElementById('iDesc').textContent = this.desc || '-';
                document.getElementById('iPos').textContent = `${this.b.position.x.toFixed(1)},${this.b.position.y.toFixed(1)},${this.b.position.z.toFixed(1)}`;
                document.getElementById('iState').textContent = quadrantNames[this.status];
            }
            tick() {
                this.m.position.copy(this.b.position);
                this.m.quaternion.copy(this.b.quaternion);
                const newStatus = this.getQuadFromPos(this.b.position);
                if (newStatus !== this.status) {
                    this.status = newStatus;
                    this.updateColor();
                }
            }
            rm() {
                sc.remove(this.m);
                world.removeBody(this.b);
                const i = tm.cubes.indexOf(this);
                if (i > -1) tm.cubes.splice(i, 1);
            }
        }

        const saved = localStorage.getItem('punt-tasks');
        if (saved) {
            const data = JSON.parse(saved);
            data.forEach(d => {
                const c = new Cube(d.pos.x, d.pos.y, d.pos.z);
                c.title = d.title;
                c.desc = d.desc;
                c.updateTextSprite();
                c.b.quaternion.set(d.quat.x, d.quat.y, d.quat.z, d.quat.w);
                tm.cubes.push(c);
            });
        } else {
            for (let i = 0; i < 12; i++) {
                const quadKeys = Object.keys(quadrantCenters);
                const randomQuad = quadKeys[Math.floor(Math.random() * quadKeys.length)];
                const center = quadrantCenters[randomQuad];
                const c = new Cube(center.x + (Math.random() - 0.5) * 10, Math.random() * 4 + 1, center.z + (Math.random() - 0.5) * 10);
                c.title = `Task ${i+1}`;
                c.desc = `Description for task ${i+1}`;
                c.updateTextSprite();
                tm.cubes.push(c);
            }
        }

        const rc = new THREE.Raycaster(), ms = new THREE.Vector2(), intersect = new THREE.Vector3();
        function upMs(e) { ms.x = (e.clientX / innerWidth) * 2 - 1; ms.y = -(e.clientY / innerHeight) * 2 + 1; }
        function getC() { rc.setFromCamera(ms, cam); const in_ = rc.intersectObjects(tm.cubes.map(c => c.m)); return in_.length > 0 ? in_[0].object.userData.cube : null; }
        function getG(e) {
            upMs(e);
            rc.setFromCamera(ms, cam);
            const planeY = tm.drag ? tm.drag.b.position.y : 0;
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -planeY);
            if (rc.ray.intersectPlane(plane, intersect)) return intersect;
            return null;
        }

        addEventListener('wheel', e => {
            e.preventDefault();
            if (e.shiftKey) {
                cam.fov += e.deltaY * 0.05;
                cam.fov = Math.max(10, Math.min(120, cam.fov));
                cam.updateProjectionMatrix();
            } else {
                distanceScale += e.deltaY * 0.001;
                distanceScale = Math.max(0.2, Math.min(10, distanceScale));
            }
        });

        addEventListener('mousemove', e => {
            upMs(e);
            const hc = getC();
            if (hc !== tm.hov) { 
                if (tm.hov) tm.hov.unhov(); 
                tm.hov = hc; 
                if (hc) hc.hov(); 
            }
            const crosshair = document.getElementById('crosshair');
            crosshair.style.left = e.clientX + 'px';
            crosshair.style.top = e.clientY + 'px';
            if (hc) {
                crosshair.classList.add('active');
                const tooltip = document.getElementById('tooltip');
                tooltip.style.display = 'block';
                tooltip.style.left = e.clientX + 10 + 'px';
                tooltip.style.top = e.clientY + 10 + 'px';
                tooltip.innerHTML = `<b>${hc.title || 'Untitled'}</b><br>${hc.desc || 'No description'}`;
            } else {
                crosshair.classList.remove('active');
                document.getElementById('tooltip').style.display = 'none';
            }
            if (tm.drag && e.buttons & 1) {
                const gp = getG(e);
                if (gp) {
                    tm.drag.b.position.copy(gp);
                }
                const trashEl = document.getElementById('trash');
                const overEl = document.elementFromPoint(e.clientX, e.clientY);
                if (overEl && overEl.id === 'trash') {
                    trashEl.classList.add('active');
                } else {
                    trashEl.classList.remove('active');
                }
            } else if (isPanning && e.buttons & 1) {
                const gp = getG(e);
                if (gp && panStartIntersect) {
                    const delta = new THREE.Vector3().subVectors(gp, panStartIntersect);
                    rig.tPiv.sub(delta);
                    panStartIntersect.copy(gp);
                }
            }
        });

        addEventListener('mousedown', e => {
            upMs(e);
            const c = getC();
            if (c) {
                if (tm.sel && tm.sel !== c) tm.sel.desel();
                c.sel();
                tm.drag = c;
                c.originalY = c.b.position.y;
                c.b.type = CANNON.Body.KINEMATIC;
                gsap.to(c.b.position, { y: c.originalY + 3, duration: 0.2, ease: "power2.out" });
            } else {
                const gp = getG(e);
                if (gp) {
                    isPanning = true;
                    panStartIntersect = gp.clone();
                } else {
                    if (tm.sel) tm.sel.desel();
                }
            }
        });

        addEventListener('mouseup', e => {
            if (tm.drag) {
                const c = tm.drag;
                gsap.to(c.b.position, { y: c.originalY, duration: 0.3, ease: "power1.in", onComplete: () => {
                    c.b.type = CANNON.Body.DYNAMIC;
                } });
                const trashEl = document.getElementById('trash');
                if (trashEl.classList.contains('active')) {
                    c.rm();
                    trashEl.classList.remove('active');
                }
            }
            tm.drag = null;
            isPanning = false;
            panStartIntersect = null;
        });

        addEventListener('contextmenu', e => { 
            e.preventDefault(); 
            upMs(e); 
            const c = getC(); 
            if (c) { 
                const m = document.getElementById('ctx'); 
                m.style.left = e.clientX + 'px'; 
                m.style.top = e.clientY + 'px'; 
                m.classList.add('active'); 
                tm.sel = c; 
            } 
        });
        addEventListener('click', () => { document.getElementById('ctx').classList.remove('active'); });

        document.querySelectorAll('.ctx-item').forEach(it => {
            it.addEventListener('click', e => {
                e.stopPropagation();
                const a = it.dataset.a, c = tm.sel;
                if (!c) return;
                switch (a) {
                    case 'clone':
                        const cl = new Cube(c.b.position.x + 2, c.b.position.y, c.b.position.z, c.sz);
                        cl.title = c.title;
                        cl.desc = c.desc;
                        cl.updateTextSprite();
                        tm.cubes.push(cl);
                        break;
                    case 'edit':
                        const title = prompt('Edit Title', c.title);
                        const desc = prompt('Edit Description', c.desc);
                        if (title !== null) {
                            c.title = title;
                            c.desc = desc || '';
                            c.updateTextSprite();
                        }
                        break;
                    case 'del': 
                        c.rm(); 
                        tm.sel = null; 
                        document.getElementById('info').classList.remove('active'); 
                        break;
                }
            });
        });

        addEventListener('dblclick', e => {
            upMs(e);
            const c = getC();
            if (c) {
                const title = prompt('Edit Title', c.title);
                const desc = prompt('Edit Description', c.desc);
                if (title !== null) {
                    c.title = title;
                    c.desc = desc || '';
                    c.updateTextSprite();
                }
            }
        });

        const k = {};
        addEventListener('keydown', e => {
            k[e.key] = true;
            if (e.key === 'Shift') { rig.mode = 'eye'; document.getElementById('mode').classList.add('active'); }
            if (e.key === ' ') { 
                e.preventDefault(); 
                const title = prompt('Task Title');
                if (title) {
                    const desc = prompt('Task Description');
                    const c = new Cube(rig.piv.x, 2, rig.piv.z);
                    c.title = title;
                    c.desc = desc || '';
                    c.updateTextSprite();
                    tm.cubes.push(c);
                }
            }
        });
        addEventListener('keyup', e => { k[e.key] = false; if (e.key === 'Shift') { rig.mode = 'std'; document.getElementById('mode').classList.remove('active'); } });

        setInterval(() => {
            const s = 0.8;
            if (k.ArrowUp) rig.tPiv.z -= s;
            if (k.ArrowDown) rig.tPiv.z += s;
            if (k.ArrowLeft) rig.tPiv.x -= s;
            if (k.ArrowRight) rig.tPiv.x += s;
        }, 16);

        document.querySelectorAll('[data-p]').forEach(b => {
            b.addEventListener('click', () => {
                document.querySelectorAll('[data-p]').forEach(x => x.classList.remove('active'));
                b.classList.add('active');
                rig.preset = b.dataset.p;
            });
        });

        document.querySelectorAll('[data-zoom]').forEach(b => {
            b.addEventListener('click', () => {
                const z = b.dataset.zoom;
                if (z === 'up') distanceScale -= 0.2;
                else if (z === 'down') distanceScale += 0.2;
                else if (z === 'micro') distanceScale = 0.2;
                else if (z === 'macro') distanceScale = 10;
                distanceScale = Math.max(0.2, Math.min(10, distanceScale));
            });
        });

        document.querySelectorAll('.quad-icon').forEach(b => {
            b.addEventListener('click', () => {
                const quad = b.dataset.quad;
                rig.tPiv.copy(quadrantCenters[quad]);
            });
        });

        document.getElementById('search').addEventListener('input', e => {
            const val = e.target.value.toLowerCase();
            tm.cubes.forEach(c => {
                const show = !val || c.title.toLowerCase().includes(val);
                c.m.visible = show;
                if (c.textSprite) c.textSprite.visible = show;
            });
        });

        addEventListener('beforeunload', () => {
            const data = tm.cubes.map(c => ({
                title: c.title,
                desc: c.desc,
                pos: { x: c.b.position.x, y: c.b.position.y, z: c.b.position.z },
                quat: { x: c.b.quaternion.x, y: c.b.quaternion.y, z: c.b.quaternion.z, w: c.b.quaternion.w }
            }));
            localStorage.setItem('punt-tasks', JSON.stringify(data));
        });

        const joy = { el: document.getElementById('joy-cube'), zone: document.getElementById('joystick'), active: false, start: {x:0, y:0} };

        function handleJoy(x, y) {
            const max = 40;
            let dx = x - joy.start.x, dy = y - joy.start.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist > max) { const r = max/dist; dx*=r; dy*=r; }

            joy.el.style.transform = `rotateX(${-25 + (dy/max*45)}deg) rotateY(${-45 + (dx/max*45)}deg)`;
            
            const speed = 0.8;
            rig.tPiv.z += dy / max * speed;
            rig.tPiv.x += dx / max * speed;
        }

        function startJoy(x, y) {
            joy.active = true; joy.start = {x, y};
            joy.el.style.transition = 'none';
            document.body.classList.add('fab-active'); 
        }

        function endJoy() {
            joy.active = false;
            joy.el.style.transition = 'transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
            joy.el.style.transform = `rotateX(-25deg) rotateY(-45deg)`;
            document.body.classList.remove('fab-active');
        }

        joy.zone.addEventListener('mousedown', e => { startJoy(e.clientX, e.clientY); e.stopPropagation(); });
        joy.zone.addEventListener('touchstart', e => { startJoy(e.touches[0].clientX, e.touches[0].clientY); e.stopPropagation(); });
        
        addEventListener('mousemove', e => { if(joy.active) handleJoy(e.clientX, e.clientY); });
        addEventListener('touchmove', e => { if(joy.active && e.touches.length === 1) handleJoy(e.touches[0].clientX, e.touches[0].clientY); });
        
        addEventListener('mouseup', endJoy);
        addEventListener('touchend', endJoy);

        let lt = 0;
        const coordD = document.getElementById('coord-display');
        function anim() {
            requestAnimationFrame(anim);
            const ct = performance.now() / 1000, dt = Math.min(ct - lt, 0.1); lt = ct;

            world.step(1 / 60, dt, 10);
            tm.cubes.forEach(c => c.tick());

            rig.piv.lerp(rig.tPiv, 0.1);

            const p = CFG.preset[rig.preset];

            if (rig.mode === 'eye') {
                const height = CFG.cam.eye.y * distanceScale;
                cam.position.lerp(new THREE.Vector3(rig.piv.x, height, rig.piv.z), 0.1);
                cam.lookAt(rig.piv);
            } else {
                const offset = p.o.clone().multiplyScalar(distanceScale);
                const tp = new THREE.Vector3().copy(rig.piv).add(offset);
                cam.position.lerp(tp, 0.1);
                cam.rotation.x += (p.r.x - cam.rotation.x) * 0.1;
                cam.rotation.y += (p.r.y - cam.rotation.y) * 0.1;
                cam.rotation.z += (p.r.z - cam.rotation.z) * 0.1;
            }

            cCam.update(rend, sc);

            if (tm.sel && (rig.preset === 'top' || rig.preset === 'side')) {
                selRing.visible = true;
                selRing.position.copy(tm.sel.m.position);
                selRing.position.y = -3.99;
                const s = 1 + Math.sin(ct * 2) * 0.1;
                selRing.scale.set(s, 1, s);
            } else {
                selRing.visible = false;
            }

            coordD.textContent = `X:${rig.piv.x.toFixed(1)} Y:${rig.piv.y.toFixed(1)} Z:${rig.piv.z.toFixed(1)}`;

            rend.render(sc, cam);
        }

        addEventListener('resize', () => { cam.aspect = innerWidth / innerHeight; cam.updateProjectionMatrix(); rend.setSize(innerWidth, innerHeight); });
        anim();
    </script>
</body>
</html>
