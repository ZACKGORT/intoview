<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>3D Cube Notes - Spatial Thinking</title>
  
  <!-- FONTS -->
  <link href="https://fonts.googleapis.com" rel="preconnect" crossorigin>
  <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet">
  
  <!-- LIBRARIES -->
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.babylonjs.com/cannon.js"></script>
  
  <style>
    /* ============================================
       DESIGN SYSTEM & VARIABLES
       ============================================ */
    :root {
      --bg-primary: #0a0e1a;
      --bg-secondary: #141824;
      --surface: #1e2330;
      --surface-elevated: #282d3c;
      
      --text-primary: #ffffff;
      --text-secondary: #a8b2d1;
      --text-muted: #64748b;
      
      --accent-primary: #60a5fa;
      --accent-secondary: #818cf8;
      --accent-success: #34d399;
      --accent-warning: #fbbf24;
      --accent-danger: #f87171;
      
      --cube-default: #3b82f6;
      --cube-selected: #60a5fa;
      --cube-connected: #818cf8;
      --cube-floating: #fbbf24;
      
      --glass-bg: rgba(30, 35, 48, 0.8);
      --glass-border: rgba(255, 255, 255, 0.1);
      --glass-blur: 12px;
      
      --shadow-elevation-1: 0 2px 8px rgba(0, 0, 0, 0.3);
      --shadow-elevation-2: 0 4px 16px rgba(0, 0, 0, 0.4);
      --shadow-elevation-3: 0 8px 32px rgba(0, 0, 0, 0.5);
      
      --transition-fast: 0.2s ease;
      --transition-smooth: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-swoosh: 0.6s cubic-bezier(0.23, 1, 0.32, 1);
      
      --z-ui: 100;
      --z-overlay: 200;
      --z-modal: 300;
      --z-tooltip: 400;
    }

    /* ============================================
       BASE STYLES
       ============================================ */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      overflow: hidden;
      touch-action: none;
    }

    /* ============================================
       3D CANVAS
       ============================================ */
    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      cursor: grab;
    }

    #canvas.grabbing {
      cursor: grabbing;
    }

    #canvas.inspecting {
      cursor: crosshair;
    }

    /* ============================================
       CAMERA MODE INDICATOR
       ============================================ */
    .camera-indicator {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--glass-bg);
      backdrop-filter: blur(var(--glass-blur));
      -webkit-backdrop-filter: blur(var(--glass-blur));
      border: 1px solid var(--glass-border);
      border-radius: 24px;
      padding: 8px 20px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
      z-index: var(--z-ui);
      opacity: 0;
      transition: opacity var(--transition-fast);
    }

    .camera-indicator.visible {
      opacity: 1;
    }

    /* ============================================
       RAIL TOGGLE UI (Edge Navigation)
       ============================================ */
    .rail-toggle {
      position: fixed;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      background: var(--glass-bg);
      backdrop-filter: blur(var(--glass-blur));
      -webkit-backdrop-filter: blur(var(--glass-blur));
      border: 1px solid var(--glass-border);
      border-left: none;
      border-radius: 0 24px 24px 0;
      padding: 16px 8px;
      z-index: var(--z-ui);
      transition: all var(--transition-smooth);
    }

    .rail-toggle:hover {
      background: var(--surface-elevated);
      transform: translateY(-50%) translateX(4px);
    }

    .rail-toggle.active {
      background: var(--surface-elevated);
      transform: translateY(-50%) translateX(200px);
    }

    .rail-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      margin-bottom: 20px;
      cursor: pointer;
      transition: all var(--transition-fast);
      padding: 8px;
      border-radius: 12px;
    }

    .rail-item:hover {
      background: var(--glass-bg);
      transform: scale(1.05);
    }

    .rail-item.active {
      background: var(--accent-primary);
      color: var(--bg-primary);
    }

    .rail-icon {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }

    .rail-label {
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      writing-mode: vertical-rl;
      text-orientation: mixed;
    }

    /* ============================================
       MODE PANEL
       ============================================ */
    .mode-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--glass-bg);
      backdrop-filter: blur(var(--glass-blur));
      -webkit-backdrop-filter: blur(var(--glass-blur));
      border: 1px solid var(--glass-border);
      border-radius: 20px;
      padding: 16px;
      z-index: var(--z-ui);
      min-width: 200px;
      box-shadow: var(--shadow-elevation-2);
    }

    .mode-title {
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-secondary);
      margin-bottom: 12px;
    }

    .mode-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .mode-option {
      padding: 10px 14px;
      border-radius: 12px;
      background: transparent;
      border: 1px solid var(--glass-border);
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all var(--transition-fast);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .mode-option:hover {
      background: var(--surface);
      border-color: var(--accent-primary);
      transform: translateY(-1px);
    }

    .mode-option.active {
      background: var(--accent-primary);
      border-color: var(--accent-primary);
      color: var(--bg-primary);
    }

    .mode-icon {
      font-size: 14px;
    }

    /* ============================================
       FLOATING ACTION BUTTON
       ============================================ */
    .fab {
      position: fixed;
      bottom: 32px;
      right: 32px;
      width: 64px;
      height: 64px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      border: none;
      color: white;
      font-size: 24px;
      font-weight: 700;
      cursor: pointer;
      z-index: var(--z-ui);
      transition: all var(--transition-smooth);
      box-shadow: var(--shadow-elevation-2);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .fab:hover {
      transform: scale(1.1) rotate(90deg);
      box-shadow: var(--shadow-elevation-3);
    }

    .fab:active {
      transform: scale(0.95);
    }

    /* ============================================
       CONTEXT MENU
       ============================================ */
    .context-menu {
      position: fixed;
      background: var(--glass-bg);
      backdrop-filter: blur(var(--glass-blur));
      -webkit-backdrop-filter: blur(var(--glass-blur));
      border: 1px solid var(--glass-border);
      border-radius: 16px;
      padding: 8px;
      z-index: var(--z-modal);
      opacity: 0;
      pointer-events: none;
      transform: scale(0.95) translateY(10px);
      transition: all var(--transition-fast);
      box-shadow: var(--shadow-elevation-3);
    }

    .context-menu.visible {
      opacity: 1;
      pointer-events: auto;
      transform: scale(1) translateY(0);
    }

    .context-item {
      padding: 10px 16px;
      border-radius: 8px;
      cursor: pointer;
      transition: background var(--transition-fast);
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 10px;
      white-space: nowrap;
    }

    .context-item:hover {
      background: var(--surface);
    }

    .context-separator {
      height: 1px;
      background: var(--glass-border);
      margin: 4px 0;
    }

    /* ============================================
       NOTE EDITOR MODAL
       ============================================ */
    .note-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      z-index: var(--z-modal);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity var(--transition-smooth);
    }

    .note-modal.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .note-modal-content {
      background: var(--surface);
      border: 1px solid var(--glass-border);
      border-radius: 24px;
      padding: 32px;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      transform: scale(0.9) translateY(20px);
      transition: transform var(--transition-smooth);
      box-shadow: var(--shadow-elevation-3);
    }

    .note-modal.visible .note-modal-content {
      transform: scale(1) translateY(0);
    }

    .note-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
    }

    .note-modal-title {
      font-size: 20px;
      font-weight: 700;
      color: var(--text-primary);
    }

    .note-modal-close {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: none;
      background: var(--glass-bg);
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all var(--transition-fast);
    }

    .note-modal-close:hover {
      background: var(--surface-elevated);
      color: var(--text-primary);
    }

    .note-form-group {
      margin-bottom: 20px;
    }

    .note-form-label {
      display: block;
      margin-bottom: 8px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
    }

    .note-form-input,
    .note-form-textarea {
      width: 100%;
      padding: 12px 16px;
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      font-size: 14px;
      font-family: inherit;
      transition: all var(--transition-fast);
    }

    .note-form-input:focus,
    .note-form-textarea:focus {
      outline: none;
      border-color: var(--accent-primary);
      background: var(--surface);
    }

    .note-form-textarea {
      resize: vertical;
      min-height: 120px;
    }

    .note-form-actions {
      display: flex;
      gap: 12px;
      margin-top: 24px;
    }

    .note-form-btn {
      flex: 1;
      padding: 12px 20px;
      border-radius: 12px;
      border: none;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition-fast);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .note-form-btn-primary {
      background: var(--accent-primary);
      color: var(--bg-primary);
    }

    .note-form-btn-primary:hover {
      background: var(--accent-secondary);
      transform: translateY(-1px);
    }

    .note-form-btn-secondary {
      background: var(--glass-bg);
      color: var(--text-secondary);
      border: 1px solid var(--glass-border);
    }

    .note-form-btn-secondary:hover {
      background: var(--surface);
      color: var(--text-primary);
    }

    /* ============================================
       STATUS BAR
       ============================================ */
    .status-bar {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: var(--glass-bg);
      backdrop-filter: blur(var(--glass-blur));
      -webkit-backdrop-filter: blur(var(--glass-blur));
      border: 1px solid var(--glass-border);
      border-radius: 16px;
      padding: 12px 20px;
      font-size: 12px;
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-secondary);
      z-index: var(--z-ui);
      display: flex;
      gap: 20px;
      align-items: center;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-label {
      color: var(--text-muted);
    }

    .status-value {
      color: var(--accent-primary);
      font-weight: 600;
    }

    /* ============================================
       HELP OVERLAY
       ============================================ */
    .help-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      z-index: var(--z-modal);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity var(--transition-smooth);
    }

    .help-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .help-content {
      background: var(--surface);
      border: 1px solid var(--glass-border);
      border-radius: 24px;
      padding: 32px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      transform: scale(0.9) translateY(20px);
      transition: transform var(--transition-smooth);
    }

    .help-overlay.visible .help-content {
      transform: scale(1) translateY(0);
    }

    .help-title {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 20px;
      color: var(--text-primary);
    }

    .help-section {
      margin-bottom: 24px;
    }

    .help-section-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--accent-primary);
    }

    .help-list {
      list-style: none;
    }

    .help-list li {
      margin-bottom: 8px;
      padding-left: 20px;
      position: relative;
      font-size: 14px;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    .help-list li:before {
      content: "‚Üí";
      position: absolute;
      left: 0;
      color: var(--accent-primary);
    }

    .help-shortcuts {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 8px 16px;
      font-size: 14px;
    }

    .help-key {
      background: var(--glass-bg);
      padding: 4px 8px;
      border-radius: 4px;
      font-family: 'JetBrains Mono', monospace;
      font-weight: 600;
      color: var(--accent-primary);
    }

    .help-desc {
      color: var(--text-secondary);
    }

    /* ============================================
       RESPONSIVE DESIGN
       ============================================ */
    @media (max-width: 768px) {
      .rail-toggle {
        top: auto;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        border-radius: 24px 24px 0 0;
        border-left: 1px solid var(--glass-border);
        border-bottom: none;
        flex-direction: row;
        padding: 12px 16px;
        gap: 16px;
      }

      .rail-toggle.active {
        transform: translateX(-50%) translateY(-200px);
      }

      .rail-item {
        flex-direction: row;
        margin-bottom: 0;
        margin-right: 16px;
      }

      .rail-label {
        writing-mode: horizontal-tb;
      }

      .mode-panel {
        top: auto;
        bottom: 180px;
        right: 20px;
      }

      .status-bar {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }

      .fab {
        width: 56px;
        height: 56px;
        font-size: 20px;
      }
    }

    @media (max-width: 480px) {
      .mode-panel {
        right: 16px;
        bottom: 160px;
        min-width: 160px;
      }

      .help-content {
        padding: 24px;
      }

      .note-modal-content {
        padding: 24px;
      }
    }

    /* ============================================
       ACCESSIBILITY
       ============================================ */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    /* ============================================
       FOCUS STATES
       ============================================ */
    *:focus {
      outline: 2px solid var(--accent-primary);
      outline-offset: 2px;
    }

    button:focus, .mode-option:focus, .context-item:focus {
      outline: 2px solid var(--accent-primary);
    }
  </style>

</head>
<body>
  <!-- 3D Canvas -->
  <canvas id="canvas"></canvas>

  <!-- Camera Mode Indicator -->
  <div class="camera-indicator" id="cameraIndicator">Macro View</div>

  <!-- Rail Toggle UI -->
  <nav class="rail-toggle" id="railToggle">
    <div class="rail-item active" data-mode="view">
      <div class="rail-icon">üëÅÔ∏è</div>
      <div class="rail-label">View</div>
    </div>
    <div class="rail-item" data-mode="string">
      <div class="rail-icon">üîó</div>
      <div class="rail-label">String Together</div>
    </div>
    <div class="rail-item" data-mode="break">
      <div class="rail-icon">üíî</div>
      <div class="rail-label">Break Up</div>
    </div>
    <div class="rail-item" data-mode="float">
      <div class="rail-icon">üéà</div>
      <div class="rail-label">Hold Thought</div>
    </div>
    <div class="rail-item" data-mode="move">
      <div class="rail-icon">‚úã</div>
      <div class="rail-label">Move</div>
    </div>
  </nav>

  <!-- Mode Panel -->
  <div class="mode-panel">
    <div class="mode-title">Current Mode</div>
    <div class="mode-options">
      <div class="mode-option active" data-mode="view">
        <span class="mode-icon">üëÅÔ∏è</span>
        <span>View Mode</span>
      </div>
      <div class="mode-option" data-mode="string">
        <span class="mode-icon">üîó</span>
        <span>String Together</span>
      </div>
      <div class="mode-option" data-mode="break">
        <span class="mode-icon">üíî</span>
        <span>Break Up</span>
      </div>
      <div class="mode-option" data-mode="float">
        <span class="mode-icon">üéà</span>
        <span>Hold Thought</span>
      </div>
      <div class="mode-option" data-mode="move">
        <span class="mode-icon">‚úã</span>
        <span>Move Mode</span>
      </div>
    </div>
  </div>

  <!-- Floating Action Button -->
  <button class="fab" id="fabButton" aria-label="Create Note">+</button>

  <!-- Context Menu -->
  <div class="context-menu" id="contextMenu">
    <div class="context-item" data-action="edit">
      <span>‚úèÔ∏è</span>
      <span>Edit Note</span>
    </div>
    <div class="context-item" data-action="duplicate">
      <span>üìã</span>
      <span>Duplicate</span>
    </div>
    <div class="context-separator"></div>
    <div class="context-item" data-action="float">
      <span>üéà</span>
      <span>Hold Thought</span>
    </div>
    <div class="context-item" data-action="connect">
      <span>üîó</span>
      <span>String Together</span>
    </div>
    <div class="context-separator"></div>
    <div class="context-item" data-action="delete">
      <span>üóëÔ∏è</span>
      <span>Delete</span>
    </div>
  </div>

  <!-- Note Editor Modal -->
  <div class="note-modal" id="noteModal">
    <div class="note-modal-content">
      <div class="note-modal-header">
        <h2 class="note-modal-title">Edit Note</h2>
        <button class="note-modal-close" id="noteModalClose">√ó</button>
      </div>
      <form id="noteForm">
        <div class="note-form-group">
          <label class="note-form-label" for="noteTitle">Title</label>
          <input type="text" id="noteTitle" class="note-form-input" placeholder="Enter note title..." required>
        </div>
        <div class="note-form-group">
          <label class="note-form-label" for="noteContent">Content</label>
          <textarea id="noteContent" class="note-form-textarea" placeholder="Enter your thoughts..." required></textarea>
        </div>
        <div class="note-form-group">
          <label class="note-form-label" for="noteCategory">Category</label>
          <select id="noteCategory" class="note-form-input">
            <option value="idea">üí° Idea</option>
            <option value="task">üìã Task</option>
            <option value="note">üìù Note</option>
            <option value="reminder">‚è∞ Reminder</option>
            <option value="reference">üìö Reference</option>
          </select>
        </div>
        <div class="note-form-actions">
          <button type="button" class="note-form-btn note-form-btn-secondary" id="noteCancel">Cancel</button>
          <button type="submit" class="note-form-btn note-form-btn-primary">Save Note</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Status Bar -->
  <div class="status-bar">
    <div class="status-item">
      <span class="status-label">Cubes:</span>
      <span class="status-value" id="cubeCount">0</span>
    </div>
    <div class="status-item">
      <span class="status-label">Connections:</span>
      <span class="status-value" id="connectionCount">0</span>
    </div>
    <div class="status-item">
      <span class="status-label">Mode:</span>
      <span class="status-value" id="currentMode">View</span>
    </div>
    <div class="status-item">
      <span class="status-label">Camera:</span>
      <span class="status-value" id="cameraMode">Macro</span>
    </div>
  </div>

  <!-- Help Overlay -->
  <div class="help-overlay" id="helpOverlay">
    <div class="help-content">
      <h2 class="help-title">3D Cube Notes - Help</h2>
      
      <div class="help-section">
        <h3 class="help-section-title">üéÆ Camera Controls</h3>
        <ul class="help-list">
          <li><strong>Macro View (Default):</strong> Isometric 30¬∞ angle perspective</li>
          <li><strong>Zoom:</strong> Scroll wheel or pinch gestures</li>
          <li><strong>Rotate:</strong> Click-drag or touch-swipe around pivot point</li>
          <li><strong>Auto-return:</strong> Camera gracefully returns to default 30¬∞ angle when idle</li>
          <li><strong>Micro View:</strong> Double-click cube for close-up inspection</li>
          <li><strong>Pivot Points:</strong> Canvas center by default, or around selected cube</li>
        </ul>
      </div>

      <div class="help-section">
        <h3 class="help-section-title">üîß Interaction Modes</h3>
        <ul class="help-list">
          <li><strong>View Mode:</strong> Navigate and inspect cubes freely</li>
          <li><strong>String Together:</strong> Connect cubes into sequences</li>
          <li><strong>Break Up:</strong> Separate connected cubes</li>
          <li><strong>Hold Thought:</strong> Float cubes temporarily without adding to sequences</li>
          <li><strong>Move Mode:</strong> Reposition cubes with playful physics</li>
        </ul>
      </div>

      <div class="help-section">
        <h3 class="help-section-title">‚å®Ô∏è Keyboard Shortcuts</h3>
        <div class="help-shortcuts">
          <span class="help-key">1</span><span class="help-desc">View Mode</span>
          <span class="help-key">2</span><span class="help-desc">String Together</span>
          <span class="help-key">3</span><span class="help-desc">Break Up</span>
          <span class="help-key">4</span><span class="help-desc">Hold Thought</span>
          <span class="help-key">5</span><span class="help-desc">Move Mode</span>
          <span class="help-key">Space</span><span class="help-desc">Create New Note</span>
          <span class="help-key">Double-click</span><span class="help-desc">Inspect Cube</span>
          <span class="help-key">Right-click</span><span class="help-desc">Context Menu</span>
          <span class="help-key">Esc</span><span class="help-desc">Return to Macro View</span>
        </div>
      </div>

      <div class="help-section">
        <h3 class="help-section-title">üí° Tips</h3>
        <ul class="help-list">
          <li>Use the rail toggle on the left for quick mode switching</li>
          <li>Right-click or long-press on cubes for context menu</li>
          <li>Cubes connected in "String" mode move together as a chain</li>
          <li>"Hold Thought" cubes float above the workspace temporarily</li>
          <li>Camera automatically follows selected cubes in Move mode</li>
        </ul>
      </div>

      <div class="note-form-actions">
        <button type="button" class="note-form-btn note-form-btn-primary" id="helpClose">Got it!</button>
      </div>
    </div>
  </div>

  <script>
    /*
     * ============================================
     * 3D CUBE NOTES - SPATIAL THINKING APPLICATION
     * ============================================
     * 
     * This application implements a sophisticated camera system and multiple interaction modes
     * for 3D note-taking with cube-based aesthetic.
     * 
     * CAMERA SYSTEM FEATURES:
     * - Default 30¬∞ isometric macro view with auto-return behavior
     * - Smooth micro view swooping for cube inspection
     * - Dynamic pivot points based on context
     * - Gesture-based navigation (mouse drag, touch swipe, scroll/pinch zoom)
     * 
     * INTERACTION MODES:
     * 1. View Mode: Free navigation with spatial awareness
     * 2. String Together: Connect cubes into sequences
     * 3. Break Up: Separate connected cubes
     * 4. Hold Thought: Temporarily float cubes
     * 5. Move Mode: Physics-based repositioning
     * 
     * TECHNICAL STACK: Three.js + Cannon.js + GSAP
     * READY FOR STACKBLITZ: No additional setup required
     */

    // ============================================
    // GLOBAL STATE MANAGEMENT
    // ============================================
    
    const state = {
      // Scene objects
      scene: null,
      camera: null,
      renderer: null,
      world: null,
      raycaster: null,
      mouse: null,
      
      // Collections
      cubes: [],
      connections: [],
      selectedCubes: [],
      floatingCubes: [],
      
      // Camera state
      cameraMode: 'macro', // 'macro' | 'micro'
      cameraTarget: new THREE.Vector3(0, 0, 0),
      cameraRadius: 40,
      cameraTheta: 0,
      cameraPhi: Math.PI / 6, // 30 degrees for isometric view
      cameraIdleTimer: null,
      cameraIsMoving: false,
      
      // Interaction state
      currentMode: 'view', // 'view' | 'string' | 'break' | 'float' | 'move'
      isDragging: false,
      isRotating: false,
      draggedCube: null,
      hoveredCube: null,
      inspectedCube: null,
      
      // UI state
      railExpanded: false,
      contextMenuOpen: false,
      noteModalOpen: false,
      
      // Touch state
      touchStart: { x: 0, y: 0 },
      lastTouchDistance: 0,
      
      // Constants
      CUBE_SIZE: 2,
      CONNECTION_DISTANCE: 4,
      FLOAT_HEIGHT: 8,
      MICRO_VIEW_DISTANCE: 8,
      MACRO_VIEW_DISTANCE: 40,
      AUTO_RETURN_DELAY: 3000,
      
      // Colors
      colors: {
        cube: {
          default: 0x3b82f6,
          selected: 0x60a5fa,
          connected: 0x818cf8,
          floating: 0xfbbf24,
          inspecting: 0x34d399
        },
        connection: 0x818cf8,
        grid: 0x1e293b
      }
    };

    // ============================================
    // INITIALIZATION
    // ============================================
    
    function init() {
      console.log('üöÄ Initializing 3D Cube Notes...');
      
      initScene();
      initPhysics();
      initLighting();
      createEnvironment();
      createInitialCubes();
      setupEventListeners();
      setupUI();
      
      // Start animation loop
      animate();
      
      // Show help on first load
      setTimeout(() => {
        showHelp();
      }, 1000);
      
      console.log('‚úÖ Initialization complete');
    }

    // ============================================
    // SCENE SETUP
    // ============================================
    
    function initScene() {
      // Create Three.js scene
      state.scene = new THREE.Scene();
      state.scene.background = new THREE.Color(0x0a0e1a);
      state.scene.fog = new THREE.Fog(0x0a0e1a, 50, 200);

      // Setup camera with initial isometric view
      state.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      updateCameraPosition();

      // Setup renderer
      const canvas = document.getElementById('canvas');
      state.renderer = new THREE.WebGLRenderer({ 
        canvas, 
        antialias: !isMobileDevice(),
        powerPreference: "high-performance",
        alpha: true
      });
      state.renderer.setSize(window.innerWidth, window.innerHeight);
      state.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      state.renderer.shadowMap.enabled = true;
      state.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Setup raycasting for interaction
      state.raycaster = new THREE.Raycaster();
      state.mouse = new THREE.Vector2();
    }

    function initPhysics() {
      // Initialize Cannon.js physics world
      state.world = new CANNON.World();
      state.world.gravity.set(0, -9.82, 0);
      state.world.broadphase = new CANNON.NaiveBroadphase();
      state.world.solver.iterations = 20;
      state.world.solver.tolerance = 0.001;
      
      // Create materials for playful bouncy physics
      const cubeMaterial = new CANNON.Material('cube');
      const groundMaterial = new CANNON.Material('ground');
      
      // Create contact material with bouncy settings
      const cubeGroundContact = new CANNON.ContactMaterial(
        cubeMaterial,
        groundMaterial,
        {
          friction: 0.3,
          restitution: 0.7, // High bounce
          contactEquationStiffness: 1e8,
          contactEquationRelaxation: 3
        }
      );
      
      state.world.addContactMaterial(cubeGroundContact);
      
      // Store materials for later use
      state.cubeMaterial = cubeMaterial;
      state.groundMaterial = groundMaterial;
    }

    function initLighting() {
      // Ambient lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      state.scene.add(ambientLight);

      // Main directional light with shadows
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 20, 10);
      directionalLight.castShadow = true;
      directionalLight.shadow.camera.left = -50;
      directionalLight.shadow.camera.right = 50;
      directionalLight.shadow.camera.top = 50;
      directionalLight.shadow.camera.bottom = -50;
      state.scene.add(directionalLight);

      // Accent lights for visual depth
      const accentLight1 = new THREE.PointLight(0x60a5fa, 1, 30);
      accentLight1.position.set(-20, 15, -20);
      state.scene.add(accentLight1);

      const accentLight2 = new THREE.PointLight(0x818cf8, 0.8, 25);
      accentLight2.position.set(20, 10, 20);
      state.scene.add(accentLight2);
    }

    function createEnvironment() {
      // Create ground plane
      const groundGeometry = new THREE.PlaneGeometry(100, 100);
      const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x141824,
        roughness: 0.8,
        metalness: 0.2
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -10;
      ground.receiveShadow = true;
      state.scene.add(ground);

      // Physics ground
      const groundShape = new CANNON.Plane();
      const groundBody = new CANNON.Body({ mass: 0 });
      groundBody.addShape(groundShape);
      groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
      groundBody.position.set(0, -10, 0);
      state.world.addBody(groundBody);

      // Create grid for spatial reference
      createGrid();
    }

    function createGrid() {
      const gridHelper = new THREE.GridHelper(60, 20, state.colors.grid, 0x0f172a);
      gridHelper.position.y = -9.8;
      state.scene.add(gridHelper);
    }

    // ============================================
    // CUBE MANAGEMENT
    // ============================================
    
    function createCube(position = null, noteData = null) {
      // Generate position if not provided
      if (!position) {
        position = new THREE.Vector3(
          (Math.random() - 0.5) * 20,
          Math.random() * 5,
          (Math.random() - 0.5) * 20
        );
      }

      // Create visual cube with rounded edges
      const geometry = new THREE.BoxGeometry(state.CUBE_SIZE, state.CUBE_SIZE, state.CUBE_SIZE);
      const material = new THREE.MeshPhysicalMaterial({
        color: state.colors.cube.default,
        metalness: 0.6,
        roughness: 0.3,
        clearcoat: 1.0,
        clearcoatRoughness: 0.1,
        emissive: state.colors.cube.default,
        emissiveIntensity: 0.1
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      state.scene.add(mesh);

      // Add text label to cube
      createCubeLabel(mesh, noteData?.title || 'New Note');

      // Create physics body
      const shape = new CANNON.Box(new CANNON.Vec3(state.CUBE_SIZE/2, state.CUBE_SIZE/2, state.CUBE_SIZE/2));
      const body = new CANNON.Body({ 
        mass: 2,
        material: new CANNON.Material({
          friction: 0.4,
          restitution: 0.3
        })
      });
      body.addShape(shape);
      body.position.set(position.x, position.y, position.z);
      body.linearDamping = 0.4;
      body.angularDamping = 0.4;
      state.world.addBody(body);

      // Create cube object
      const cube = {
        id: Date.now() + Math.random(),
        mesh: mesh,
        body: body,
        connections: [],
        selected: false,
        floating: false,
        note: noteData || {
          title: 'New Note',
          content: '',
          category: 'note',
          createdAt: new Date().toISOString()
        }
      };

      state.cubes.push(cube);
      updateStatusBar();
      
      return cube;
    }

    function createCubeLabel(mesh, text) {
      // Create text sprite for cube label
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 256;
      canvas.height = 64;
      
      context.fillStyle = '#ffffff';
      context.font = 'bold 20px Inter';
      context.textAlign = 'center';
      context.fillText(text.substring(0, 20), 128, 40);
      
      const texture = new THREE.CanvasTexture(canvas);
      const spriteMaterial = new THREE.SpriteMaterial({ 
        map: texture,
        transparent: true,
        alphaTest: 0.1
      });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.scale.set(4, 1, 1);
      sprite.position.y = state.CUBE_SIZE + 1;
      
      mesh.add(sprite);
    }

    function createInitialCubes() {
      // Create some initial cubes for demonstration
      const initialNotes = [
        { title: 'Welcome!', content: 'Start creating your 3D notes', category: 'note' },
        { title: 'Idea', content: 'Double-click to inspect', category: 'idea' },
        { title: 'Task', content: 'Try different interaction modes', category: 'task' }
      ];

      initialNotes.forEach((noteData, index) => {
        const position = new THREE.Vector3(
          (index - 1) * 6,
          0,
          0
        );
        createCube(position, noteData);
      });
    }

    // ============================================
    // CAMERA SYSTEM
    // ============================================
    
    function updateCameraPosition() {
      const { cameraTarget, cameraRadius, cameraTheta, cameraPhi } = state;
      
      const x = cameraRadius * Math.sin(cameraPhi) * Math.cos(cameraTheta);
      const y = cameraRadius * Math.cos(cameraPhi);
      const z = cameraRadius * Math.sin(cameraPhi) * Math.sin(cameraTheta);
      
      state.camera.position.set(x, y, z);
      state.camera.lookAt(cameraTarget);
    }

    function setCameraMode(mode, targetCube = null) {
      const previousMode = state.cameraMode;
      state.cameraMode = mode;
      
      if (mode === 'micro' && targetCube) {
        // Swoop in for close-up inspection
        state.inspectedCube = targetCube;
        const targetPos = targetCube.mesh.position.clone();
        
        // Move camera target to cube
        gsap.to(state.cameraTarget, {
          x: targetPos.x,
          y: targetPos.y,
          z: targetPos.z,
          duration: 0.8,
          ease: "power2.inOut"
        });
        
        // Move camera closer
        gsap.to(state, {
          cameraRadius: state.MICRO_VIEW_DISTANCE,
          cameraPhi: Math.PI / 3, // Steeper angle for inspection
          duration: 0.8,
          ease: "power2.inOut",
          onUpdate: updateCameraPosition,
          onComplete: () => {
            showCameraIndicator('Micro View - Inspecting');
          }
        });
        
        // Highlight inspected cube
        highlightCube(targetCube, state.colors.cube.inspecting);
        
      } else if (mode === 'macro') {
        // Return to macro view
        state.inspectedCube = null;
        
        // Reset camera target to origin
        gsap.to(state.cameraTarget, {
          x: 0,
          y: 0,
          z: 0,
          duration: 0.8,
          ease: "power2.inOut"
        });
        
        // Return to isometric position
        gsap.to(state, {
          cameraRadius: state.MACRO_VIEW_DISTANCE,
          cameraPhi: Math.PI / 6, // 30 degrees isometric
          duration: 0.8,
          ease: "power2.inOut",
          onUpdate: updateCameraPosition,
          onComplete: () => {
            showCameraIndicator('Macro View - Isometric');
            startCameraIdleTimer();
          }
        });
        
        // Remove highlight from previously inspected cube
        if (targetCube) {
          resetCubeColor(targetCube);
        }
      }
      
      updateStatusBar();
    }

    function startCameraIdleTimer() {
      // Clear existing timer
      if (state.cameraIdleTimer) {
        clearTimeout(state.cameraIdleTimer);
      }
      
      // Set new timer to return to default position
      state.cameraIdleTimer = setTimeout(() => {
        if (state.cameraMode === 'macro' && !state.cameraIsMoving) {
          // Smoothly return to default isometric position
          gsap.to(state, {
            cameraTheta: 0,
            cameraPhi: Math.PI / 6,
            duration: 2,
            ease: "power2.inOut",
            onUpdate: updateCameraPosition
          });
        }
      }, state.AUTO_RETURN_DELAY);
    }

    function rotateCamera(deltaX, deltaY) {
      state.cameraTheta -= deltaX * 0.01;
      state.cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, state.cameraPhi + deltaY * 0.01));
      updateCameraPosition();
      resetCameraIdleTimer();
    }

    function zoomCamera(delta) {
      const newRadius = Math.max(10, Math.min(100, state.cameraRadius + delta));
      state.cameraRadius = newRadius;
      updateCameraPosition();
      resetCameraIdleTimer();
    }

    function resetCameraIdleTimer() {
      if (state.cameraIdleTimer) {
        clearTimeout(state.cameraIdleTimer);
      }
      startCameraIdleTimer();
    }

    function showCameraIndicator(text) {
      const indicator = document.getElementById('cameraIndicator');
      indicator.textContent = text;
      indicator.classList.add('visible');
      
      setTimeout(() => {
        indicator.classList.remove('visible');
      }, 2000);
    }

    // ============================================
    // INTERACTION MODES
    // ============================================
    
    function setInteractionMode(mode) {
      state.currentMode = mode;
      
      // Update UI
      document.querySelectorAll('.rail-item, .mode-option').forEach(item => {
        item.classList.remove('active');
        if (item.dataset.mode === mode) {
          item.classList.add('active');
        }
      });
      
      // Clear selection when switching modes
      clearSelection();
      
      // Mode-specific setup
      switch (mode) {
        case 'view':
          document.getElementById('canvas').style.cursor = 'grab';
          break;
        case 'string':
          document.getElementById('canvas').style.cursor = 'crosshair';
          break;
        case 'break':
          document.getElementById('canvas').style.cursor = 'not-allowed';
          break;
        case 'float':
          document.getElementById('canvas').style.cursor = 'grab';
          break;
        case 'move':
          document.getElementById('canvas').style.cursor = 'move';
          break;
      }
      
      updateStatusBar();
      console.log(`üîÑ Mode changed to: ${mode}`);
    }

    function handleCubeInteraction(cube, event) {
      switch (state.currentMode) {
        case 'view':
          handleViewMode(cube, event);
          break;
        case 'string':
          handleStringMode(cube, event);
          break;
        case 'break':
          handleBreakMode(cube, event);
          break;
        case 'float':
          handleFloatMode(cube, event);
          break;
        case 'move':
          handleMoveMode(cube, event);
          break;
      }
    }

    function handleViewMode(cube, event) {
      if (event.shiftKey) {
        // Multi-select with shift
        toggleCubeSelection(cube);
      } else {
        // Single select
        clearSelection();
        selectCube(cube);
      }
    }

    function handleStringMode(cube, event) {
      if (state.selectedCubes.length === 0) {
        selectCube(cube);
      } else {
        // Connect to last selected cube
        const lastSelected = state.selectedCubes[state.selectedCubes.length - 1];
        if (lastSelected !== cube) {
          createConnection(lastSelected, cube);
        }
        selectCube(cube);
      }
    }

    function handleBreakMode(cube, event) {
      // Break all connections for this cube
      const connectionsToBreak = [...cube.connections];
      connectionsToBreak.forEach(connection => {
        breakConnection(connection);
      });
      
      // Visual feedback
      gsap.to(cube.mesh.scale, {
        x: 0.8, y: 0.8, z: 0.8,
        duration: 0.1,
        yoyo: true,
        repeat: 1
      });
    }

    function handleFloatMode(cube, event) {
      if (cube.floating) {
        // Stop floating
        stopFloating(cube);
      } else {
        // Start floating
        startFloating(cube);
      }
    }

    function handleMoveMode(cube, event) {
      selectCube(cube);
      state.draggedCube = cube;
      state.isDragging = true;
      
      // Update camera pivot to follow selected cube
      updateCameraPivot(cube.mesh.position);
    }

    // ============================================
    // CONNECTION SYSTEM
    // ============================================
    
    function createConnection(cube1, cube2) {
      // Check if connection already exists
      const existingConnection = state.connections.find(conn => 
        (conn.cube1 === cube1 && conn.cube2 === cube2) ||
        (conn.cube1 === cube2 && conn.cube2 === cube1)
      );
      
      if (existingConnection) return null;

      // Create physics constraint
      const constraint = new CANNON.PointToPointConstraint(
        cube1.body,
        new CANNON.Vec3(state.CUBE_SIZE/2, 0, 0),
        cube2.body,
        new CANNON.Vec3(-state.CUBE_SIZE/2, 0, 0)
      );
      state.world.addConstraint(constraint);

      // Create visual connection line
      const lineGeometry = new THREE.BufferGeometry().setFromPoints([
        cube1.mesh.position,
        cube2.mesh.position
      ]);
      const lineMaterial = new THREE.LineBasicMaterial({ 
        color: state.colors.connection,
        linewidth: 3,
        transparent: true,
        opacity: 0.6
      });
      const line = new THREE.Line(lineGeometry, lineMaterial);
      state.scene.add(line);

      // Connection object
      const connection = {
        id: Date.now() + Math.random(),
        cube1: cube1,
        cube2: cube2,
        constraint: constraint,
        line: line,
        active: true
      };

      state.connections.push(connection);
      cube1.connections.push(connection);
      cube2.connections.push(connection);

      // Update cube colors to show connection
      updateCubeColor(cube1, state.colors.cube.connected);
      updateCubeColor(cube2, state.colors.cube.connected);

      // Visual feedback
      createConnectionEffect(cube1.mesh.position, cube2.mesh.position);
      updateStatusBar();
      
      return connection;
    }

    function breakConnection(connection) {
      if (!connection.active) return;

      // Remove physics constraint
      state.world.removeConstraint(connection.constraint);

      // Remove visual line
      state.scene.remove(connection.line);

      // Update cube connections
      connection.cube1.connections = connection.cube1.connections.filter(c => c !== connection);
      connection.cube2.connections = connection.cube2.connections.filter(c => c !== connection);

      // Reset cube colors if no more connections
      if (connection.cube1.connections.length === 0) {
        resetCubeColor(connection.cube1);
      }
      if (connection.cube2.connections.length === 0) {
        resetCubeColor(connection.cube2);
      }

      // Mark as inactive and remove
      connection.active = false;
      state.connections = state.connections.filter(c => c !== connection);

      updateStatusBar();
    }

    function updateConnectionLines() {
      state.connections.forEach(connection => {
        if (!connection.active) return;
        
        const positions = connection.line.geometry.attributes.position;
        positions.array[0] = connection.cube1.mesh.position.x;
        positions.array[1] = connection.cube1.mesh.position.y;
        positions.array[2] = connection.cube1.mesh.position.z;
        positions.array[3] = connection.cube2.mesh.position.x;
        positions.array[4] = connection.cube2.mesh.position.y;
        positions.array[5] = connection.cube2.mesh.position.z;
        positions.needsUpdate = true;
      });
    }

    // ============================================
    // FLOATING SYSTEM
    // ============================================
    
    function startFloating(cube) {
      if (cube.floating) return;
      
      cube.floating = true;
      state.floatingCubes.push(cube);
      
      // Disable physics for floating cube
      state.world.removeBody(cube.body);
      
      // Animate to floating height
      const targetY = state.FLOAT_HEIGHT + Math.random() * 4;
      gsap.to(cube.mesh.position, {
        y: targetY,
        duration: 1,
        ease: "power2.out"
      });
      
      // Add gentle floating animation
      gsap.to(cube.mesh.rotation, {
        y: Math.PI * 2,
        duration: 8,
        ease: "none",
        repeat: -1
      });
      
      // Update cube color
      updateCubeColor(cube, state.colors.cube.floating);
      
      updateStatusBar();
    }

    function stopFloating(cube) {
      if (!cube.floating) return;
      
      cube.floating = false;
      state.floatingCubes = state.floatingCubes.filter(c => c !== cube);
      
      // Re-enable physics
      state.world.addBody(cube.body);
      cube.body.position.copy(cube.mesh.position);
      cube.body.velocity.set(0, -5, 0); // Small downward velocity
      
      // Stop floating animation
      gsap.killTweensOf(cube.mesh.rotation);
      
      // Update cube color
      if (cube.connections.length > 0) {
        updateCubeColor(cube, state.colors.cube.connected);
      } else {
        resetCubeColor(cube);
      }
      
      updateStatusBar();
    }

    // ============================================
    // SELECTION SYSTEM
    // ============================================
    
    function selectCube(cube) {
      if (!cube.selected) {
        cube.selected = true;
        state.selectedCubes.push(cube);
        updateCubeAppearance(cube);
      }
    }

    function toggleCubeSelection(cube) {
      if (cube.selected) {
        deselectCube(cube);
      } else {
        selectCube(cube);
      }
    }

    function deselectCube(cube) {
      cube.selected = false;
      state.selectedCubes = state.selectedCubes.filter(c => c !== cube);
      updateCubeAppearance(cube);
    }

    function clearSelection() {
      state.selectedCubes.forEach(cube => {
        cube.selected = false;
        updateCubeAppearance(cube);
      });
      state.selectedCubes = [];
    }

    function updateCubeAppearance(cube) {
      if (cube.selected) {
        updateCubeColor(cube, state.colors.cube.selected);
        
        // Scale up selected cubes
        gsap.to(cube.mesh.scale, {
          x: 1.1, y: 1.1, z: 1.1,
          duration: 0.2,
          ease: "back.out"
        });
      } else {
        // Reset color based on state
        if (cube.connections.length > 0) {
          updateCubeColor(cube, state.colors.cube.connected);
        } else if (cube.floating) {
          updateCubeColor(cube, state.colors.cube.floating);
        } else {
          resetCubeColor(cube);
        }
        
        // Scale back to normal
        gsap.to(cube.mesh.scale, {
          x: 1, y: 1, z: 1,
          duration: 0.2,
          ease: "power2.out"
        });
      }
    }

    function updateCubeColor(cube, color) {
      cube.mesh.material.color.setHex(color);
      cube.mesh.material.emissive.setHex(color);
    }

    function resetCubeColor(cube) {
      updateCubeColor(cube, state.colors.cube.default);
    }

    function highlightCube(cube, color) {
      gsap.to(cube.mesh.material.color, {
        r: ((color >> 16) & 255) / 255,
        g: ((color >> 8) & 255) / 255,
        b: (color & 255) / 255,
        duration: 0.3
      });
    }

    // ============================================
    // CAMERA PIVOT SYSTEM
    // ============================================
    
    function updateCameraPivot(position) {
      // Smoothly transition camera target to new pivot
      gsap.to(state.cameraTarget, {
        x: position.x,
        y: position.y,
        z: position.z,
        duration: 0.5,
        ease: "power2.inOut"
      });
    }

    // ============================================
    // VISUAL EFFECTS
    // ============================================
    
    function createConnectionEffect(pos1, pos2) {
      const midPoint = new THREE.Vector3().addVectors(pos1, pos2).multiplyScalar(0.5);
      
      const particleGeometry = new THREE.SphereGeometry(0.3, 8, 8);
      const particleMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x818cf8,
        transparent: true,
        opacity: 1
      });
      const particle = new THREE.Mesh(particleGeometry, particleMaterial);
      particle.position.copy(midPoint);
      state.scene.add(particle);

      gsap.to(particle.scale, {
        x: 3, y: 3, z: 3,
        duration: 0.5,
        ease: "power2.out"
      });
      gsap.to(particleMaterial, {
        opacity: 0,
        duration: 0.5,
        ease: "power2.out",
        onComplete: () => {
          state.scene.remove(particle);
        }
      });
    }

    // ============================================
    // UI SYSTEM
    // ============================================
    
    function setupUI() {
      // Setup rail toggle
      const railToggle = document.getElementById('railToggle');
      
      // Rail item clicks
      document.querySelectorAll('.rail-item').forEach(item => {
        item.addEventListener('click', () => {
          const mode = item.dataset.mode;
          setInteractionMode(mode);
          toggleRail();
        });
      });
      
      // Mode panel clicks
      document.querySelectorAll('.mode-option').forEach(option => {
        option.addEventListener('click', () => {
          const mode = option.dataset.mode;
          setInteractionMode(mode);
        });
      });
      
      // Floating action button
      document.getElementById('fabButton').addEventListener('click', () => {
        createCube();
        setInteractionMode('view');
      });
      
      // Note modal
      setupNoteModal();
      
      // Context menu
      setupContextMenu();
      
      // Help overlay
      setupHelp();
      
      // Initial mode
      setInteractionMode('view');
    }

    function toggleRail() {
      const railToggle = document.getElementById('railToggle');
      state.railExpanded = !state.railExpanded;
      
      if (state.railExpanded) {
        railToggle.classList.add('active');
      } else {
        railToggle.classList.remove('active');
      }
    }

    function setupNoteModal() {
      const modal = document.getElementById('noteModal');
      const form = document.getElementById('noteForm');
      
      document.getElementById('noteModalClose').addEventListener('click', () => {
        closeNoteModal();
      });
      
      document.getElementById('noteCancel').addEventListener('click', () => {
        closeNoteModal();
      });
      
      form.addEventListener('submit', (e) => {
        e.preventDefault();
        saveNoteFromModal();
      });
      
      // Close on background click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          closeNoteModal();
        }
      });
    }

    function openNoteModal(cube) {
      const modal = document.getElementById('noteModal');
      const form = document.getElementById('noteForm');
      
      // Populate form with cube data
      document.getElementById('noteTitle').value = cube.note.title;
      document.getElementById('noteContent').value = cube.note.content;
      document.getElementById('noteCategory').value = cube.note.category;
      
      // Store current cube for saving
      modal.dataset.cubeId = cube.id;
      
      modal.classList.add('visible');
      state.noteModalOpen = true;
    }

    function closeNoteModal() {
      const modal = document.getElementById('noteModal');
      modal.classList.remove('visible');
      state.noteModalOpen = false;
    }

    function saveNoteFromModal() {
      const modal = document.getElementById('noteModal');
      const cubeId = modal.dataset.cubeId;
      const cube = state.cubes.find(c => c.id == cubeId);
      
      if (cube) {
        cube.note.title = document.getElementById('noteTitle').value;
        cube.note.content = document.getElementById('noteContent').value;
        cube.note.category = document.getElementById('noteCategory').value;
        
        // Update cube label
        createCubeLabel(cube.mesh, cube.note.title);
      }
      
      closeNoteModal();
    }

    function setupContextMenu() {
      const contextMenu = document.getElementById('contextMenu');
      
      document.querySelectorAll('.context-item').forEach(item => {
        item.addEventListener('click', () => {
          const action = item.dataset.action;
          handleContextAction(action);
          hideContextMenu();
        });
      });
      
      // Hide on background click
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.context-menu')) {
          hideContextMenu();
        }
      });
    }

    function showContextMenu(x, y, cube) {
      const contextMenu = document.getElementById('contextMenu');
      contextMenu.style.left = x + 'px';
      contextMenu.style.top = y + 'px';
      contextMenu.dataset.cubeId = cube.id;
      contextMenu.classList.add('visible');
      state.contextMenuOpen = true;
    }

    function hideContextMenu() {
      const contextMenu = document.getElementById('contextMenu');
      contextMenu.classList.remove('visible');
      state.contextMenuOpen = false;
    }

    function handleContextAction(action) {
      const contextMenu = document.getElementById('contextMenu');
      const cubeId = contextMenu.dataset.cubeId;
      const cube = state.cubes.find(c => c.id == cubeId);
      
      if (!cube) return;
      
      switch (action) {
        case 'edit':
          openNoteModal(cube);
          break;
        case 'duplicate':
          const newPosition = cube.mesh.position.clone();
          newPosition.x += 3;
          const newCube = createCube(newPosition, { ...cube.note });
          newCube.note.title = cube.note.title + ' (copy)';
          createCubeLabel(newCube.mesh, newCube.note.title);
          break;
        case 'float':
          handleFloatMode(cube, {});
          break;
        case 'connect':
          setInteractionMode('string');
          selectCube(cube);
          break;
        case 'delete':
          deleteCube(cube);
          break;
      }
    }

    function deleteCube(cube) {
      // Break all connections
      const connectionsToBreak = [...cube.connections];
      connectionsToBreak.forEach(connection => {
        breakConnection(connection);
      });
      
      // Remove from scene and physics
      state.scene.remove(cube.mesh);
      if (!cube.floating) {
        state.world.removeBody(cube.body);
      }
      
      // Remove from arrays
      state.cubes = state.cubes.filter(c => c !== cube);
      state.selectedCubes = state.selectedCubes.filter(c => c !== cube);
      state.floatingCubes = state.floatingCubes.filter(c => c !== cube);
      
      updateStatusBar();
    }

    function setupHelp() {
      document.getElementById('helpClose').addEventListener('click', () => {
        hideHelp();
      });
      
      document.getElementById('helpOverlay').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) {
          hideHelp();
        }
      });
    }

    function showHelp() {
      const helpOverlay = document.getElementById('helpOverlay');
      helpOverlay.classList.add('visible');
    }

    function hideHelp() {
      const helpOverlay = document.getElementById('helpOverlay');
      helpOverlay.classList.remove('visible');
    }

    function updateStatusBar() {
      document.getElementById('cubeCount').textContent = state.cubes.length;
      document.getElementById('connectionCount').textContent = state.connections.filter(c => c.active).length;
      document.getElementById('currentMode').textContent = state.currentMode.charAt(0).toUpperCase() + state.currentMode.slice(1);
      document.getElementById('cameraMode').textContent = state.cameraMode.charAt(0).toUpperCase() + state.cameraMode.slice(1);
    }

    // ============================================
    // EVENT LISTENERS
    // ============================================
    
    function setupEventListeners() {
      const canvas = document.getElementById('canvas');
      
      // Mouse events
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      canvas.addEventListener('wheel', onMouseWheel);
      canvas.addEventListener('dblclick', onDoubleClick);
      canvas.addEventListener('contextmenu', onRightClick);
      
      // Touch events
      canvas.addEventListener('touchstart', onTouchStart);
      canvas.addEventListener('touchmove', onTouchMove);
      canvas.addEventListener('touchend', onTouchEnd);
      
      // Window events
      window.addEventListener('resize', onWindowResize);
      
      // Keyboard events
      document.addEventListener('keydown', onKeyDown);
    }

    function onMouseDown(event) {
      if (event.button === 2) {
        // Right mouse - camera rotation
        state.isRotating = true;
        canvas.style.cursor = 'grabbing';
        return;
      }
      
      // Raycast for cube selection
      updateMousePosition(event.clientX, event.clientY);
      const intersectedCube = getIntersectedCube();
      
      if (intersectedCube) {
        handleCubeInteraction(intersectedCube, event);
      } else if (state.currentMode === 'view') {
        // Start camera rotation
        state.isRotating = true;
        canvas.style.cursor = 'grabbing';
      }
      
      state.previousMousePosition = { x: event.clientX, y: event.clientY };
    }

    function onMouseMove(event) {
      updateMousePosition(event.clientX, event.clientY);
      
      if (state.isRotating) {
        const deltaX = event.clientX - state.previousMousePosition.x;
        const deltaY = event.clientY - state.previousMousePosition.y;
        
        rotateCamera(deltaX, deltaY);
        
        state.previousMousePosition = { x: event.clientX, y: event.clientY };
      } else if (state.isDragging && state.draggedCube && state.currentMode === 'move') {
        // Drag selected cube in move mode
        const planeIntersect = getPlaneIntersection(event);
        if (planeIntersect) {
          const force = planeIntersect.sub(state.draggedCube.mesh.position);
          force.multiplyScalar(15);
          state.draggedCube.body.wakeUp();
          state.draggedCube.body.applyForce(force, state.draggedCube.body.position);
          
          // Update camera pivot to follow dragged cube
          updateCameraPivot(state.draggedCube.mesh.position);
        }
      } else {
        // Hover detection
        const hoveredCube = getIntersectedCube();
        if (hoveredCube && hoveredCube !== state.hoveredCube) {
          state.hoveredCube = hoveredCube;
          
          // Update cursor based on mode
          if (state.currentMode === 'view' || state.currentMode === 'move') {
            canvas.style.cursor = 'pointer';
          }
        } else if (!hoveredCube && state.hoveredCube) {
          state.hoveredCube = null;
          if (state.currentMode === 'view' || state.currentMode === 'move') {
            canvas.style.cursor = 'grab';
          }
        }
      }
    }

    function onMouseUp(event) {
      state.isRotating = false;
      state.isDragging = false;
      state.draggedCube = null;
      
      if (state.currentMode === 'view' || state.currentMode === 'move') {
        canvas.style.cursor = 'grab';
      }
    }

    function onMouseWheel(event) {
      event.preventDefault();
      const delta = event.deltaY * 0.01;
      zoomCamera(delta);
    }

    function onDoubleClick(event) {
      const intersectedCube = getIntersectedCube();
      if (intersectedCube) {
        // Enter micro view for inspection
        setCameraMode('micro', intersectedCube);
      }
    }

    function onRightClick(event) {
      event.preventDefault();
      
      const intersectedCube = getIntersectedCube();
      if (intersectedCube) {
        showContextMenu(event.clientX, event.clientY, intersectedCube);
      }
    }

    function onTouchStart(event) {
      if (event.touches.length === 1) {
        const touch = event.touches[0];
        state.touchStart = { x: touch.clientX, y: touch.clientY };
        
        // Simulate mouse down
        updateMousePosition(touch.clientX, touch.clientY);
        const intersectedCube = getIntersectedCube();
        
        if (intersectedCube) {
          handleCubeInteraction(intersectedCube, event);
        }
      } else if (event.touches.length === 2) {
        // Pinch zoom start
        const touch1 = event.touches[0];
        const touch2 = event.touches[1];
        state.lastTouchDistance = Math.hypot(
          touch2.clientX - touch1.clientX,
          touch2.clientY - touch1.clientY
        );
      }
    }

    function onTouchMove(event) {
      if (event.touches.length === 1) {
        event.preventDefault();
        const touch = event.touches[0];
        
        // Simulate mouse move for camera rotation
        const deltaX = touch.clientX - state.touchStart.x;
        const deltaY = touch.clientY - state.touchStart.y;
        
        if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
          rotateCamera(deltaX * 0.5, deltaY * 0.5);
          state.touchStart = { x: touch.clientX, y: touch.clientY };
        }
      } else if (event.touches.length === 2) {
        event.preventDefault();
        
        // Pinch zoom
        const touch1 = event.touches[0];
        const touch2 = event.touches[1];
        const currentDistance = Math.hypot(
          touch2.clientX - touch1.clientX,
          touch2.clientY - touch1.clientY
        );
        
        if (state.lastTouchDistance > 0) {
          const delta = (currentDistance - state.lastTouchDistance) * 0.01;
          zoomCamera(-delta);
        }
        
        state.lastTouchDistance = currentDistance;
      }
    }

    function onTouchEnd(event) {
      state.lastTouchDistance = 0;
    }

    function onWindowResize() {
      state.camera.aspect = window.innerWidth / window.innerHeight;
      state.camera.updateProjectionMatrix();
      state.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(event) {
      // Mode shortcuts
      switch (event.key) {
        case '1':
          setInteractionMode('view');
          break;
        case '2':
          setInteractionMode('string');
          break;
        case '3':
          setInteractionMode('break');
          break;
        case '4':
          setInteractionMode('float');
          break;
        case '5':
          setInteractionMode('move');
          break;
        case ' ':
          event.preventDefault();
          createCube();
          break;
        case 'Escape':
          setCameraMode('macro');
          clearSelection();
          hideContextMenu();
          closeNoteModal();
          break;
        case 'h':
        case 'H':
          showHelp();
          break;
      }
    }

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================
    
    function updateMousePosition(clientX, clientY) {
      state.mouse.x = (clientX / window.innerWidth) * 2 - 1;
      state.mouse.y = -(clientY / window.innerHeight) * 2 + 1;
    }

    function getIntersectedCube() {
      state.raycaster.setFromCamera(state.mouse, state.camera);
      const intersects = state.raycaster.intersectObjects(state.cubes.map(c => c.mesh));
      
      if (intersects.length > 0) {
        return state.cubes.find(c => c.mesh === intersects[0].object);
      }
      return null;
    }

    function getPlaneIntersection(event) {
      updateMousePosition(event.clientX, event.clientY);
      state.raycaster.setFromCamera(state.mouse, state.camera);
      
      // Create invisible plane for intersection
      const planeGeometry = new THREE.PlaneGeometry(100, 100);
      const planeMaterial = new THREE.MeshBasicMaterial({ visible: false });
      const plane = new THREE.Mesh(planeGeometry, planeMaterial);
      plane.rotation.x = -Math.PI / 2;
      plane.position.y = -5;
      
      const intersects = state.raycaster.intersectObject(plane);
      
      if (intersects.length > 0) {
        return intersects[0].point;
      }
      return null;
    }

    function isMobileDevice() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    // ============================================
    // ANIMATION LOOP
    // ============================================
    
    function animate() {
      requestAnimationFrame(animate);
      
      // Step physics world
      state.world.step(1/60);
      
      // Update visual positions from physics
      state.cubes.forEach(cube => {
        if (!cube.floating) {
          cube.mesh.position.copy(cube.body.position);
          cube.mesh.quaternion.copy(cube.body.quaternion);
        }
      });
      
      // Update connection lines
      updateConnectionLines();
      
      // Render scene
      state.renderer.render(state.scene, state.camera);
    }

    // ============================================
    // START APPLICATION
    // ============================================
    
    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
