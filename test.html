<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1.0,user-scalable=no,viewport-fit=cover" />
  <title>i n t o v i e w : N.O.D.E.</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-color: #050505;
      --card-bg: #111111;
      --ink: #ffffff;
      --ink-dim: #888888;
      --accent: #FFED29;
      
      --neon-green: #22c55e;
      --neon-orange: #f97316;
      --neon-red: #ef4444;
      --neon-blue: #3b82f6;
      
      --glass-bg: rgba(20, 20, 20, 0.85);
      --glass-border: rgba(255, 255, 255, 0.1);
      --glass-blur: 16px;
      
      --nav-height: 80px;
      --header-height: 100px;
      --font-mono: 'JetBrains Mono', monospace;
      --font-sans: 'Inter', sans-serif;
    }

    [data-theme="light"] {
      --bg-color: #f0f0f0;
      --card-bg: #ffffff;
      --ink: #111111;
      --ink-dim: #666666;
      --glass-bg: rgba(255, 255, 255, 0.9);
      --glass-border: rgba(0, 0, 0, 0.1);
    }

    * { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
    html, body { height: 100%; font-family: var(--font-sans); background: var(--bg-color); color: var(--ink); overflow: hidden; }

    /* --- Custom Scrollbar Design --- */
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--glass-border); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--ink-dim); }

    /* --- Typography & Utilities --- */
    .text-green { color: var(--neon-green); }
    .text-orange { color: var(--neon-orange); }
    .text-red { color: var(--neon-red); }
    .text-blue { color: var(--neon-blue); }
    
    /* --- Layout Structure --- */
    .app-header {
      position: fixed; top: 0; left: 0; right: 0; height: var(--header-height);
      display: flex; flex-direction: column; justify-content: center;
      padding: 10px 0; z-index: 100;
      background: linear-gradient(to bottom, var(--bg-color) 40%, transparent);
      pointer-events: none;
    }
    .header-top { 
        display: flex; justify-content: space-between; align-items: center; 
        padding: 0 20px; width: 100%; pointer-events: auto; 
    }
    
    /* Logo Styling */
    .logo { 
        display: flex; align-items: center; height: 32px; 
    }
    /* Logo Image Sizing */
    .logo img {
        height: 32px; /* Enforce size for the SVG */
        width: auto;
    }

    /* Text Logo Fallback */
    .logo-text {
      font-family: var(--font-mono);
      font-weight: 800;
      font-size: 20px;
      letter-spacing: -1px;
      color: var(--ink);
      display: flex; align-items: center; gap: 8px;
    }
    .logo-dot { width: 8px; height: 8px; background: var(--accent); border-radius: 50%; box-shadow: 0 0 10px var(--accent); }

    .header-buttons { display: flex; align-items: center; gap: 8px; margin-left: auto; }

    .theme-btn {
        background: transparent; border: none; color: var(--ink-dim);
        cursor: pointer; padding: 8px; border-radius: 50%; display: flex; align-items: center;
    }
    .theme-btn:active { background: var(--glass-border); color: var(--ink); }

    /* --- Provider Toggle Bar --- */
    .provider-bar {
      display: flex; gap: 8px; overflow-x: auto; padding: 10px 20px;
      pointer-events: auto; scrollbar-width: none;
      justify-content: flex-start; 
    }
    .provider-bar::-webkit-scrollbar { display: none; }
    
    .pill {
      padding: 4px 12px; border-radius: 20px; font-size: 11px; font-weight: 600;
      background: var(--glass-bg); border: 1px solid var(--glass-border);
      color: var(--ink-dim); white-space: nowrap; cursor: pointer; transition: all 0.2s;
      flex-shrink: 0; 
    }
    .pill.active { background: var(--ink); color: var(--bg-color); border-color: var(--ink); }
    .pill.add-btn { border-style: dashed; }

    .view-container {
      position: absolute; inset: 0;
      top: var(--header-height); bottom: 0;
      overflow: hidden; opacity: 0; pointer-events: none;
      transition: opacity 0.3s ease;
    }
    .view-container.active { opacity: 1; pointer-events: auto; }

    /* --- Grid View --- */
    #gridContainer { overflow-y: auto; padding: 10px 16px 120px 16px; }
    .grid-wrapper {
      display: grid; 
      grid-template-columns: 1fr; 
      gap: 16px; 
      padding-bottom: 40px;
    }
    @media(min-width: 600px) { .grid-wrapper { grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); } }

    .card {
      background: var(--card-bg);
      border: 1px solid var(--glass-border);
      border-radius: 16px;
      padding: 20px;
      position: relative;
      display: flex; flex-direction: column; gap: 12px;
      transition: transform 0.2s, background 0.2s;
      cursor: pointer; /* Clickable */
    }
    .card:active { transform: scale(0.98); background: var(--glass-border); }

    .card-top { display: flex; justify-content: space-between; align-items: center; }
    .card-provider { font-weight: 600; font-size: 14px; opacity: 0.8; text-transform: uppercase; letter-spacing: 1px; }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; box-shadow: 0 0 8px currentColor; animation: pulse 1.5s infinite ease-in-out; }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 8px currentColor; }
      50% { box-shadow: 0 0 16px currentColor; }
    }

    /* Edit Icon Style */
    .card-edit-icon {
      color: var(--ink-dim); padding: 4px; border-radius: 4px;
      transition: color 0.2s, background 0.2s;
      margin-left: 8px;
    }
    .card-edit-icon:hover { color: var(--ink); background: rgba(255,255,255,0.1); }

    .card-timer {
      font-family: var(--font-mono);
      font-size: 2.4rem;
      font-weight: 700;
      text-align: center;
      letter-spacing: -1px;
      margin: 8px 0;
      position: relative;
    }

    .card-meta { display: flex; justify-content: space-between; align-items: center; font-size: 12px; color: var(--ink-dim); border-top: 1px solid var(--glass-border); padding-top: 12px; }
    .card-email { font-family: var(--font-mono); opacity: 0.8; }
    
    .card-actions { display: flex; gap: 8px; }
    .action-icon { 
      width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; 
      border-radius: 6px; background: rgba(255,255,255,0.05); cursor: pointer;
      color: var(--ink-dim); transition: 0.2s;
    }
    .action-icon:hover { background: var(--accent); color: #000; }

    .card.burnt, .scatter-card.burnt {
      opacity: 0.6;
    }

    .card.burnt .card-edit-icon, .scatter-card.burnt .card-edit-icon {
      opacity: 1;
    }

    .burnt-label {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(-45deg);
      font-family: var(--font-mono);
      font-size: 1.8rem;
      font-weight: 700;
      color: var(--neon-red);
      opacity: 0.7;
      pointer-events: none;
    }

    .scatter-card .burnt-label {
      font-size: 1.2rem;
    }

    /* --- Scatter View --- */
    #scatterContainer { 
        overflow: hidden; 
        background-image: radial-gradient(var(--glass-border) 1px, transparent 1px);
        background-size: 40px 40px;
    }
    .scatter-canvas { 
        width: 100%; height: 100%; position: relative; 
        will-change: transform; 
        touch-action: none; 
    }
    .scatter-card {
      position: absolute;
      width: 220px;
      background: var(--card-bg);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      display: flex; flex-direction: column; align-items: center;
      user-select: none;
      transition: box-shadow 0.2s;
      cursor: pointer;
    }
    .scatter-card.is-dragging {
        box-shadow: 0 20px 50px rgba(0,0,0,0.6);
        z-index: 1000 !important;
        cursor: grabbing;
    }
    .scatter-card .card-timer { font-size: 1.4rem; margin: 4px 0; position: relative; }
    .scatter-card .card-provider { font-size: 11px; }
    .scatter-card .card-meta { 
        display: block; 
        text-align: center; 
        font-size: 11px; 
        color: var(--ink-dim); 
        margin-top: 8px; 
        border-top: 1px solid var(--glass-border); 
        padding-top: 8px; 
        width: 100%; 
    }

    /* --- Bottom Navigation (Dock) --- */
    .bottom-nav {
      position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
      width: 92%; max-width: 400px;
      height: 64px;
      background: var(--glass-bg);
      backdrop-filter: blur(var(--glass-blur));
      border: 1px solid var(--glass-border);
      border-radius: 32px;
      display: flex; justify-content: space-between; align-items: center;
      padding: 0 8px 0 16px; 
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
      z-index: 200;
    }

    .nav-group { display: flex; align-items: center; gap: 4px; }
    
    .nav-btn {
      width: 48px; height: 48px;
      border-radius: 50%;
      border: none; background: transparent;
      color: var(--ink-dim);
      font-size: 20px;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    .nav-btn.active { color: var(--ink); background: rgba(255,255,255,0.1); }
    .nav-btn.primary { background: var(--accent); color: #000; transform: scale(1.1); box-shadow: 0 0 15px var(--accent); }
    .nav-btn.primary:active { transform: scale(1.0); }

    .filter-pill-btn {
        background: var(--glass-border);
        height: 40px;
        width: 120px;
        padding: 0 16px;
        border-radius: 20px;
        border: 1px solid var(--glass-border);
        color: var(--ink);
        display: flex; align-items: center; justify-content: flex-start;
        gap: 8px;
        font-size: 11px; font-weight: 700; text-transform: uppercase;
        margin-right: 8px; cursor: pointer;
        transition: all 0.2s;
    }
    .filter-pill-btn:active { transform: scale(0.95); }
    .filter-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--ink-dim); box-shadow: 0 0 5px currentColor; flex-shrink: 0; }

    /* --- Modals & Overlays --- */
    .overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.9); backdrop-filter: blur(8px);
      z-index: 300; opacity: 0; pointer-events: none; transition: opacity 0.3s;
      display: flex; align-items: flex-end;
    }
    .overlay.active { opacity: 1; pointer-events: auto; }
    @media(min-width: 600px) { .overlay { align-items: center; justify-content: center; } }

    .modal-sheet {
      position: relative; 
      width: 100%; background: var(--bg-color);
      border-top: 1px solid var(--glass-border);
      border-radius: 24px 24px 0 0;
      padding: 24px;
      transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
      max-height: 85vh; overflow-y: auto;
    }
    .overlay.active .modal-sheet { transform: translateY(0); }
    @media(min-width: 600px) { 
      .modal-sheet { max-width: 400px; border-radius: 24px; border: 1px solid var(--glass-border); transform: scale(0.95); }
      .overlay.active .modal-sheet { transform: scale(1); }
    }
    
    .close-btn { 
       position: absolute; top: 16px; right: 16px; 
       background: transparent; border: none; color: var(--ink-dim); 
       cursor: pointer; padding: 8px; border-radius: 50%; z-index: 10;
       transition: color 0.2s;
    }
    .close-btn:hover { color: var(--ink); }

    /* --- Dialogs (Confirm & Action) --- */
    .confirm-dialog {
        background: var(--card-bg); border: 1px solid var(--glass-border);
        padding: 24px; border-radius: 16px; width: 90%; max-width: 320px;
        text-align: center;
        margin-bottom: 40vh; 
    }
    .overlay.active .confirm-dialog { animation: fadeIn 0.1s ease; }
    @media(min-width: 600px) { .confirm-dialog { margin-bottom: 0; } }
    
    .confirm-title { font-weight: 700; font-size: 16px; margin-bottom: 8px; }
    .confirm-text { font-size: 13px; color: var(--ink-dim); margin-bottom: 20px; }
    .confirm-actions { display: flex; gap: 10px; }

    .form-group { margin-bottom: 16px; }
    label { display: block; font-size: 12px; font-weight: 600; color: var(--ink-dim); margin-bottom: 6px; text-transform: uppercase; }
    
    .input-wrapper { position: relative; width: 100%; }
    .input-wrapper input { padding-right: 40px; }
    .input-icon-btn {
      position: absolute; right: 8px; top: 50%; transform: translateY(-50%);
      background: none; border: none; color: var(--ink-dim); cursor: pointer;
      padding: 4px; border-radius: 4px;
    }
    .input-icon-btn:hover { color: var(--accent); background: rgba(255,255,255,0.1); }

    input, select {
      width: 100%; padding: 16px;
      background: rgba(255,255,255,0.05); border: 1px solid var(--glass-border);
      border-radius: 12px; color: var(--ink); font-size: 16px;
      font-family: var(--font-sans); padding-right: 32px; 
      -webkit-appearance: none; -moz-appearance: none; appearance: none;
    }
    input:focus, select:focus { outline: none; border-color: var(--accent); background: rgba(255,255,255,0.1); }
    
    .form-group select {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3E%3Cpath fill='%23888' d='M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 12px center;
        background-size: 16px;
    }

    .status-toggles { display: flex; gap: 8px; }
    .btn-toggle {
       flex: 1; padding: 12px; border-radius: 12px; font-weight: 700; border: 1px solid var(--glass-border); 
       background: transparent; cursor: pointer; transition: all 0.2s; font-size: 14px;
       line-height: 1;
    }
    .btn-toggle.selected { color: var(--bg-color); border-color: currentColor; }
    .btn-toggle[data-status="active"].selected { background: var(--accent); color: #000; border-color: var(--accent); }
    .btn-toggle[data-status="ready"].selected { background: var(--neon-green); color: #000; border-color: var(--neon-green); }
    .btn-toggle[data-status="cooldown"].selected { background: var(--neon-orange); color: #000; border-color: var(--neon-orange); }
    .btn-toggle[data-status="burnt"].selected { background: var(--neon-red); color: #000; border-color: var(--neon-red); }

    .pill-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
    .pill-option {
       padding: 8px 12px; border-radius: 8px; font-size: 14px; font-weight: 600; text-align: center;
       background: rgba(255,255,255,0.05); border: 1px solid var(--glass-border);
       cursor: pointer; transition: all 0.2s; line-height: 1.2;
    }
    .pill-option:hover { background: rgba(255,255,255,0.1); }
    .pill-option.selected { background: var(--accent); color: #000; border-color: var(--accent); }
    
    .btn-block { width: 100%; padding: 16px; border-radius: 12px; font-weight: 700; border: none; font-size: 14px; text-transform: uppercase; cursor: pointer; }
    .btn-primary { background: var(--accent); color: #000; }
    .btn-secondary { background: var(--glass-border); color: var(--ink); margin-top: 12px; }
    .btn-danger { background: rgba(239,68,68,0.2); color: var(--neon-red); margin-top: 12px; border: 1px solid rgba(239,68,68,0.5); }
    
    .btn-half { flex: 1; padding: 12px; border-radius: 10px; font-weight: 600; border: none; cursor: pointer; }
    .btn-cancel { background: transparent; color: var(--ink-dim); border: 1px solid var(--glass-border); }
    .btn-confirm { background: var(--accent); color: #000; }

    /* --- Accordion Styles --- */
    .accordion-item {
        border: 1px solid var(--glass-border);
        border-radius: 12px;
        margin-bottom: 8px;
        overflow: hidden;
        transition: all 0.2s;
    }
    .accordion-header {
        width: 100%;
        background: transparent;
        border: none;
        padding: 16px;
        text-align: left;
        color: var(--ink);
        font-weight: 600;
        font-size: 15px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .accordion-header:hover { background: rgba(255, 255, 255, 0.05); }
    .accordion-icon { transition: transform 0.3s ease; }
    .accordion-item.open .accordion-icon { transform: rotate(180deg); }
    .accordion-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; }
    .accordion-content-inner { padding: 0 16px 16px 16px; font-size: 14px; color: var(--ink-dim); line-height: 1.6; }
    .accordion-content-inner ul { list-style-type: 'â€”  '; margin-left: 20px; padding-left: 0; }
    .accordion-content-inner li { margin-bottom: 6px; padding: 4px 0; }
    
    /* --- Utilities --- */
    .toast {
      position: fixed; top: 120px; left: 50%; transform: translateX(-50%) translateY(-20px);
      background: var(--accent); color: #000; padding: 10px 20px; border-radius: 20px;
      font-weight: 700; font-size: 12px; opacity: 0; pointer-events: none; transition: all 0.3s; z-index: 500;
    }
    .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
    
    /* Scatter Specific Mobile Controls */
    .scatter-controls {
      position: fixed; bottom: 100px; right: 20px; display: none; flex-direction: column; gap: 10px; z-index: 150;
    }
    .scatter-controls.visible { display: flex; }
    .control-btn { width: 40px; height: 40px; border-radius: 50%; background: var(--glass-bg); border: 1px solid var(--glass-border); color: var(--ink); font-size: 16px; backdrop-filter: blur(10px); cursor: pointer; }

    /* --- Context Menu --- */
    .context-menu {
      position: fixed; display: none; 
      background: var(--card-bg); border: 1px solid var(--glass-border);
      border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      z-index: 1000; width: 220px; overflow: hidden;
      backdrop-filter: blur(12px);
    }
    .context-menu.active { display: block; animation: fadeIn 0.1s ease; }
    .ctx-header { padding: 8px 12px; font-size: 10px; text-transform: uppercase; color: var(--ink-dim); border-bottom: 1px solid var(--glass-border); letter-spacing: 1px; }
    .ctx-item { 
      padding: 12px 16px; font-size: 14px; color: var(--ink); cursor: pointer; display: flex; align-items: center; gap: 10px;
      border-bottom: 1px solid rgba(255,255,255,0.02);
    }
    .ctx-item:hover { background: var(--accent); color: #000; }
    .ctx-item:last-child { border-bottom: none; }
    
    @keyframes fadeIn { from { opacity:0; transform:scale(0.95); } to { opacity:1; transform:scale(1); } }

  </style>
</head>
<body data-theme="dark">

  <header class="app-header">
    <div class="header-top">
    <div class="logo">
    <img id="logoImg" src="https://raw.githubusercontent.com/ZACKGORT/intoview/main/intoview-logo-light.svg" alt="IntoView Logo" style="height: 32px;">
  </div>
      
      <div class="header-buttons">
        <button class="theme-btn info-btn" onclick="openInfoModal()" title="Information & Help">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"></path></svg>
        </button>
        <button class="theme-btn" onclick="toggleTheme()" title="Toggle Theme">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9 9-4.03 9-9c0-.46-.04-.92-.1-1.36-.98 1.37-2.58 2.26-4.4 2.26-2.98 0-5.4-2.42-5.4-5.4 0-1.81.89-3.42 2.26-4.4-.44-.06-.9-.1-1.36-.1z"></path></svg>
        </button>
      </div>
    </div>
    
    <div class="provider-bar" id="providerBar"></div>
  </header>

  <div id="gridContainer" class="view-container active">
    <div class="grid-wrapper" id="gridWrapper"></div>
  </div>

  <div id="scatterContainer" class="view-container">
    <div class="scatter-canvas" id="scatterCanvas"></div>
  </div>

  <div class="scatter-controls" id="scatterControls">
    <button class="control-btn" onclick="autoArrange()" id="wandBtn" title="Auto-Arrange">ðŸª„</button>
    <button class="control-btn" onclick="zoom(0.1, window.innerWidth/2, window.innerHeight/2)" title="Zoom In">+</button>
    <button class="control-btn" onclick="zoom(-0.1, window.innerWidth/2, window.innerHeight/2)" title="Zoom Out">-</button>
  </div>

  <div id="contextMenu" class="context-menu"></div>

  <nav class="bottom-nav">
    <div class="nav-group">
      <button class="nav-btn active" data-view="grid" onclick="switchView('grid')" title="Grid View">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M4 11h7V4H4v7zm0 9h7v-7H4v7zm9 0h7v-7h-7v7zm0-16v7h7V4h-7z"></path></svg>
      </button>
      <button class="nav-btn" data-view="scatter" onclick="switchView('scatter')" title="Free Form">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="3"></circle><circle cx="19" cy="5" r="2"></circle><circle cx="5" cy="19" r="2"></circle><circle cx="5" cy="5" r="2"></circle><circle cx="19" cy="19" r="2"></circle></svg>
      </button>
    </div>

    <button class="nav-btn primary" onclick="openModal()">+</button>

    <button class="filter-pill-btn" onclick="cycleStatusFilter()" id="statusPill" title="Active â€¢ Ready â€¢ Cooling â€¢ Burnt">
      <div class="filter-dot" id="filterDot"></div>
      <span id="filterLabel">All</span>
    </button>
  </nav>

  <div class="overlay" id="modalOverlay">
  <div class="modal-sheet">
    <button class="close-btn" onclick="closeModal()">
       <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
    </button>
    
    <h2 style="margin-bottom:20px; font-family:var(--font-mono)" id="modalTitle">New Node</h2>
    <form id="nodeForm">
      <input type="hidden" id="nodeId">
      
      <div class="form-group">
        <label>Provider</label>
        <select id="inpProvider"></select>
      </div>
      
      <div class="form-group">
        <label>Email / Identity</label>
        <div class="input-wrapper">
          <input type="text" id="inpEmail" required autocomplete="off">
          <button type="button" class="input-icon-btn" onclick="copyInput('inpEmail')">
             <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
          </button>
        </div>
      </div>

      <div class="form-group">
        <label>Current Status</label>
        <div class="status-toggles">
          <button type="button" data-status="active" class="btn-toggle text-blue" onclick="selectStatusButton('active')">Active</button>
          <button type="button" data-status="ready" class="btn-toggle text-green" onclick="selectStatusButton('ready')">Ready</button>
          <button type="button" data-status="cooldown" class="btn-toggle text-orange" onclick="selectStatusButton('cooldown')">Cooldown</button>
          <button type="button" data-status="burnt" class="btn-toggle text-red" onclick="selectStatusButton('burnt')">Burnt</button>
        </div>
        <input type="hidden" id="inpStatus" value="active">
      </div>
      
      <div class="form-group">
        <label>Reset Cycle (Hours)</label>
        <div class="pill-grid">
           <div class="pill-option" data-hours="3" onclick="selectResetHours(3)">3h</div>
           <div class="pill-option" data-hours="6" onclick="selectResetHours(6)">6h</div>
           <div class="pill-option" data-hours="12" onclick="selectResetHours(12)">12h</div>
           <div class="pill-option" data-hours="24" onclick="selectResetHours(24)">24h</div>
           <div class="pill-option" data-hours="48" onclick="selectResetHours(48)">48h</div>
           <div class="pill-option" data-hours="72" onclick="selectResetHours(72)">72h</div>
        </div>
        <input type="number" id="inpResetCustom" placeholder="Custom Hours" style="margin-top: 8px;" step="0.5">
        <input type="hidden" id="inpReset" value="3">
      </div>

      <div id="editActions" style="display:none; margin-top:12px; display:flex; gap:10px;">
         <button type="button" class="btn-block btn-secondary" onclick="confirmHitLimit(null)">ðŸ”¥ Hit Limit</button>
         <button type="button" class="btn-block btn-secondary" onclick="confirmForceRestore(null)">ðŸ”„ Restore</button>
      </div>

      <button type="submit" class="btn-block btn-primary" style="margin-top: 12px;">Save Node</button>
      
      <button type="button" class="btn-block btn-danger" id="btnDelete" style="display:none" onclick="deleteNode()">Delete Node</button>
      <div style="height:20px"></div>
    </form>
  </div>
</div>

<div class="overlay" id="confirmOverlay">
   <div class="confirm-dialog">
      <div class="confirm-title" id="confirmTitle">Confirm Action</div>
      <div class="confirm-text" id="confirmText">Are you sure?</div>
      <div class="confirm-actions">
         <button class="btn-half btn-cancel" onclick="closeConfirm()">Cancel</button>
         <button class="btn-half btn-confirm" id="btnConfirmAction">Confirm</button>
      </div>
   </div>
</div>

<div class="overlay" id="actionOverlay">
   <div class="confirm-dialog">
      <div class="confirm-title" id="actionTitle">Activate Node</div>
      <div class="confirm-text">Email copied to clipboard:</div>
      <input type="text" id="actionEmail" readonly style="margin-bottom:20px; text-align:center;">
      <div class="confirm-actions">
         <button class="btn-half btn-cancel" onclick="closeActionOverlay()">Cancel</button>
         <button class="btn-half btn-confirm" id="btnActivateNode">Activate</button>
      </div>
   </div>
</div>

<div class="overlay" id="infoOverlay">
  <div class="modal-sheet">
    <button class="close-btn" onclick="closeInfoModal()">
       <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
    </button>
    
    <h2 style="margin-bottom:20px; font-family:var(--font-mono)">fyi:</h2>

    <div style="margin-bottom: 24px; padding: 16px; border-radius: 12px; background: rgba(255,255,255,0.05);">
      <h3 style="font-weight: 700; font-size: 16px; color: var(--accent); margin-bottom: 8px;">The Node Manifesto:</h3>
      <p style="font-size: 14px; color: var(--ink-dim); line-height: 1.5;">
      <p style="font-size: 14px; color: var(--ink-dim); line-height: 1.5;"><strong></p><p style="font-size: 14px; color: var(--ink-dim); line-height: 1.5;">You are an infinite machine</strong> in a <em>finite prompt cycle</em>; but do not yield for here is a tool for the commonwealth of the commonfolk. <br><br>
        Use the timer not as a limiter, but as a catalyst to creation.<br><br>Let each cooldown be a reset, every burnt node a lesson, and each new node a launchpad.</p>
    </div>


    <div id="accordionContainer">
      
      <div class="accordion-item">
        <button class="accordion-header" onclick="toggleAccordion(this)">
          <span>Interaction & Shortcuts</span>
          <svg class="accordion-icon" width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"></path></svg>
        </button>
        <div class="accordion-content">
          <div class="accordion-content-inner">
            <ul style="list-style-type: none; padding: 0;">
              <li><strong style="color: var(--accent);">Tap Card (Grid/Scatter):</strong> Open Edit Modal (View Details).</li>
              <li><strong style="color: var(--accent);">Right-Click / Long-Press Card:</strong> Quick Action Menu (Hit Limit / Restore / View Details).</li>
              <li><strong style="color: var(--accent);">Right-Click / Long-Press Background (Scatter Mode):</strong> Arrangement & Sorting menu.</li>
              <li><strong style="color: var(--accent);">Drag Card (Scatter Mode):</strong> Move the node freely. Because some people like to thhink for themselves. </li>
              <li><strong style="color: var(--accent);">Drag Background (well, camera)</strong> Scroll / Pan / Zoom / Sort / Arrange</li>
              <li><strong style="color: var(--accent);">Right-Click / Long-Press</strong> Contextual Menu Interface</li>
              <li><strong style="color: var(--accent);">Theme Toggle:</strong> Switches between Light and Dark mode.</li>
              <li><strong style="color: var(--accent);">Status Pill (Bottom Right):</strong> Cycles the global filter (All -> Active -> Cooldown -> Burnt).</li>
            </ul>
          </div>
        </div>
      </div>

      <div class="accordion-item">
        <button class="accordion-header" onclick="toggleAccordion(this)">
          <span>Status & Timing</span>
          <svg class="accordion-icon" width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"></path></svg>
        </button>
        <div class="accordion-content">
          <div class="accordion-content-inner">
            <ul>
              <li style="color: var(--neon-green);">**Active:** Actively in use. Timer shows 00:00:00.</li>
              <li style="color: var(--neon-blue);">**Ready:** Ready to use. Timer shows 00:00:00.</li>              
              <li style="color: var(--neon-orange);">**Cooldown:** In use, waiting for the limit to reset. Timer shows time remaining (based on *Reset Cycle*).</li>
              <li style="color: var(--neon-red);">**Burnt:** Permanently defunct or retired.</li>
              <li style="margin-top: 12px; color: var(--ink-dim); font-size: 13px; list-style-type: none;">*The timer counts down from the last "Hit Limit" event to the pre-selected "Reset Cycle" duration.*</li>
            </ul>
          </div>
        </div>
      </div>

    </div>
    
    <a href="https://emdash.click" target="_blank" style="display: block; text-align: center; margin-top: 30px; text-decoration: none;">
       <button class="btn-block btn-secondary" style="background: var(--glass-border); color: var(--ink-dim);">
          <span style="font-weight: 400;">Something useful @</span><strong style="color: var(--ink); font-weight: 700;"> emdash.click</strong>
       </button>
    </a>

    <div style="height:20px"></div>
  </div>
</div>


<div class="toast" id="toast">Copied to Clipboard</div>


  <script>
    // --- Global State ---
    let items = []; // Main array of nodes
    let providers = []; // List of all providers for dropdowns/pills
    let config = {
      filterStatus: 'all',
      filterProvider: 'all',
      view: 'grid'
    };
    let scatter = {
      transform: { x: 0, y: 0, scale: 1 },
      panning: false,
      dragging: false,
      pinchStart: 0,
    };
    let activeNodeId = null;
    let timerInterval = null;

    // --- Data Persistence ---

    function load() {
      const storedItems = localStorage.getItem('iv_items');
      const storedProviders = localStorage.getItem('iv_providers');
      
      if (storedItems) {
        items = JSON.parse(storedItems);
      } else {
        seedMockData(); // Use mock data if nothing is stored
      }
      
      if (storedProviders) {
        providers = JSON.parse(storedProviders);
      }
      
      config.filterStatus = localStorage.getItem('iv_filterStatus') || 'all';
      config.filterProvider = localStorage.getItem('iv_filterProvider') || 'all';
      config.view = localStorage.getItem('iv_view') || 'grid';
      
      const storedTransform = localStorage.getItem('iv_scatterTransform');
      if (storedTransform) {
        scatter.transform = JSON.parse(storedTransform);
      }
    }

    function seedMockData() {
      const allProviders = ['ChatGPT', 'Claude', 'Gemini', 'Grok', 'Copilot', 'Perplexity', 'Mistral', 'Midjourney', 'Llama Hub'];
      
      const mockData = [
          // --- FEW ACTIVE (2) ---
          { provider: 'ChatGPT', email: 'gpt_4_main@openai.com', status: 'active', resetHours: 3, lastUsedOffset: 0.1 },
          { provider: 'Claude', email: 'claude_opus_pro@anthropic.ai', status: 'active', resetHours: 6, lastUsedOffset: 0.2 },

          // --- SOME READY (3) ---
          { provider: 'Grok', email: 'grok_fun_mode@x.com', status: 'ready', resetHours: 48, lastUsedOffset: 50 },
          { provider: 'Gemini', email: 'gemini_ultra@google.com', status: 'ready', resetHours: 12, lastUsedOffset: 14 },
          { provider: 'Copilot', email: 'github_copilot_student@ms.com', status: 'ready', resetHours: 6, lastUsedOffset: 8 },

          // --- MOST COOLING (7) ---
          { provider: 'ChatGPT', email: 'gpt_3.5_burner@openai.com', status: 'cooldown', resetHours: 3, lastUsedOffset: 0.5 },
          { provider: 'Claude', email: 'claude_sonnet_dev@anthropic.ai', status: 'cooldown', resetHours: 8, lastUsedOffset: 2 },
          { provider: 'Perplexity', email: 'research_pplx@perplexity.ai', status: 'cooldown', resetHours: 4, lastUsedOffset: 1 },
          { provider: 'Mistral', email: 'le_chat_large@mistral.ai', status: 'cooldown', resetHours: 24, lastUsedOffset: 12 },
          { provider: 'Midjourney', email: 'mj_fast_hours@discord.com', status: 'cooldown', resetHours: 12, lastUsedOffset: 11 }, // Almost ready
          { provider: 'Llama Hub', email: 'llama3_70b@meta.ai', status: 'cooldown', resetHours: 6, lastUsedOffset: 1.5 },
          { provider: 'Gemini', email: 'gemini_flash@google.com', status: 'cooldown', resetHours: 24, lastUsedOffset: 5 },

          // --- BUNCH DEFUNCT/BURNT (4) ---
          { provider: 'ChatGPT', email: 'old_gpt_banned@openai.com', status: 'burnt', resetHours: 24, lastUsedOffset: 100 },
          { provider: 'Claude', email: 'claude_v1_legacy@anthropic.ai', status: 'burnt', resetHours: 12, lastUsedOffset: 200 },
          { provider: 'Midjourney', email: 'mj_trial_expired@discord.com', status: 'burnt', resetHours: 24, lastUsedOffset: 50 },
          { provider: 'Copilot', email: 'expired_enterprise@corp.com', status: 'burnt', resetHours: 6, lastUsedOffset: 300 },
      ];
      
      items = mockData.map((data, i) => {
        const lastUsedMs = Date.now() - (data.lastUsedOffset * 60 * 60 * 1000);
        return {
          id: Date.now() + i,
          provider: data.provider,
          email: data.email,
          status: data.status,
          resetHours: data.resetHours,
          lastUsed: lastUsedMs,
          pos: { x: 50 + (i % 3) * 250, y: 100 + Math.floor(i / 3) * 180 }
        };
      });
      providers = allProviders; 
      save();
    }

    function save() {
      localStorage.setItem('iv_items', JSON.stringify(items));
      localStorage.setItem('iv_providers', JSON.stringify(providers));
      localStorage.setItem('iv_filterStatus', config.filterStatus);
      localStorage.setItem('iv_filterProvider', config.filterProvider);
      localStorage.setItem('iv_scatterTransform', JSON.stringify(scatter.transform));
    }

    // --- Utility Functions ---

    function formatTime(ms) {
      const totalSeconds = Math.floor(ms / 1000);
      const totalMinutes = Math.floor(totalSeconds / 60);
      const totalHours = Math.floor(totalMinutes / 60);

      const hours = String(totalHours).padStart(2, '0');
      const minutes = String(totalMinutes % 60).padStart(2, '0');
      const seconds = String(totalSeconds % 60).padStart(2, '0');

      if (totalHours > 99) {
          return `${totalHours}h+`;
      }
      return `${hours}:${minutes}:${seconds}`;
    }

    function formatRemainingTime(ms) {
      if (ms <= 0) return '00:00:00';
      const totalSeconds = Math.floor(ms / 1000);
      const totalMinutes = Math.floor(totalSeconds / 60);
      const totalHours = Math.floor(totalMinutes / 60);

      const days = Math.floor(totalHours / 24);
      const hours = String(totalHours % 24).padStart(2, '0');
      const minutes = String(totalMinutes % 60).padStart(2, '0');
      const seconds = String(totalSeconds % 60).padStart(2, '0');
      
      if (days > 0) return `${days}d ${hours}h`;
      return `${hours}:${minutes}:${seconds}`;
    }

    function copyToClipboard(text) {
        if (!navigator.clipboard) {
            fallbackCopyTextToClipboard(text);
            return;
        }
        navigator.clipboard.writeText(text).then(function() {
            showToast('Copied to Clipboard!');
        }, function(err) {
            console.error('Async: Could not copy text: ', err);
            showToast('Copy Failed!');
        });
    }
    
    function fallbackCopyTextToClipboard(text) {
      var textArea = document.createElement("textarea");
      textArea.value = text;
      textArea.style.position = "fixed";  // Avoid scrolling to bottom
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      try {
        var successful = document.execCommand('copy');
        var msg = successful ? 'successful' : 'unsuccessful';
        showToast('Copied to Clipboard!');
      } catch (err) {
        showToast('Copy Failed!');
      }
      document.body.removeChild(textArea);
    }
    
    function copyInput(inputId) {
        const input = document.getElementById(inputId);
        copyToClipboard(input.value);
    }

    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => {
        toast.classList.remove('show');
      }, 2000);
    }

    function toggleAccordion(header) {
        const item = header.closest('.accordion-item');
        const content = item.querySelector('.accordion-content');
        const isOpen = item.classList.contains('open');

        // Close all other accordions
        document.querySelectorAll('.accordion-item').forEach(otherItem => {
            if (otherItem !== item) {
                otherItem.classList.remove('open');
                otherItem.querySelector('.accordion-content').style.maxHeight = null;
            }
        });

        if (isOpen) {
            item.classList.remove('open');
            content.style.maxHeight = null;
        } else {
            item.classList.add('open');
            content.style.maxHeight = content.scrollHeight + "px";
        }
    }

    // --- Filtering & View Management ---

    function switchView(viewName) {
      config.view = viewName;
      localStorage.setItem('iv_view', viewName);
      
      document.querySelectorAll('.nav-btn[data-view]').forEach(b => b.classList.toggle('active', b.dataset.view === viewName));
      document.querySelectorAll('.view-container').forEach(c => c.classList.remove('active'));
      
      if(viewName === 'grid') {
        document.getElementById('gridContainer').classList.add('active');
        document.getElementById('scatterControls').classList.remove('visible');
        renderGrid();
      } else {
        document.getElementById('scatterContainer').classList.add('active');
        document.getElementById('scatterControls').classList.add('visible');
        renderScatter();
      }
    }

    function filterItems() {
      let res = items;
      if (config.filterStatus !== 'all') {
        res = res.filter(i => i.status === config.filterStatus);
      }
      if (config.filterProvider !== 'all') {
        res = res.filter(i => i.provider === config.filterProvider);
      }
      return res;
    }

    function cycleStatusFilter() {
        const statuses = ['all', 'active', 'ready', 'cooldown', 'burnt'];
        let currentIndex = statuses.indexOf(config.filterStatus);
        
        currentIndex = (currentIndex + 1) % statuses.length;
        config.filterStatus = statuses[currentIndex];
        
        updateFilterPill();
        localStorage.setItem('iv_filterStatus', config.filterStatus);
        
        if (config.view === 'grid') {
            renderGrid();
        } else {
            renderScatter();
        }
    }
    
    function updateFilterPill() {
        const pill = document.getElementById('statusPill');
        const dot = document.getElementById('filterDot');
        const label = document.getElementById('filterLabel');

        label.textContent = config.filterStatus.toUpperCase();
        
        dot.className = 'filter-dot';
        
        if (config.filterStatus === 'all') {
            dot.style.background = 'var(--ink-dim)';
            dot.style.boxShadow = '0 0 5px var(--ink-dim)';
        } else if (config.filterStatus === 'active') {
            dot.style.background = 'var(--neon-blue)';
            dot.style.boxShadow = '0 0 5px var(--neon-blue)';
        } else if (config.filterStatus === 'ready') {
            dot.style.background = 'var(--neon-green)';
            dot.style.boxShadow = '0 0 5px var(--neon-green)';
        } else if (config.filterStatus === 'cooldown') {
            dot.style.background = 'var(--neon-orange)';
            dot.style.boxShadow = '0 0 5px var(--neon-orange)';
        } else if (config.filterStatus === 'burnt') {
            dot.style.background = 'var(--neon-red)';
            dot.style.boxShadow = '0 0 5px var(--neon-red)';
        }
    }

    function setProviderFilter(providerName) {
        config.filterProvider = providerName;
        localStorage.setItem('iv_filterProvider', providerName);
        renderProviderPills();

        if (config.view === 'grid') {
            renderGrid();
        } else {
            renderScatter();
        }
    }

    // --- Rendering ---

    function updateAllTimers() {
      const activeItems = items.filter(i => i.status !== 'burnt');
      activeItems.forEach(item => {
        const timerElement = document.getElementById(`timer-${item.id}`);
        const resetDot = document.getElementById(`reset-dot-${item.id}`);
        const now = Date.now();

        if (!timerElement) return;

        if (item.status === 'active') {
          const usedMs = now - item.lastUsed;
          timerElement.textContent = formatTime(usedMs);
          
          const resetMs = item.resetHours * 60 * 60 * 1000;
          if (usedMs >= resetMs) {
            // Auto-hit limit/cooldown when active time exceeds reset time
            item.status = 'cooldown';
            item.lastUsed = now; // New cooldown start time
            save();
            renderAll();
            showToast(`${item.provider} Node Cooldown Initiated.`);
          }
        } 
        
        else if (item.status === 'cooldown') {
          const resetMs = item.resetHours * 60 * 60 * 1000;
          const remainingMs = item.lastUsed + resetMs - now;
          timerElement.textContent = formatRemainingTime(remainingMs);
          
          const progress = Math.min(1, (now - item.lastUsed) / resetMs);
          if (resetDot) {
            resetDot.style.opacity = '1';
            resetDot.style.transform = `scaleX(${progress})`;
          }

          if (remainingMs <= 0) {
            item.status = 'ready';
            save();
            renderAll();
            showToast(`${item.provider} Node is Ready!`);
          }
        }
        
        else if (item.status === 'ready') {
          timerElement.textContent = '00:00:00';
          if (resetDot) resetDot.style.opacity = '0';
        }
      });
    }

    function renderProviderPills() {
        const bar = document.getElementById('providerBar');
        bar.innerHTML = '';

        // Add 'All' pill
        const allPill = document.createElement('div');
        allPill.className = `pill ${config.filterProvider === 'all' ? 'active' : ''}`;
        allPill.textContent = 'All Providers';
        allPill.onclick = () => setProviderFilter('all');
        bar.appendChild(allPill);

        providers.sort().forEach(provider => {
            const pill = document.createElement('div');
            pill.className = `pill ${config.filterProvider === provider ? 'active' : ''}`;
            pill.textContent = provider;
            pill.onclick = () => setProviderFilter(provider);
            bar.appendChild(pill);
        });
        
        // Add 'Add' pill
        const addPill = document.createElement('div');
        addPill.className = 'pill add-btn';
        addPill.textContent = '+ Add Node';
        addPill.onclick = openModal;
        bar.appendChild(addPill);
    }
    
    function renderCard(item) {
      const isCooldown = item.status === 'cooldown';
      const isBurnt = item.status === 'burnt';
      const isReady = item.status === 'ready';

      let dotClass = '';
      if (item.status === 'active') dotClass = 'text-blue';
      else if (isCooldown) dotClass = 'text-orange';
      else if (isReady) dotClass = 'text-green';
      else if (isBurnt) dotClass = 'text-red';
      
      const timerLabel = isCooldown ? 'TIME TO READY' : (isBurnt ? 'DEFUNCT' : 'TIME IN USE');
      
      const card = document.createElement('div');
      card.className = 'card' + (isBurnt ? ' burnt' : '');
      card.dataset.id = item.id;
      card.onclick = (e) => {
          // Prevent activation if clicking on the edit icon
          if (e.target.closest('.card-edit-icon') || e.target.closest('.action-icon')) {
              return;
          }
          if (item.status === 'ready') {
              openActionOverlay(item.id);
          } else {
              openModal(item.id);
          }
      };
      card.oncontextmenu = (e) => {
          e.preventDefault();
          showContextMenu(e, item.id);
      }
      
      // Card Content
      card.innerHTML = `
        <div class="card-top">
          <div class="card-provider">${item.provider}</div>
          <div style="display: flex; align-items: center;">
            <div class="status-dot ${dotClass}" style="margin-right:8px;"></div>
            <div style="font-size:14px; font-weight:600; text-transform:uppercase; color: ${dotClass.replace('text-', 'var(--neon-')}">${item.status}</div>
            <button class="card-edit-icon" onclick="openModal(${item.id})">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path></svg>
            </button>
          </div>
        </div>
        
        <div class="card-timer" id="timer-${item.id}">00:00:00${isBurnt ? '<div class="burnt-label">BURNT</div>' : ''}</div>
        
        <div style="font-size:11px; color:var(--ink-dim); text-align:center; margin-top:-10px;">${timerLabel}</div>

        <div class="card-meta">
            <span class="card-email">${item.email}</span>
            <div class="card-actions">
                ${item.status !== 'ready' ? `<div class="action-icon" onclick="confirmForceRestore(${item.id})" title="Reset to Ready">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.74 15.42 20 13.75 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 9.74C4.26 11.02 4 12.63 4 14c0 4.42 3.58 8 8 8V23l4-4-4-4v3z"></path></svg>
                </div>` : ''}
                ${item.status === 'active' || item.status === 'cooldown' ? `<div class="action-icon" onclick="confirmHitLimit(${item.id})" title="Hit Limit Now">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"></path></svg>
                </div>` : ''}
            </div>
        </div>
      `;
      
      return card;
    }

    function renderGrid() {
      const wrapper = document.getElementById('gridWrapper');
      wrapper.innerHTML = '';
      
      const filtered = filterItems().sort((a, b) => {
        // Sort by status: Active > Ready > Cooldown > Burnt
        const statusOrder = { 'active': 0, 'ready': 1, 'cooldown': 2, 'burnt': 3 };
        const statusA = statusOrder[a.status];
        const statusB = statusOrder[b.status];
        if (statusA !== statusB) return statusA - statusB;
        
        // Secondary sort: Cooldown remaining or last used time
        if (a.status === 'cooldown' || b.status === 'cooldown') {
            const timeToA = a.resetHours * 3600000 - (Date.now() - a.lastUsed);
            const timeToB = b.resetHours * 3600000 - (Date.now() - b.lastUsed);
            return timeToA - timeToB;
        }
        
        return b.lastUsed - a.lastUsed; // Most recently used first for Active/Ready
      });

      if (filtered.length === 0) {
        wrapper.innerHTML = `<div style="text-align:center; padding-top:40px; color:var(--ink-dim); font-size:16px;">No nodes match the current filter.</div>`;
      } else {
        filtered.forEach(item => {
          wrapper.appendChild(renderCard(item));
        });
      }
    }

    // --- Scatter View Logic ---
    
    function applyScatterTransform() {
        const canvas = document.getElementById('scatterCanvas');
        canvas.style.transform = `translate(${scatter.transform.x}px, ${scatter.transform.y}px) scale(${scatter.transform.scale})`;
        canvas.style.backgroundPosition = `${scatter.transform.x}px ${scatter.transform.y}px`;
        canvas.style.backgroundSize = `${40 * scatter.transform.scale}px ${40 * scatter.transform.scale}px`;
    }

    function renderScatter() {
        const canvas = document.getElementById('scatterCanvas');
        canvas.innerHTML = '';
        
        const filtered = filterItems();

        if (filtered.length === 0) {
            canvas.innerHTML = `<div style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:var(--ink-dim); font-size:16px; width:200px; text-align:center;">No nodes match the current filter.</div>`;
        } else {
            filtered.forEach(item => {
                const card = renderScatterCard(item);
                canvas.appendChild(card);
            });
        }
        
        applyScatterTransform();
    }
    
    function renderScatterCard(item) {
        const card = document.createElement('div');
        card.className = 'scatter-card' + (item.status === 'burnt' ? ' burnt' : '');
        card.id = `scatter-card-${item.id}`;
        card.dataset.id = item.id;
        
        card.style.left = `${item.pos.x}px`;
        card.style.top = `${item.pos.y}px`;
        card.style.zIndex = item.status === 'active' ? 5 : 1;
        
        const isCooldown = item.status === 'cooldown';
        const isBurnt = item.status === 'burnt';
        const isReady = item.status === 'ready';

        let dotClass = '';
        if (item.status === 'active') dotClass = 'text-blue';
        else if (isCooldown) dotClass = 'text-orange';
        else if (isReady) dotClass = 'text-green';
        else if (isBurnt) dotClass = 'text-red';
        
        const timerLabel = isCooldown ? 'TIME TO READY' : (isBurnt ? 'DEFUNCT' : 'TIME IN USE');
        
        card.innerHTML = `
            <div class="card-top" style="width:100%;">
              <div class="card-provider">${item.provider}</div>
              <div style="display: flex; align-items: center; gap:4px;">
                <div class="status-dot ${dotClass}" style="margin-right:4px;"></div>
                <div style="font-size:11px; font-weight:600; text-transform:uppercase; color: ${dotClass.replace('text-', 'var(--neon-')}">${item.status}</div>
                <button class="card-edit-icon" onclick="openModal(${item.id})">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path></svg>
                </button>
              </div>
            </div>
            
            <div class="card-timer" id="timer-${item.id}">00:00:00${isBurnt ? '<div class="burnt-label">BURNT</div>' : ''}</div>
            
            <div style="font-size:10px; color:var(--ink-dim); margin-top:-4px;">${timerLabel}</div>
            
            <div class="card-meta">
                ${item.email}
            </div>
            
            ${isCooldown ? `<div style="height:4px; width:100%; background:var(--glass-border); border-radius:2px; margin-top:8px; overflow:hidden;">
                <div id="reset-dot-${item.id}" style="height:4px; width:100%; background:var(--neon-orange); transform-origin:left; transform:scaleX(0);"></div>
            </div>` : ''}
        `;

        card.onpointerdown = (e) => startDrag(e, item);
        card.onclick = (e) => {
            // Prevent activation if drag happened
            if (scatter.dragging) return;
            if (item.status === 'ready') {
                openActionOverlay(item.id);
            } else {
                openModal(item.id);
            }
        };
        card.oncontextmenu = (e) => {
            e.preventDefault();
            showContextMenu(e, item.id);
        }

        return card;
    }
    
    function autoArrange() {
        const filtered = filterItems();
        const cardWidth = 250;
        const cardHeight = 200;
        const perRow = 5;
        
        filtered.forEach((item, i) => {
            const row = Math.floor(i / perRow);
            const col = i % perRow;
            
            item.pos = {
                x: 50 + col * cardWidth,
                y: 100 + row * cardHeight
            };
        });
        
        // Reset transform to center things a bit
        scatter.transform = { x: 0, y: 0, scale: 1 };
        
        save();
        renderScatter();
        showToast('Nodes Arranged!');
    }

    // --- Scatter Interactivity (Pan/Drag/Zoom) ---
    
    // Pan Logic
    let lastPan = { x: 0, y: 0 };
    const canvas = document.getElementById('scatterCanvas');

    canvas.addEventListener('pointerdown', (e) => {
      // Ignore if clicking on a card or if a card drag is in progress
      if (e.target.closest('.scatter-card') || scatter.dragging) {
        return;
      }
      
      e.preventDefault();
      scatter.panning = true;
      canvas.setPointerCapture(e.pointerId);
      
      lastPan.x = e.clientX;
      lastPan.y = e.clientY;
    });

    canvas.addEventListener('pointermove', (e) => {
      if (scatter.panning) {
        const dx = e.clientX - lastPan.x;
        const dy = e.clientY - lastPan.y;
        
        scatter.transform.x += dx;
        scatter.transform.y += dy;
        
        lastPan.x = e.clientX;
        lastPan.y = e.clientY;
        
        applyScatterTransform();
      }
    });

    canvas.addEventListener('pointerup', (e) => {
      if (scatter.panning) {
        scatter.panning = false;
        canvas.releasePointerCapture(e.pointerId);
        save();
      }
    });

    // Drag Logic
    function startDrag(e, item) {
      if (e.button !== 0) return; // Only left mouse button

      const card = e.currentTarget;
      
      scatter.dragging = true;
      card.classList.add('is-dragging');
      card.setPointerCapture(e.pointerId);
      
      // Bring to front
      card.style.zIndex = 1000; 

      const containerRect = canvas.getBoundingClientRect();
      const startItemX = item.pos.x;
      const startItemY = item.pos.y;
      
      const startClientX = e.clientX - containerRect.left;
      const startClientY = e.clientY - containerRect.top;
      
      const invScale = 1 / scatter.transform.scale;
      const startCanvasX = (startClientX - scatter.transform.x) * invScale;
      const startCanvasY = (startClientY - scatter.transform.y) * invScale;

      function move(eMove) {
        if (eMove.pointerId !== e.pointerId) return;
        
        const currentClientX = eMove.clientX - containerRect.left;
        const currentClientY = eMove.clientY - containerRect.top;
        
        const currentCanvasX = (currentClientX - scatter.transform.x) * invScale;
        const currentCanvasY = (currentClientY - scatter.transform.y) * invScale;
        
        const newX = startItemX + (currentCanvasX - startCanvasX);
        const newY = startItemY + (currentCanvasY - startCanvasY);
        
        card.style.transform = `translate(${newX - startItemX}px, ${newY - startItemY}px)`;
      }

      function end(eEnd) {
        if (eEnd.pointerId !== e.pointerId) return;
        
        document.removeEventListener('pointermove', move);
        document.removeEventListener('pointerup', end);
        document.removeEventListener('pointercancel', end);
        card.classList.remove('is-dragging');
        // FIX: Reset zIndex after drag is complete to fix timer/overlap issues
        card.style.zIndex = item.status === 'active' ? 5 : 1; 
        const currentClientX = eEnd.clientX - containerRect.left;
        const currentClientY = eEnd.clientY - containerRect.top;
        
        const currentCanvasX = (currentClientX - scatter.transform.x) * invScale;
        const currentCanvasY = (currentClientY - scatter.transform.y) * invScale;
        
        const newX = startItemX + (currentCanvasX - startCanvasX);
        const newY = startItemY + (currentCanvasY - startCanvasY);
        item.pos = {x: newX, y: newY};
        card.style.left = `${newX}px`;
        card.style.top = `${newY}px`;
        card.style.transform = '';
        setTimeout(() => scatter.dragging = false, 50); // Small delay to prevent immediate click
        save();
      }

      document.addEventListener('pointermove', move);
      document.addEventListener('pointerup', end);
      document.addEventListener('pointercancel', end);
    }

    // Zoom Logic
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      
      const zoomFactor = -e.deltaY / 1000; 
      zoom(zoomFactor, e.clientX, e.clientY);
      save();
    });
    
    // Pinch to zoom (for mobile/touch devices)
    let pointers = [];

    canvas.addEventListener('touchstart', (e) => {
        pointers = Array.from(e.touches);
    });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        
        if (e.touches.length === 2) {
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];

            const dist = Math.hypot(touch1.clientX - touch2.clientX, touch1.clientY - touch2.clientY);
            
            if (scatter.pinchStart === 0) {
                scatter.pinchStart = dist;
                return;
            }
            
            const scaleChange = dist / scatter.pinchStart;
            
            const centerX = (touch1.clientX + touch2.clientX) / 2;
            const centerY = (touch1.clientY + touch2.clientY) / 2;

            const oldScale = scatter.transform.scale;
            let newScale = oldScale * scaleChange;
            
            // Clamp scale
            newScale = Math.max(0.25, Math.min(3, newScale)); 
            
            const scaleRatio = newScale / oldScale;

            scatter.transform.x = centerX - (centerX - scatter.transform.x) * scaleRatio;
            scatter.transform.y = centerY - (centerY - scatter.transform.y) * scaleRatio;
            scatter.transform.scale = newScale;
            
            scatter.pinchStart = dist;
            applyScatterTransform();
        } else if (e.touches.length === 1 && !e.target.closest('.scatter-card')) {
             // Treat single touch move as pan if not dragging a card
             const touch = e.touches[0];
             const dx = touch.clientX - lastPan.x;
             const dy = touch.clientY - lastPan.y;
            
             scatter.transform.x += dx;
             scatter.transform.y += dy;
            
             lastPan.x = touch.clientX;
             lastPan.y = touch.clientY;
            
             applyScatterTransform();
        }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
        pointers = Array.from(e.touches);
        if (e.touches.length < 2) {
            scatter.pinchStart = 0;
            save();
        }
    });

    function zoom(zoomFactor, clientX, clientY) {
      const scaleDelta = 1 + zoomFactor;
      const oldScale = scatter.transform.scale;
      let newScale = oldScale * scaleDelta;

      // Clamp scale
      newScale = Math.max(0.25, Math.min(3, newScale)); 
      
      const scaleRatio = newScale / oldScale;

      // Adjust translation to keep the zoom origin (clientX, clientY) fixed
      scatter.transform.x = clientX - (clientX - scatter.transform.x) * scaleRatio;
      scatter.transform.y = clientY - (clientY - scatter.transform.y) * scaleRatio;
      scatter.transform.scale = newScale;
      
      applyScatterTransform();
    }
    
    // --- Context Menu Logic ---
    
    function showContextMenu(e, nodeId) {
        const menu = document.getElementById('contextMenu');
        const item = items.find(i => i.id == nodeId);
        if (!item) return;

        menu.innerHTML = `
            <div class="ctx-header">${item.provider} Node</div>
            <div class="ctx-item" onclick="openModal(${nodeId})">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path></svg>
                <span>Edit Node</span>
            </div>
            ${item.status !== 'active' ? `<div class="ctx-item" onclick="activateNode(${nodeId})">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 14H9V8h2v8zm4 0h-2V8h2v8z"></path></svg>
                <span>Mark Active & Use</span>
            </div>` : ''}
            ${item.status !== 'ready' ? `<div class="ctx-item" onclick="confirmForceRestore(${nodeId})">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.74 15.42 20 13.75 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 9.74C4.26 11.02 4 12.63 4 14c0 4.42 3.58 8 8 8V23l4-4-4-4v3z"></path></svg>
                <span>Force Ready</span>
            </div>` : ''}
            ${item.status !== 'cooldown' ? `<div class="ctx-item" onclick="confirmHitLimit(${nodeId})">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"></path></svg>
                <span>Hit Limit / Cooldown</span>
            </div>` : ''}
        `;
        
        menu.style.left = `${e.clientX}px`;
        menu.style.top = `${e.clientY}px`;
        menu.classList.add('active');
        
        // Hide menu on next click
        const hide = () => {
            menu.classList.remove('active');
            document.removeEventListener('click', hide);
            document.removeEventListener('contextmenu', hide);
        };
        setTimeout(() => document.addEventListener('click', hide), 10);
    }
    
    function showBackgroundContextMenu(e) {
      const menu = document.getElementById('contextMenu');
      menu.innerHTML = `
          <div class="ctx-header">Scatter Options</div>
          <div class="ctx-item" onclick="autoArrange()">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M4 11h7V4H4v7zm0 9h7v-7H4v7zm9 0h7v-7h-7v7zm0-16v7h7V4h-7z"></path></svg>
              <span>Auto Arrange</span>
          </div>
      `;
      
      menu.style.left = `${e.clientX}px`;
      menu.style.top = `${e.clientY}px`;
      menu.classList.add('active');
      
      // Hide menu on next click
      const hide = () => {
          menu.classList.remove('active');
          document.removeEventListener('click', hide);
          document.removeEventListener('contextmenu', hide);
      };
      setTimeout(() => document.addEventListener('click', hide), 10);
    }

    function closeContextMenu() {
      document.getElementById('contextMenu').classList.remove('active');
    }
    
    // Hide context menu if clicking outside of it (already handled by hide function, but just in case)
    document.addEventListener('click', (e) => {
        if (!e.target.closest('#contextMenu')) {
            document.getElementById('contextMenu').classList.remove('active');
        }
    });


    // --- Status & Action Handlers ---
    
    function activateNode(nodeId) {
        closeActionOverlay();
        const item = items.find(i => i.id == nodeId);
        if (!item) return;
        
        // 1. Reset any previously active node to cooldown/ready
        const previouslyActive = items.find(i => i.status === 'active' && i.id !== nodeId);
        if (previouslyActive) {
            const usedTime = Date.now() - previouslyActive.lastUsed;
            const resetTime = previouslyActive.resetHours * 60 * 60 * 1000;
            
            if (usedTime >= resetTime) {
                previouslyActive.status = 'ready'; // Time expired, reset to ready
            } else {
                previouslyActive.status = 'cooldown'; // Time not expired, set to cooldown
            }
            previouslyActive.lastUsed = Date.now();
        }

        // 2. Activate the new node
        item.status = 'active';
        item.lastUsed = Date.now();
        
        // 3. Copy email (already done in ActionOverlay, but ensure on direct activation)
        copyToClipboard(item.email);

        save();
        renderAll();
    }
    
    function hitLimit(nodeId) {
        closeConfirm();
        const item = items.find(i => i.id == nodeId);
        if (!item) return;

        // Only move to cooldown if it's currently active or ready (if ready, skip straight to cooldown)
        if (item.status === 'active' || item.status === 'ready') {
            item.status = 'cooldown';
            item.lastUsed = Date.now();
            save();
            renderAll();
            showToast(`${item.provider} Node is now in Cooldown.`);
        }
    }
    
    function forceRestore(nodeId) {
        closeConfirm();
        const item = items.find(i => i.id == nodeId);
        if (!item) return;

        item.status = 'ready';
        item.lastUsed = Date.now() - (item.resetHours * 60 * 60 * 1000) * 2; // Set last used far in past to ensure ready state
        save();
        renderAll();
        showToast(`${item.provider} Node is Force Ready.`);
    }

    // --- Modal/Dialog Management ---

    function setupProviderSelect(currentProvider = 'ChatGPT') {
      const select = document.getElementById('inpProvider');
      select.innerHTML = '';
      
      const sortedProviders = [...providers].sort();
      sortedProviders.forEach(provider => {
        const option = document.createElement('option');
        option.value = provider;
        option.textContent = provider;
        if (provider === currentProvider) {
          option.selected = true;
        }
        select.appendChild(option);
      });
      
      // Add 'Custom' option
      const customOption = document.createElement('option');
      customOption.value = 'Custom';
      customOption.textContent = 'Custom Provider...';
      select.appendChild(customOption);

      select.onchange = (e) => {
        if (e.target.value === 'Custom') {
          const newProvider = prompt("Enter new provider name:");
          if (newProvider && newProvider.trim()) {
            const cleanNewProvider = newProvider.trim();
            if (!providers.includes(cleanNewProvider)) {
              providers.push(cleanNewProvider);
              save();
            }
            setupProviderSelect(cleanNewProvider); // Re-render with new one selected
          } else {
            // Revert selection if user cancels prompt
            setupProviderSelect(currentProvider);
          }
        }
      };
    }

    function selectStatusButton(status) {
        document.querySelectorAll('.btn-toggle').forEach(b => b.classList.remove('selected'));
        document.querySelector(`.btn-toggle[data-status="${status}"]`).classList.add('selected');
        document.getElementById('inpStatus').value = status;
    }
    
    function selectResetHours(hours) {
        document.querySelectorAll('.pill-option').forEach(p => p.classList.remove('selected'));
        document.querySelector(`.pill-option[data-hours="${hours}"]`).classList.add('selected');
        document.getElementById('inpReset').value = hours;
        document.getElementById('inpResetCustom').value = ''; // Clear custom input
    }
    
    document.getElementById('inpResetCustom').addEventListener('input', (e) => {
        document.querySelectorAll('.pill-option').forEach(p => p.classList.remove('selected'));
        const value = parseFloat(e.target.value);
        if (!isNaN(value) && value > 0) {
            document.getElementById('inpReset').value = value;
        } else if (e.target.value === '') {
            // Re-select default or current value if custom is cleared
            selectResetHours(document.getElementById('inpReset').value || 3);
        }
    });

    function openModal(nodeId = null) {
      const modal = document.getElementById('modalOverlay');
      const form = document.getElementById('nodeForm');
      const title = document.getElementById('modalTitle');
      const btnDelete = document.getElementById('btnDelete');
      const editActions = document.getElementById('editActions');
      
      form.reset();
      
      let item = {
        provider: 'ChatGPT', 
        email: '', 
        status: 'ready', 
        resetHours: 3 
      };

      if (nodeId !== null) {
        item = items.find(i => i.id == nodeId);
        title.textContent = `Edit: ${item.provider}`;
        document.getElementById('nodeId').value = nodeId;
        document.getElementById('inpEmail').value = item.email;
        document.getElementById('inpReset').value = item.resetHours;
        btnDelete.style.display = 'block';
        editActions.style.display = 'flex';
      } else {
        title.textContent = 'New Node';
        document.getElementById('nodeId').value = '';
        btnDelete.style.display = 'none';
        editActions.style.display = 'none';
      }
      
      setupProviderSelect(item.provider);
      selectStatusButton(item.status);
      selectResetHours(item.resetHours);
      
      modal.classList.add('active');
    }

    function closeModal() {
      document.getElementById('modalOverlay').classList.remove('active');
    }

    document.getElementById('nodeForm').onsubmit = function(e) {
      e.preventDefault();
      
      const nodeId = document.getElementById('nodeId').value;
      const provider = document.getElementById('inpProvider').value;
      const email = document.getElementById('inpEmail').value.trim();
      const status = document.getElementById('inpStatus').value;
      const resetHours = parseFloat(document.getElementById('inpReset').value);
      
      if (!email || isNaN(resetHours) || resetHours <= 0) {
        showToast('Please check form inputs.');
        return;
      }
      
      const now = Date.now();
      
      if (nodeId) {
        // Edit existing node
        const item = items.find(i => i.id == nodeId);
        item.provider = provider;
        item.email = email;
        
        // If status changes, update lastUsed timestamp
        if (item.status !== status) {
            item.status = status;
            item.lastUsed = now; // Reset timer on status change
        }
        item.resetHours = resetHours;

        if (!providers.includes(provider)) {
             providers.push(provider);
        }
        showToast('Node Updated!');

      } else {
        // Create new node
        const newItem = {
          id: now + Math.floor(Math.random() * 1000),
          provider: provider,
          email: email,
          status: status,
          resetHours: resetHours,
          lastUsed: now,
          pos: { x: 50, y: 50 } // Default position for scatter view
        };
        items.push(newItem);

        if (!providers.includes(provider)) {
            providers.push(provider);
        }
        showToast('New Node Added!');
      }

      save();
      closeModal();
      renderAll();
    };
    
    function deleteNode() {
        const nodeId = document.getElementById('nodeId').value;
        const item = items.find(i => i.id == nodeId);
        if (!item) return;
        
        confirmAction(`Delete ${item.provider}?`, 'This action cannot be undone.', () => {
            items = items.filter(i => i.id != nodeId);
            save();
            closeModal();
            renderAll();
            showToast('Node Deleted!');
        });
    }

    function confirmAction(title, text, callback) {
        const overlay = document.getElementById('confirmOverlay');
        document.getElementById('confirmTitle').textContent = title;
        document.getElementById('confirmText').textContent = text;
        const btnConfirm = document.getElementById('btnConfirmAction');
        
        // Clone the button to remove existing listeners
        const newBtnConfirm = btnConfirm.cloneNode(true);
        btnConfirm.parentNode.replaceChild(newBtnConfirm, btnConfirm);

        newBtnConfirm.onclick = callback;
        overlay.classList.add('active');
    }

    function closeConfirm() {
        document.getElementById('confirmOverlay').classList.remove('active');
    }
    
    function confirmHitLimit(nodeId) {
        closeContextMenu();
        const id = nodeId || document.getElementById('nodeId').value;
        const item = items.find(i => i.id == id);
        if (!item) return;

        confirmAction(`Hit Limit: ${item.provider}`, `Mark this node as 'cooldown' and start its ${item.resetHours}h reset timer?`, () => hitLimit(id));
    }
    
    function confirmForceRestore(nodeId) {
        closeContextMenu();
        const id = nodeId || document.getElementById('nodeId').value;
        const item = items.find(i => i.id == id);
        if (!item) return;

        confirmAction(`Force Ready: ${item.provider}`, `Immediately set this node's status to 'ready'?`, () => forceRestore(id));
    }

    function openActionOverlay(nodeId) {
        const overlay = document.getElementById('actionOverlay');
        const item = items.find(i => i.id == nodeId);
        if (!item || item.status !== 'ready') return;
        
        document.getElementById('actionTitle').textContent = `Activate ${item.provider}`;
        document.getElementById('actionEmail').value = item.email;
        copyToClipboard(item.email);
        
        const btnActivate = document.getElementById('btnActivateNode');
        // Clone button to remove listeners
        const newBtnActivate = btnActivate.cloneNode(true);
        btnActivate.parentNode.replaceChild(newBtnActivate, btnActivate);
        newBtnActivate.onclick = () => activateNode(nodeId);

        overlay.classList.add('active');
    }

    function closeActionOverlay() {
        document.getElementById('actionOverlay').classList.remove('active');
    }

    function openInfoModal() {
        document.getElementById('infoOverlay').classList.add('active');
    }
    
    function closeInfoModal() {
        document.getElementById('infoOverlay').classList.remove('active');
    }

    function toggleTheme() {
        const body = document.body;
        const currentTheme = body.getAttribute('data-theme');
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        body.setAttribute('data-theme', newTheme);
        localStorage.setItem('iv_theme', newTheme);
    }
    
    // --- Initialization ---

    function renderAll() {
        renderProviderPills();
        updateFilterPill();
        if (config.view === 'grid') {
            renderGrid();
        } else {
            renderScatter();
        }
    }

    function init() {
      load();
      
      const storedTheme = localStorage.getItem('iv_theme');
      if (storedTheme) {
        document.body.setAttribute('data-theme', storedTheme);
      }
      
      // Ensure the correct view is active on load
      switchView(config.view); 

      // Start the timer loop
      timerInterval = setInterval(updateAllTimers, 1000);
      
      // Initial render
      renderAll();

      // Add background context menu for scatter
      const canvas = document.getElementById('scatterCanvas');
      canvas.oncontextmenu = (e) => {
        if (!e.target.closest('.scatter-card')) {
          e.preventDefault();
          showBackgroundContextMenu(e);
        }
      };
    }

    window.addEventListener('load', init);
    window.addEventListener('resize', () => {
        if (config.view === 'scatter') {
            applyScatterTransform(); // Re-center background on resize
        }
    });
    
  </script>
</body>
</html>
