<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Microgravity Cube-Balloons — ES Modules</title>
  <style>
    :root{--bg:#000;--accent:#39FF14;--pink:#FF1493;--mint:#00FF88}
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{background:#000;color:#fff;font-family:Inter,system-ui,monospace;overflow:hidden;cursor:none}
    canvas{display:block;width:100vw;height:100vh}
    #cursor{position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:9999}
    .c-circle{position:absolute;width:18px;height:18px;border-radius:50%;background:radial-gradient(circle,var(--pink),transparent);opacity:0.6;mix-blend-mode:screen}
    .hud{position:fixed;bottom:18px;left:18px;font-size:12px;opacity:0.66;z-index:50}
    #info{position:fixed;top:18px;right:18px;background:rgba(10,10,12,0.7);backdrop-filter:blur(6px);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);font-size:13px;z-index:50}
    .info-row{display:flex;justify-content:space-between;min-width:200px;margin:6px 0}
    .btn{display:none}
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="cursor"></div>
  <div class="hud">[LMB] Select · [Drag] Move · [C] Create · [Space] Shake</div>
  <div id="info">
    <div style="font-weight:700;color:var(--accent);margin-bottom:6px">Cube</div>
    <div class="info-row"><span style="opacity:.7">Position:</span><span id="iPos">0,0,0</span></div>
    <div class="info-row"><span style="opacity:.7">Priority:</span><span id="iPri">Normal</span></div>
    <div class="info-row"><span style="opacity:.7">Color:</span><span id="iColor">Neutral</span></div>
    <div class="info-row"><span style="opacity:.7">State:</span><span id="iState">Default</span></div>
  </div>

  <script type="module">
    // -----------------------------
    // Module imports (ESM)
    // -----------------------------
    import * as THREE from 'https://unpkg.com/three@0.165.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js';
    import { EffectComposer } from 'https://unpkg.com/three@0.165.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.165.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three@0.165.0/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'https://unpkg.com/three@0.165.0/examples/jsm/postprocessing/ShaderPass.js';
    import { CopyShader } from 'https://unpkg.com/three@0.165.0/examples/jsm/shaders/CopyShader.js';
    // cannon-es (ES module compatible)
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';
    // GSAP as ESM
    import gsap from 'https://cdn.jsdelivr.net/npm/gsap@3.12.2/index.js';

    // -----------------------------
    // ThinFilm texture (iridescent)
    // -----------------------------
    class ThinFilm extends THREE.Texture {
      constructor(t = 520) {
        super();
        this.thickness = t;
        this.generate();
      }
      generate() {
        const w = 512, h = 1;
        const d = new Uint8Array(w * 4);
        for (let i = 0; i < w; i++) {
          const c = i / w;
          const u = Math.pow(1 - c, 5);
          const phase = this.thickness / 100 * c * Math.PI * 2;
          let r = 0.04 + 0.96 * u + (Math.sin(phase) * 0.5 + 0.5);
          let g = u + (Math.sin(phase + 2 * Math.PI / 3) * 0.5 + 0.5);
          let b = u + (Math.sin(phase + 4 * Math.PI / 3) * 0.5 + 0.5);
          r = Math.max(0, Math.min(1, r));
          g = Math.max(0, Math.min(1, g));
          b = Math.max(0, Math.min(1, b));
          d[i * 4] = Math.floor(r * 255);
          d[i * 4 + 1] = Math.floor(g * 255);
          d[i * 4 + 2] = Math.floor(b * 255);
          d[i * 4 + 3] = 255;
        }
        this.image = { data: d, width: w, height: h };
        this.magFilter = THREE.LinearFilter;
        this.minFilter = THREE.LinearFilter;
        this.wrapS = THREE.ClampToEdgeWrapping;
        this.wrapT = THREE.ClampToEdgeWrapping;
        this.needsUpdate = true;
      }
    }

    // -----------------------------
    // Scene, camera, renderer, composer
    // -----------------------------
    const canvas = document.getElementById('canvas');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.FogExp2(0x000000, 0.005);

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
    camera.position.set(0, 20, 40);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // composer + bloom
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.6, 0.8, 0.15);
    composer.addPass(bloomPass);

    // optional controls for debugging (not shown in UI)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableZoom = true;
    controls.enabled = false; // disable by default; re-enable for debugging

    // -----------------------------
    // Physics world (microgravity)
    // -----------------------------
    const world = new CANNON.World();
    world.broadphase = new CANNON.NaiveBroadphase();
    world.solver.iterations = 8;
    world.gravity.set(0, -0.6, 0); // microgravity

    const defaultMat = new CANNON.Material('defaultMat');
    world.addContactMaterial(new CANNON.ContactMaterial(defaultMat, defaultMat, { friction: 0.2, restitution: 0.25 }));

    // -----------------------------
    // Lighting (neon + directional)
    // -----------------------------
    scene.add(new THREE.AmbientLight(0xffffff, 0.45));

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.6);
    dirLight.position.set(10, 40, 20);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    dirLight.shadow.bias = -0.0005;
    scene.add(dirLight);

    const neonCyan = new THREE.PointLight(0x00ffff, 3.8, 90, 2);
    neonCyan.position.set(-25, 18, -25);
    scene.add(neonCyan);

    const neonMag = new THREE.PointLight(0xff00ff, 3.8, 90, 2);
    neonMag.position.set(25, 18, 25);
    scene.add(neonMag);

    const neonMint = new THREE.PointLight(0x00ff88, 4.0, 90, 2);
    neonMint.position.set(0, 28, 0);
    scene.add(neonMint);

    // ThinFilm and cube reflection RT
    const fMap = new ThinFilm(520);
    const cubeRT = new THREE.WebGLCubeRenderTarget(512, { format: THREE.RGBFormat, generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter });
    const cubeCam = new THREE.CubeCamera(0.1, 1000, cubeRT);
    scene.add(cubeCam);

    // -----------------------------
    // Ground — black + thinfilm fresnel
    // -----------------------------
    const groundGeo = new THREE.PlaneGeometry(220, 220);
    const groundMat = new THREE.MeshPhysicalMaterial({
      color: 0x000000,
      metalness: 0.9,
      roughness: 0.6,
      clearcoat: 0.6,
      envMap: cubeRT.texture,
      envMapIntensity: 1.0
    });

    // inject thinfilm into ground shader
    groundMat.onBeforeCompile = (shader) => {
      shader.uniforms.fresnelMap = { value: fMap };
      shader.fragmentShader = 'uniform sampler2D fresnelMap;\n' + shader.fragmentShader;
      shader.fragmentShader = shader.fragmentShader.replace(
        '#include <normal_fragment_maps>',
        `#include <normal_fragment_maps>
         vec3 viewDir = normalize( vViewPosition );
         float dnv = clamp( dot( normal, viewDir ), 0.0, 1.0 );
         vec3 irid = texture2D( fresnelMap, vec2( dnv, 0.0 ) ).rgb;
         irid = irid * irid;`
      );
      shader.fragmentShader = shader.fragmentShader.replace(
        '#include <lights_fragment_end>',
        `#include <lights_fragment_end>
         reflectedLight.directSpecular *= (0.25 + 0.75 * irid);
         reflectedLight.indirectSpecular *= (0.25 + 0.75 * irid);`
      );
    };

    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -8;
    ground.receiveShadow = true;
    scene.add(ground);

    const groundShape = new CANNON.Plane();
    const groundBody = new CANNON.Body({ mass: 0, material: defaultMat });
    groundBody.addShape(groundShape);
    groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
    groundBody.position.set(0, -8, 0);
    world.addBody(groundBody);

    // timeline grid lines
    for (let i = -50; i <= 50; i += 5) {
      const pts = [ new THREE.Vector3(-20, -7.9, i), new THREE.Vector3(20, -7.9, i) ];
      const mat = new THREE.LineBasicMaterial({ color: (i % 10 === 0) ? 0x443355 : 0x20202a, transparent: true, opacity: 0.9 });
      const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat);
      scene.add(line);
      if (i % 10 === 0) {
        const c = document.createElement('canvas'); c.width = 128; c.height = 64;
        const cx = c.getContext('2d'); cx.fillStyle = '#777799'; cx.font = 'bold 26px monospace'; cx.textAlign = 'center';
        cx.fillText(Math.abs(i) + 'Y', 64, 40);
        const sp = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(c) }));
        sp.position.set(22, -7.5, i);
        sp.scale.set(3.2, 1.6, 1);
        scene.add(sp);
      }
    }

    // -----------------------------
    // Helpers: thinfilm injection for cubes
    // -----------------------------
    function injectThinFilmOnMaterial(mat) {
      mat.onBeforeCompile = function (shader) {
        shader.uniforms.fresnelMap = { value: fMap };
        shader.fragmentShader = 'uniform sampler2D fresnelMap;\n' + shader.fragmentShader;
        shader.fragmentShader = shader.fragmentShader.replace(
          '#include <normal_fragment_maps>',
          `#include <normal_fragment_maps>
           vec3 viewDir = normalize( vViewPosition );
           float dnv = clamp( dot( normal, viewDir ), 0.0, 1.0 );
           vec3 irid = texture2D( fresnelMap, vec2( dnv, 0.0 ) ).rgb;
           irid = irid * irid;`
        );
        shader.fragmentShader = shader.fragmentShader.replace(
          '#include <lights_fragment_end>',
          `#include <lights_fragment_end>
           reflectedLight.directSpecular *= (0.5 + 0.9 * irid);
           reflectedLight.indirectSpecular *= (0.5 + 0.9 * irid);`
        );
      };
    }

    // click-state materials (kept)
    const pMat = new THREE.MeshPhysicalMaterial({
      color: 0xffffff,
      metalness: 0.12,
      roughness: 0.08,
      clearcoat: 1.0,
      emissive: new THREE.Color(0xFF1493),
      emissiveIntensity: 1.2,
      envMap: cubeRT.texture,
      envMapIntensity: 1.0
    });
    const sMat = new THREE.MeshPhysicalMaterial({
      color: 0xffffff,
      metalness: 0.0,
      roughness: 0.0,
      clearcoat: 1.0,
      emissive: new THREE.Color(0xFF1493),
      emissiveIntensity: 2.2,
      envMap: cubeRT.texture,
      envMapIntensity: 1.0
    });
    injectThinFilmOnMaterial(pMat);
    injectThinFilmOnMaterial(sMat);

    // -----------------------------
    // Cube-Balloon class (CANNON constraint + visual string)
    // -----------------------------
    const cubes = [];
    let selected = null;

    function biasedMintPink() {
      const t = Math.random();
      if (t < 0.65) {
        const h = 0.38 + Math.random() * 0.12;
        return new THREE.Color().setHSL(h, 0.95, 0.55);
      } else {
        const h = 0.88 + Math.random() * 0.10;
        return new THREE.Color().setHSL(h, 0.9, 0.55);
      }
    }

    class CubeBalloon {
      constructor(x = (Math.random()-0.5)*20, y = Math.random()*6 + 2, z = (Math.random()-0.5)*60, size = 1.6) {
        this.size = size;
        this.state = 'def';
        this.priority = Math.round(y);
        this.puls = false;

        const geo = new THREE.BoxGeometry(size, size, size);
        this.emColor = biasedMintPink();

        const mat = new THREE.MeshPhysicalMaterial({
          color: 0xffffff,
          metalness: 1.0,
          roughness: 0.05,
          clearcoat: 1.0,
          emissive: this.emColor.clone(),
          emissiveIntensity: 2.6,
          envMap: cubeRT.texture,
          envMapIntensity: 1.6
        });
        injectThinFilmOnMaterial(mat);

        this.mesh = new THREE.Mesh(geo, Array(6).fill(mat));
        this.mesh.position.set(x, y, z);
        this.mesh.castShadow = true;
        this.mesh.receiveShadow = true;
        scene.add(this.mesh);

        // physics body (very light)
        this.body = new CANNON.Body({ mass: 0.22, material: defaultMat });
        const half = size / 2;
        this.body.addShape(new CANNON.Box(new CANNON.Vec3(half, half, half)));
        this.body.position.set(x, y, z);
        this.body.linearDamping = 0.12;
        this.body.angularDamping = 0.25;
        world.addBody(this.body);

        // anchor above + distance constraint (string)
        const stringLength = 7 + Math.random() * 6;
        const anchor = new CANNON.Body({ mass: 0 });
        anchor.addShape(new CANNON.Sphere(0.01));
        anchor.position.set(x + (Math.random()-0.5)*0.6, y + stringLength, z + (Math.random()-0.5)*0.6);
        world.addBody(anchor);
        this.anchor = anchor;

        const constraint = new CANNON.DistanceConstraint(this.body, anchor, stringLength);
        world.addConstraint(constraint);
        this.constraint = constraint;

        // visual string
        const positions = new Float32Array(6);
        positions[0] = this.mesh.position.x;
        positions[1] = this.mesh.position.y;
        positions[2] = this.mesh.position.z;
        positions[3] = this.anchor.position.x;
        positions[4] = this.anchor.position.y;
        positions[5] = this.anchor.position.z;
        const strGeo = new THREE.BufferGeometry();
        strGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const strMat = new THREE.LineBasicMaterial({ color: 0xdddddd, linewidth: 1, transparent: true, opacity: 0.6 });
        this.string = new THREE.Line(strGeo, strMat);
        scene.add(this.string);

        // glow
        const glowGeo = new THREE.SphereGeometry(0.18, 8, 8);
        const glowMat = new THREE.MeshBasicMaterial({ color: this.emColor.clone(), transparent: true, opacity: 0.95 });
        this.glow = new THREE.Mesh(glowGeo, glowMat);
        this.glow.position.copy(this.mesh.position);
        scene.add(this.glow);

        // edges
        const edges = new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial({ color: 0x111111 }));
        edges.visible = false;
        this.edges = edges;
        this.mesh.add(edges);

        // attach reference for raycasting convenience
        this.mesh.userData.cube = this;
      }

      click() {
        if (this.state === 'def') {
          this.mesh.material = Array(6).fill(pMat);
          this.state = 'pk';
          gsap.to(this.mesh.scale, { x:1.06, y:1.06, z:1.06, duration: 0.14, ease: "back.out" });
        } else if (this.state === 'pk') {
          this.mesh.material = Array(6).fill(sMat);
          this.state = 'sup';
          gsap.to(this.mesh.scale, { x:1.18, y:1.18, z:1.18, duration: 0.22, yoyo:true, repeat:3, ease: "sine.inOut" });
        } else {
          const mat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            metalness: 1.0,
            roughness: 0.05,
            clearcoat: 1.0,
            emissive: this.emColor.clone(),
            emissiveIntensity: 2.6,
            envMap: cubeRT.texture,
            envMapIntensity: 1.6
          });
          injectThinFilmOnMaterial(mat);
          this.mesh.material = Array(6).fill(mat);
          this.state = 'def';
          gsap.to(this.mesh.scale, { x:1, y:1, z:1, duration: 0.18, ease: "power2.out" });
        }
        updateInfoForSelected(this);
      }

      select() { this.edges.visible = true; selected = this; updateInfoForSelected(this); }
      deselect() { this.edges.visible = false; if (selected === this) { selected = null; document.getElementById('iState').textContent = 'Default'; } }

      applyBuoyancy() {
        const buoy = 10 * this.size;
        const jitter = (Math.random() - 0.5) * 2.0;
        this.body.applyForce(new CANNON.Vec3(0, buoy + jitter, 0), this.body.position);
      }

      updateVisuals() {
        this.mesh.position.copy(this.body.position);
        this.mesh.quaternion.copy(this.body.quaternion);

        const pos = this.string.geometry.attributes.position.array;
        pos[0] = this.mesh.position.x; pos[1] = this.mesh.position.y; pos[2] = this.mesh.position.z;
        pos[3] = this.anchor.position.x; pos[4] = this.anchor.position.y; pos[5] = this.anchor.position.z;
        this.string.geometry.attributes.position.needsUpdate = true;

        this.glow.position.copy(this.mesh.position);
        this.glow.position.y += this.size * 0.55;
      }

      remove() {
        scene.remove(this.mesh); scene.remove(this.string); scene.remove(this.glow);
        world.removeConstraint(this.constraint); world.removeBody(this.body); world.removeBody(this.anchor);
      }
    }

    function updateInfoForSelected(c) {
      if (!c) return;
      document.getElementById('iPos').textContent = `${c.body.position.x.toFixed(1)}, ${c.body.position.y.toFixed(1)}, ${c.body.position.z.toFixed(1)}`;
      document.getElementById('iPri').textContent = (c.priority > 3 ? 'High' : c.priority > 0 ? 'Normal' : 'Low');
      const hsl = {}; c.emColor.getHSL(hsl);
      const colorName = (hsl.h > 0.82 || hsl.h < 0.05) ? 'Pink' : (hsl.h > 0.35 && hsl.h < 0.55) ? 'Mint' : 'Neutral';
      document.getElementById('iColor').textContent = colorName;
      document.getElementById('iState').textContent = c.state === 'def' ? 'Default' : (c.state === 'pk' ? 'Pink' : 'Super');
    }

    // create initial set
    for (let i = 0; i < 12; i++) {
      const cb = new CubeBalloon();
      cubes.push(cb);
    }

    // raycast interaction
    const ray = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let dragging = null;

    function getIntersectedCube(e) {
      mouse.x = (e.clientX / innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / innerHeight) * 2 + 1;
      ray.setFromCamera(mouse, camera);
      const intersects = ray.intersectObjects(cubes.map(c => c.mesh));
      if (intersects.length) return intersects[0].object.userData.cube || null;
      return null;
    }

    addEventListener('pointermove', e => {
      if (dragging) {
        // move towards plane intersection
        const plane = new THREE.Plane(new THREE.Vector3(0,1,0), -8);
        const pos = new THREE.Vector3();
        ray.setFromCamera(new THREE.Vector2((e.clientX/innerWidth)*2-1, -(e.clientY/innerHeight)*2+1), camera);
        if (ray.ray.intersectPlane(plane, pos)) {
          const target = new CANNON.Vec3(pos.x, pos.y + 2.2, pos.z);
          const dir = target.vsub(dragging.body.position);
          dragging.body.applyImpulse(new CANNON.Vec3(dir.x*0.08, dir.y*0.08, dir.z*0.08), dragging.body.position);
          dragging.body.wakeUp();
        }
      }
    });

    addEventListener('mousedown', e => {
      const hit = getIntersectedCube(e);
      if (hit) {
        if (selected && selected !== hit) selected.deselect();
        hit.click();
        hit.select();
        dragging = hit;
      } else {
        if (selected) { selected.deselect(); selected = null; }
      }
    });

    addEventListener('mouseup', () => { dragging = null; });

    addEventListener('keydown', e => {
      if (e.key === 'c' || e.key === 'C') {
        const nb = new CubeBalloon();
        cubes.push(nb);
      }
      if (e.key === ' ') {
        cubes.forEach(c => {
          c.body.applyImpulse(new CANNON.Vec3((Math.random()-0.5)*60, (20+Math.random()*50), (Math.random()-0.5)*60), c.body.position);
          c.body.angularVelocity.set((Math.random()-0.5)*40, (Math.random()-0.5)*40, (Math.random()-0.5)*40);
        });
      }
    });

    // cursor trail
    const cursorContainer = document.getElementById('cursor');
    const trailLen = 14;
    for (let i=0;i<trailLen;i++){ const d = document.createElement('div'); d.className = 'c-circle'; cursorContainer.appendChild(d); }
    const circles = Array.from(cursorContainer.querySelectorAll('.c-circle'));
    let mX = innerWidth/2, mY = innerHeight/2;
    const hist = Array(trailLen).fill(0).map(()=>({x:mX,y:mY}));
    addEventListener('pointermove', e => { mX = e.clientX; mY = e.clientY; }, {passive:true});
    function tickCursor(){
      hist.shift(); hist.push({x:mX,y:mY});
      circles.forEach((c,i)=>{
        const cur = hist[i], nx = hist[i+1] || hist[trailLen-1];
        cur.x += (nx.x - cur.x) * 0.35;
        cur.y += (nx.y - cur.y) * 0.35;
        const s = Math.max(0.18, (trailLen - i)/trailLen * 1.1);
        c.style.transform = `translate(calc(${cur.x}px - 50%), calc(${cur.y}px - 50%)) scale(${s})`;
      });
      requestAnimationFrame(tickCursor);
    }
    tickCursor();

    // animation loop
    let last = performance.now() / 1000;
    function animate(){
      requestAnimationFrame(animate);
      const now = performance.now() / 1000;
      const dt = Math.min(now - last, 0.05);
      last = now;

      world.step(1/60, dt, 3);

      cubes.forEach(c=>{
        c.applyBuoyancy();
        c.updateVisuals();
      });

      // update reflection cube map occasionally
      cubeCam.update(renderer, scene);

      composer.render();
    }
    animate();

    // resize handling
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      composer.setSize(innerWidth, innerHeight);
    });

    // expose for debug
    window.__balloons = { scene, camera, renderer, world, cubes };

  </script>
</body>
</html>
