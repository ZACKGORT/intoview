<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Prompt:Rotation 3D - LLM Status Matrix</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <style>
        /* BASE STYLES from sandbox.html */
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        :root {
            --bg-color: #0f1014;
            --ink: #ffffff;
            --ink-2: #9f9f9f;
            --accent: #83ff83;
            --glass-bg: rgba(20, 21, 26, 0.6);
            --glass-bg-hover: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.15);
            --corner-pad: clamp(16px, 4vw, 24px);
            --corner-top: calc(env(safe-area-inset-top) + clamp(12px, 2vh, 18px));
            --fab-size: 60px;
            --fab-bottom: calc(env(safe-area-inset-bottom) + clamp(16px, 3vh, 32px));
            --z-ui: 220;
            --z-overlay: 250;
        }
        body { overflow: hidden; font-family: 'Inter', sans-serif; background: var(--bg-color); color: var(--ink); }
        #canvas { display: block; width: 100vw; height: 100vh; outline: none; }
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* UI Elements - Adapted from sandbox.html */
        .corner-reset, .top-toggle-nav, .left-toggle-nav {
            position: fixed; z-index: var(--z-ui); background: var(--glass-bg);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            padding: 6px; border: 1px solid var(--glass-border); border-radius: 8px;
            pointer-events: auto;
        }
        .corner-reset { top: var(--corner-top); right: var(--corner-pad); }
        .left-toggle-nav { left: var(--corner-pad); top: 50%; transform: translateY(-50%); flex-direction: column; display: flex; }
        .top-toggle-nav { top: var(--corner-top); left: 50%; transform: translateX(-50%); display: flex; gap: 8px; }
        .top-toggle-nav button, .left-toggle-nav button {
            padding: 8px 16px; background: transparent; border: none; color: var(--ink);
            cursor: pointer; transition: background 0.2s ease; border-radius: 4px;
        }
        .top-toggle-nav button:hover, .left-toggle-nav button:hover { background: var(--glass-bg-hover); }
        .left-toggle-nav button.active { background: var(--glass-bg-bright, rgba(255, 255, 255, 0.15)); color: var(--accent); }

        /* FAB - NEW ACCOUNT BUTTON */
        .fab {
            position: fixed; bottom: var(--fab-bottom); right: var(--corner-pad); z-index: var(--z-ui);
            width: var(--fab-size); height: var(--fab-size); border-radius: 50%;
            background: var(--glass-bg-bright); backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border); box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            transition: transform 0.2s ease, background 0.2s ease; pointer-events: auto;
        }
        .fab svg { width: 32px; height: 32px; fill: var(--ink); }

        /* OVERLAY SHEETS - Add/Detail */
        .overlay-sheet {
            position: fixed; inset: 0; pointer-events: none; z-index: var(--z-overlay);
            opacity: 0; transition: opacity 0.2s ease; background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
        }
        .overlay-sheet.open { opacity: 1; pointer-events: auto; }
        .sheet {
            position: fixed; right: 0; top: 0; bottom: 0; width: min(400px, 90%);
            background: var(--bg-color); border-left: 1px solid var(--glass-border);
            padding: 24px; overflow-y: auto; box-shadow: -10px 0 30px rgba(0,0,0,0.5);
            transform: translateX(100%); transition: transform 0.3s ease;
        }
        .overlay-sheet.open .sheet { transform: translateX(0); }
        .sheet h2 { color: var(--accent); margin-bottom: 20px; font-family: 'JetBrains Mono'; }
        .form-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-size: 0.9em; color: var(--ink-2); }
        input, select, textarea {
            width: 100%; padding: 10px; background: var(--glass-bg-hover);
            border: 1px solid var(--glass-border); color: var(--ink); border-radius: 4px;
            font-family: 'JetBrains Mono'; font-size: 1em;
        }
        .btn-submit {
            padding: 12px 24px; background: var(--accent); color: #000;
            border: none; border-radius: 4px; cursor: pointer; margin-top: 20px;
            font-weight: 700; text-transform: uppercase; width: 100%;
        }
        .close-btn {
            position: absolute; top: 16px; right: 16px; background: transparent;
            border: none; font-size: 28px; cursor: pointer; color: var(--ink);
            opacity: 0.7; transition: opacity 0.2s;
        }

        /* CARD DETAIL STYLES */
        #detailSheet p { margin-bottom: 10px; }
        #detailSheet strong { color: var(--accent); }
        .status-badge { display: inline-block; padding: 4px 10px; border-radius: 16px; font-size: 0.8em; font-weight: 700; text-transform: uppercase; margin-left: 10px; }
        .status-active { background: #144714; color: #83ff83; }
        .status-cooldown { background: #473214; color: #ff8d14; }
        .status-burnt { background: #471414; color: #FF1447; }
        .timer-display { font-family: 'JetBrains Mono'; font-size: 1.2em; color: #FF8D14; margin-top: 5px; }


        /* HOVER TOOLTIP */
        #hoverTooltip {
            position: fixed;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--glass-border);
            color: var(--ink);
            border-radius: 4px;
            pointer-events: none;
            z-index: 300;
            opacity: 0;
            transition: opacity 0.1s;
            font-size: 12px;
            font-family: 'JetBrains Mono';
        }
    </style>
</head>
<body data-theme="dark">
    <div class="logo">
        </div>

    <canvas id="canvas"></canvas>
    
    <div class="overlay">
        <div class="corner-reset">
            <button id="resetTopBtn" title="Reset all cubes/planes to their initial positions."><span class="text">Reset Physics</span><span class="emoji">ðŸ”„</span></button>
        </div>

        <div class="left-toggle-nav">
            <button id="macroBtn" class="active" title="Grid View: Stacked Wall">Grid</button>
            <button id="microBtn" title="List View: Free-fall Scatter">Scatter</button>
        </div>

        <button id="fabButton" class="fab" aria-label="Add New Account">
            <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z"/></svg>
        </button>
    </div>

    <div id="addSheetOverlay" class="overlay-sheet">
        <div id="addSheet" class="sheet">
            <button class="close-btn" onclick="closeAddSheet()">&times;</button>
            <h2>Add New LLM Node</h2>
            <form id="addAccountForm">
                <div class="form-group">
                    <label for="provider">Provider</label>
                    <select id="provider" required>
                        <option value="ChatGPT">OpenAI (ChatGPT)</option>
                        <option value="Claude">Anthropic (Claude)</option>
                        <option value="Gemini">Google (Gemini)</option>
                        <option value="Grok">xAI (Grok)</option>
                        <option value="Copilot">Microsoft (Copilot)</option>
                        <option value="Other">Other</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="username">Username / Email</label>
                    <input type="text" id="username" required>
                </div>
                <div class="form-group">
                    <label for="password">Password</label>
                    <input type="password" id="password" required>
                </div>
                <div class="form-group">
                    <label for="resetHours">Cooldown/Reset Time (Hours)</label>
                    <input type="number" id="resetHours" value="3" min="0.5" step="0.5" required>
                </div>
                <div class="form-group">
                    <label for="status">Initial Status</label>
                    <select id="status">
                        <option value="active">Active</option>
                        <option value="cooldown">Cooldown</option>
                        <option value="burnt">Burnt/Expired</option>
                    </select>
                </div>
                <button type="submit" class="btn-submit">Initialize Node</button>
            </form>
        </div>
    </div>

    <div id="detailSheetOverlay" class="overlay-sheet">
        <div id="detailSheet" class="sheet">
            <button class="close-btn" onclick="closeDetailSheet()">&times;</button>
            <h2 id="detailProvider"></h2>
            <div id="detailContent">
                </div>
            <button class="btn-submit" onclick="copyLogin()">Copy Login</button>
            <button class="btn-submit" style="background:#FF8D14; color:#000; margin-top:10px;" onclick="toggleCooldown()">Toggle Status</button>
            <button class="btn-submit" style="background:#FF1447; color:#fff; margin-top:10px;" onclick="deleteCard()">Delete Node</button>
        </div>
    </div>

    <div id="hoverTooltip"></div>

    <script>
        // ====================================================================
        // 1. THREE.JS AND CANNON.JS SETUP (Minimal Adaptation of sandbox.html)
        // ====================================================================
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x0f1014, 1);

        const world = new CANNON.World();
        world.gravity.set(0, -19.81, 0); // Stronger gravity for dramatic drop
        world.broadphase = new CANNON.NaiveBroadphase();
        const defaultMaterial = new CANNON.Material();
        const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, { friction: 0.3, restitution: 0.5 });
        world.addContactMaterial(defaultContactMaterial);

        // Ground Plane (Positioned lower than initial sandbox to accommodate card size)
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0, material: defaultMaterial });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        groundBody.position.set(0, -10, 0); // Lowered the floor further for better scatter view
        world.addBody(groundBody);

        let cards = []; // Replaced 'cubes' with 'cards'
        const gridGroup = new THREE.Group();
        scene.add(gridGroup);

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const pointLight = new THREE.PointLight(0xffffff, 10, 100);
        pointLight.position.set(5, 10, 5);
        scene.add(pointLight);

        // Camera Initialization
        camera.position.set(0, 0, 15);

        // Status Colors (Hex -> THREE.Color)
        const STATUS_COLORS = {
            active: new THREE.Color(0x39FF14),  // Neon Green
            cooldown: new THREE.Color(0xFF8D14), // Neon Orange
            burnt: new THREE.Color(0xFF1447),   // Neon Red
        };

        // Standard Card Material (Basic, thin volume)
        const cardMaterial = (color) => new THREE.MeshPhysicalMaterial({
            color: color,
            metalness: 0.1,
            roughness: 0.5,
            clearcoat: 1.0,
            emissive: color,
            emissiveIntensity: 0.3,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.95
        });

        // ====================================================================
        // 2. DATA / LOCALSTORAGE MANAGEMENT
        // ====================================================================
        let accountData = JSON.parse(localStorage.getItem('llm_accounts_3d')) || [];

        function saveAccounts() {
            localStorage.setItem('llm_accounts_3d', JSON.stringify(accountData.map(c => c.data)));
        }

        function generateMockData() {
            const providers = ['ChatGPT', 'Claude', 'Gemini', 'Grok', 'Copilot', 'Other'];
            const statuses = ['active', 'cooldown', 'burnt'];
            return Array.from({ length: 12 }, (_, i) => {
                const status = statuses[i % 3];
                const resetHours = 3 + (i % 4);
                const data = {
                    id: Date.now() + i,
                    provider: providers[i % 6],
                    username: `user${i + 1}@example.com`,
                    password: `pass${i + 1}`,
                    resetHours: resetHours,
                    status: status,
                    cooldownEnd: null,
                    initial: { x: 0, y: 0, z: 0, qx: 0, qy: 0, qz: 0, qw: 1 }
                };
                if (status === 'cooldown') {
                    data.cooldownEnd = Date.now() + (resetHours * 60 * 60 * 1000);
                }
                return { data };
            });
        }

        if (accountData.length === 0) {
            accountData = generateMockData();
            saveAccounts();
        }

        // ====================================================================
        // 3. CARD CREATION AND PHYSICS LOGIC
        // ====================================================================

        const CARD_WIDTH = 4.0;
        const CARD_HEIGHT = 2.5;
        const CARD_DEPTH = 0.2; // Very thin box for physics

        /** Creates a new 3D card (thin box) and its Cannon.js body. */
        function createCard(data, initialDrop = false) {
            const color = STATUS_COLORS[data.status] || STATUS_COLORS.active;

            // Mesh: Thin box geometry to act as a flat card
            const cardGeo = new THREE.BoxGeometry(CARD_WIDTH, CARD_HEIGHT, CARD_DEPTH);
            const mesh = new THREE.Mesh(cardGeo, cardMaterial(color));

            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData = { id: data.id }; // Link mesh back to data

            // Body: Very thin Cannon box
            const shape = new CANNON.Box(new CANNON.Vec3(CARD_WIDTH / 2, CARD_HEIGHT / 2, CARD_DEPTH / 2));
            const body = new CANNON.Body({ mass: 5, shape: shape, material: defaultMaterial });

            let x, y, z;
            if (initialDrop) {
                // Drop from above the viewport
                x = (Math.random() - 0.5) * 10;
                y = 20 + Math.random() * 10;
                z = (Math.random() - 0.5) * 5;
                body.angularVelocity.set(Math.random() * 5, Math.random() * 5, Math.random() * 5);
            } else {
                // Place on the ground initially (used for grid refresh)
                x = data.initial.x;
                y = data.initial.y;
                z = data.initial.z;
                body.quaternion.set(data.initial.qx, data.initial.qy, data.initial.qz, data.initial.qw);
                body.mass = 0; // Temporarily disable physics for initial placement
                body.velocity.set(0, 0, 0);
                body.angularVelocity.set(0, 0, 0);
            }

            body.position.set(x, y, z);
            
            // Set the plane to be visible (rotated)
            // body.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI/2);
            
            world.addBody(body);
            gridGroup.add(mesh);

            const cardObject = { mesh, body, data, initial: { x: x, y: y, z: z } };
            cards.push(cardObject);
            return cardObject;
        }

        /** Handles the submission of the new account form */
        document.getElementById('addAccountForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const data = {
                id: Date.now(),
                provider: document.getElementById('provider').value,
                username: document.getElementById('username').value,
                password: document.getElementById('password').value, // In a real app, this MUST be encrypted
                resetHours: parseFloat(document.getElementById('resetHours').value),
                status: document.getElementById('status').value,
                cooldownEnd: null,
                initial: { x: 0, y: 0, z: 0, qx: 0, qy: 0, qz: 0, qw: 1 } // Will be set on the next grid update
            };
            
            if (data.status === 'cooldown') {
                data.cooldownEnd = Date.now() + (data.resetHours * 60 * 60 * 1000);
            }

            // 1. Save to data store
            accountData.push({ data });
            saveAccounts();
            
            // 2. Create the card with an immediate drop
            const newCard = createCard(data, true);
            newCard.body.mass = 5; // Enable physics for the drop
            newCard.body.wakeUp();

            // 3. Close UI and clean up
            closeAddSheet();
            e.target.reset();
            
            // 4. Force a grid update soon to stabilize the scene
            setTimeout(() => {
                updateGrid(true); // Recalculate grid positions after a new card drops
            }, 3000);
        });
        
        // ====================================================================
        // 4. GRID/LIST (MACRO/SCATTER) VIEW LOGIC
        // ====================================================================
        let currentView = 'grid'; // 'grid' (macro) or 'scatter' (micro)

        function updateGrid(animateCamera = false) {
            // 1. Clear current meshes and bodies from scene/world
            cards.forEach(card => {
                world.removeBody(card.body);
                gridGroup.remove(card.mesh);
            });
            cards = []; // Clear the local array
            
            // Sort active cards to the front for a cleaner display
            accountData.sort((a, b) => (b.data.status === 'active') - (a.data.status === 'active'));

            const cols = Math.floor(window.innerWidth / 200); // Dynamic columns based on viewport width
            const rows = Math.ceil(accountData.length / cols);
            const spacingX = CARD_WIDTH * 1.1; // Slightly increased spacing for better separation
            const spacingY = CARD_HEIGHT * 1.1;
            const gridWidth = (cols - 1) * spacingX + CARD_WIDTH;
            const gridHeight = (rows - 1) * spacingY + CARD_HEIGHT;

            if (currentView === 'grid') {
                // GRID/MACRO VIEW: Wall of Cards, centered vertically and horizontally
                const startX = -((cols - 1) * spacingX) / 2;
                const startY = -((rows - 1) * spacingY) / 2;
                
                accountData.forEach((account, index) => {
                    const row = Math.floor(index / cols);
                    const col = index % cols;
                    
                    const x = startX + col * spacingX;
                    const y = startY + row * spacingY;
                    const z = 0; // Cards are close to the camera

                    // Update initial/saved position
                    account.data.initial = { x, y, z, qx: 0, qy: 0, qz: 0, qw: 1 };
                    
                    // Create the card at its final, fixed position
                    const cardObject = createCard(account.data, false);
                    cardObject.body.position.set(x, y, z);
                    cardObject.body.quaternion.set(0, 0, 0, 1);
                    cardObject.body.mass = 0; // Lock in place
                });

                // Calculate optimal camera Z to fit the grid with padding
                const vfov = camera.fov * Math.PI / 180;
                const hfov = 2 * Math.atan(Math.tan(vfov / 2) * camera.aspect);
                const requiredZForHeight = (gridHeight / 2) / Math.tan(vfov / 2);
                const requiredZForWidth = (gridWidth / 2) / Math.tan(hfov / 2);
                const requiredZ = Math.max(requiredZForHeight, requiredZForWidth) * 1.2; // 20% padding

                // Animate camera to centered grid view
                gsap.to(camera.position, { duration: animateCamera ? 2 : 0.5, x: 0, y: 0, z: requiredZ, ease: "power2.inOut" });

            } else {
                // SCATTER/LIST VIEW: Free-fall/Natural Positions
                accountData.forEach((account) => {
                    // Start position high up for the drop animation
                    account.data.initial = { 
                        x: (Math.random() - 0.5) * 10,
                        y: 20 + Math.random() * 10,
                        z: (Math.random() - 0.5) * 5,
                        qx: 0, qy: 0, qz: 0, qw: 1
                    };
                    const cardObject = createCard(account.data, true);
                    cardObject.body.mass = 5; // Enable physics
                    cardObject.body.wakeUp();
                });
                
                // Animate camera to a wider, more distant view, slightly elevated for better overview
                gsap.to(camera.position, { duration: animateCamera ? 2 : 0.5, x: 0, y: 5, z: 25, ease: "power2.inOut" });
            }
            
            saveAccounts();
            updateCardColors();
        }

        // Set up initial grid and handle the left nav toggle
        updateGrid(false); 
        
        document.querySelectorAll('.left-toggle-nav button').forEach(btn => {
            btn.addEventListener('click', () => {
                const newView = btn.id === 'macroBtn' ? 'grid' : 'scatter';
                if (newView !== currentView) {
                    document.querySelectorAll('.left-toggle-nav button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentView = newView;
                    updateGrid(true);
                }
            });
        });

        // ====================================================================
        // 5. STATUS, COLOR, AND DETAIL LOGIC
        // ====================================================================
        let selectedCardId = null;

        function getCardByMesh(mesh) {
            return cards.find(c => c.mesh === mesh);
        }

        function updateCardColors() {
            cards.forEach(card => {
                const now = Date.now();
                let status = card.data.status;
                
                // Auto-restore logic for cooldown cards
                if (status === 'cooldown' && card.data.cooldownEnd && now > card.data.cooldownEnd) {
                    status = 'active';
                    card.data.status = 'active';
                    card.data.cooldownEnd = null;
                    saveAccounts();
                }
                
                const color = STATUS_COLORS[status];
                card.mesh.material.color.set(color);
                card.mesh.material.emissive.set(color);
            });
        }
        
        // Interval to check cooldown status
        setInterval(updateCardColors, 60000); 

        function toggleCooldown() {
            const card = accountData.find(a => a.data.id === selectedCardId);
            if (!card) return;

            if (card.data.status === 'active') {
                card.data.status = 'cooldown';
                card.data.cooldownEnd = Date.now() + (card.data.resetHours * 60 * 60 * 1000);
            } else if (card.data.status === 'cooldown') {
                card.data.status = 'active';
                card.data.cooldownEnd = null;
            } else if (card.data.status === 'burnt') {
                card.data.status = 'active';
                card.data.cooldownEnd = null;
            }

            saveAccounts();
            updateCardColors();
            handleCardClick(card.mesh); // Refresh the detail sheet
        }

        function deleteCard() {
            accountData = accountData.filter(a => a.data.id !== selectedCardId);
            saveAccounts();
            closeDetailSheet();
            updateGrid(false);
        }
        
        function copyLogin() {
            const card = accountData.find(a => a.data.id === selectedCardId);
            if (card) {
                const loginString = `Provider: ${card.data.provider}\nUsername: ${card.data.username}\nPassword: ${card.data.password}`;
                navigator.clipboard.writeText(loginString).then(() => {
                    alert('Login details copied to clipboard!');
                });
            }
        }

        /** Handles clicking a 3D card/plane to open the detail overlay. */
        function handleCardClick(mesh) {
            const card = getCardByMesh(mesh);
            if (!card) return;

            selectedCardId = card.data.id;
            const data = card.data;
            
            document.getElementById('detailProvider').textContent = `${data.provider} Node`;
            
            let statusBadge = '';
            let timerHtml = '';

            switch(data.status) {
                case 'active':
                    statusBadge = `<span class="status-badge status-active">Active</span>`;
                    break;
                case 'cooldown':
                    statusBadge = `<span class="status-badge status-cooldown">Cooldown</span>`;
                    if (data.cooldownEnd) {
                        const diff = data.cooldownEnd - Date.now();
                        const h = Math.floor(diff / (1000 * 60 * 60));
                        const m = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                        timerHtml = `<p>Resetting in: <span class="timer-display">${h}h ${m}m</span></p>`;
                    }
                    break;
                case 'burnt':
                    statusBadge = `<span class="status-badge status-burnt">Burnt</span>`;
                    break;
            }

            document.getElementById('detailContent').innerHTML = `
                <p>Status: ${statusBadge}</p>
                ${timerHtml}
                <hr style="border-color:var(--glass-border); margin: 15px 0;">
                <p><strong>ID:</strong> ${data.username}</p>
                <p><strong>Password:</strong> â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢</p>
                <p><strong>Reset Logic:</strong> ${data.resetHours} hours</p>
                <p style="opacity:0.6; font-size:0.8em; margin-top:15px;">Node ID: ${data.id}</p>
            `;
            
            document.getElementById('detailSheetOverlay').classList.add('open');
        }

        function closeAddSheet() {
            document.getElementById('addSheetOverlay').classList.remove('open');
        }
        
        function closeDetailSheet() {
            document.getElementById('detailSheetOverlay').classList.remove('open');
            selectedCardId = null;
        }

        // ====================================================================
        // 6. INTERACTION (Click & Hover) - IMPULSE LOGIC REMOVED
        // ====================================================================
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltip = document.getElementById('hoverTooltip');
        let intersected = null;

        function onPointerMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Raycast for hover
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cards.map(c => c.mesh));

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const card = getCardByMesh(intersect.object);
                
                if (card) {
                    if (intersected !== card) {
                        intersected = card;
                        tooltip.style.opacity = 1;
                    }
                    
                    // Update Tooltip Position
                    tooltip.style.left = `${event.clientX + 15}px`;
                    tooltip.style.top = `${event.clientY - 15}px`;
                    
                    // Update Tooltip Content (Essential Metrics)
                    let statusText = card.data.status.toUpperCase();
                    if (card.data.status === 'cooldown' && card.data.cooldownEnd) {
                        const diff = card.data.cooldownEnd - Date.now();
                        const h = Math.floor(diff / (1000 * 60 * 60));
                        const m = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                        statusText = `COOLDOWN: ${h}h ${m}m`;
                    } else if (card.data.status === 'burnt') {
                        statusText = 'BURNT (EXPIRED)';
                    }

                    tooltip.innerHTML = `
                        <strong>${card.data.provider}</strong><br>
                        Status: <span style="color:${STATUS_COLORS[card.data.status].getStyle()};">${statusText}</span><br>
                        ID: ${card.data.username.substring(0, 10)}...
                    `;
                }
            } else {
                if (intersected) {
                    intersected = null;
                    tooltip.style.opacity = 0;
                }
            }
        }
        
        function onCardClick(event) {
            if (document.getElementById('addSheetOverlay').classList.contains('open') || document.getElementById('detailSheetOverlay').classList.contains('open')) {
                return; // Ignore clicks if an overlay is open
            }
            
            // Re-run raycast based on click position
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cards.map(c => c.mesh));

            if (intersects.length > 0) {
                handleCardClick(intersects[0].object);
            }
        }

        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('click', onCardClick);
        document.getElementById('fabButton').addEventListener('click', () => {
            document.getElementById('addSheetOverlay').classList.add('open');
        });

        // ====================================================================
        // 7. ANIMATION LOOP
        // ====================================================================

        const targetRotation = { x: 0, y: 0 };
        const currentRotation = { x: 0, y: 0 };
        const fixedTimeStep = 1.0 / 60.0;
        let lastTime = 0;

        function animate() {
            requestAnimationFrame(animate);

            // Time step for physics
            const currentTime = performance.now() / 1000;
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            const safeDelta = Math.min(deltaTime, 0.1);
            world.step(fixedTimeStep, safeDelta, 3);

            // Sync Three.js meshes with Cannon.js bodies
            cards.forEach(({ mesh, body }) => {
                mesh.position.copy(body.position);
                mesh.quaternion.copy(body.quaternion);
                
                // Keep the card facing the camera (overrides physics rotation)
                if (currentView === 'grid') {
                    mesh.quaternion.copy(camera.quaternion).invert(); 
                }
            });

            // Camera Rotation (Inherited from sandbox.html)
            currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
            currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;
            scene.rotation.x = currentRotation.x;
            scene.rotation.y = currentRotation.y;
            
            renderer.render(scene, camera);
        }

        animate();

        // ====================================================================
        // 8. UTILITY FUNCTIONS (Reset, Resize)
        // ====================================================================

        function resetCubes() { // Renamed from resetCubes to reflect the action
            cards.forEach(({ body }) => {
                body.position.y = 15 + Math.random() * 10;
                body.velocity.set(0, 0, 0);
                body.angularVelocity.set(Math.random() * 5, Math.random() * 5, Math.random() * 5);
                body.mass = 5; // Re-enable mass to allow drop
                body.wakeUp();
            });
            // Force the grid view to switch to scatter to re-enable physics
            document.getElementById('microBtn').click(); 
        }

        document.getElementById('resetTopBtn').addEventListener('click', resetCubes);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateGrid(false); // Recalculate grid positions on resize
        });
        
        // Mouse/Touch Tracking (Kept from sandbox.html for 3D rotation)
        function onMouseMove(event) {
            targetRotation.y = (event.clientX / window.innerWidth - 0.5) * 0.2;
            targetRotation.x = (event.clientY / window.innerHeight - 0.5) * 0.2;
        }
        window.addEventListener('mousemove', onMouseMove);
    </script>
</body>
</html>
