<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
    <title>Phantom-style Grid — Single File (R3F + Three)</title>

    <!-- Fonts (optional) -->
    <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">

    <style>
      :root{
        --paper:#0E0E10;
        --ink:#FFFFFF;
        --ink-2:#9F9F9F;
        --ink-3:#6C6C6C;
        --accent:#59D2C8;
      }

      *{box-sizing:border-box}
      html,body,#root{height:100%}
      body{
        margin:0; background:var(--paper); color:var(--ink);
        font:14px/1.4 Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial;
        overflow:hidden;
      }
      .header{
        position:fixed; inset:0 0 auto 0; z-index:3;
        display:flex; gap:12px; align-items:baseline;
        padding:14px 16px;
        border-bottom:1px solid var(--ink-2);
        background:linear-gradient(180deg,#0a0a0ccc,#0a0a0c66 40%,transparent);
        backdrop-filter:blur(6px);
      }
      .header .dot{
        width:8px; height:8px; border-radius:50%;
        background:var(--accent);
        box-shadow:0 0 0 6px color-mix(in oklab, var(--accent), transparent 80%);
      }
      .header h1{margin:0; font-size:18px}
      .canvas-wrap{position:absolute; inset:0}

      /* Hairline fallback so something is visible immediately */
      .fallback-grid{
        position:absolute; inset:0; z-index:0; pointer-events:none; opacity:.12;
        color:var(--ink);
        background-image:
          repeating-linear-gradient(to right, currentColor 0 1px, transparent 1px 48px),
          repeating-linear-gradient(to bottom, currentColor 0 1px, transparent 1px 48px);
      }

      .hud{
        position:fixed; z-index:4; inset:auto 12px 12px auto; display:flex; gap:8px;
        font:inherit;
      }
      .hud button{
        appearance:none; cursor:pointer; font:inherit;
        border:1px solid var(--ink-2); background:transparent; color:var(--ink);
        padding:8px 10px; border-radius:10px;
        transition:transform .12s ease;
      }
      .hud button:hover{ transform:translateY(-1px) }
    </style>
  </head>
  <body>
    <header class="header">
      <span class="dot" aria-hidden="true"></span>
      <h1>Phantom-style Grid</h1>
      <small>drag to pan • ambient parallax • flat/curved shader • image tiles</small>
    </header>

    <div id="root"></div>

    <script type="module">
      /* ===========================================================
         ESM imports (versions pinned)
         =========================================================== */
      import React, { useEffect, useMemo, useState, Suspense } from 'https://esm.sh/react@18.3.1';
      import { createRoot } from 'https://esm.sh/react-dom@18.3.1/client';
      import * as THREE from 'https://esm.sh/three@0.160.1';
      import { Canvas, useFrame, useThree } from 'https://esm.sh/@react-three/fiber@8.16.0?deps=react@18.3.1,react-dom@18.3.1,three@0.160.1';
      import gsap from 'https://esm.sh/gsap@3.12.5';

      // three/examples post-processing
      import { EffectComposer } from 'https://esm.sh/three@0.160.1/examples/jsm/postprocessing/EffectComposer.js';
      import { RenderPass } from 'https://esm.sh/three@0.160.1/examples/jsm/postprocessing/RenderPass.js';
      import { ShaderPass } from 'https://esm.sh/three@0.160.1/examples/jsm/postprocessing/ShaderPass.js';
      import { OutputPass } from 'https://esm.sh/three@0.160.1/examples/jsm/postprocessing/OutputPass.js';

      /* ===========================================================
         Plug your images here (URLs, data: URIs, or local paths)
         =========================================================== */
      const IMAGES = [
        // ——— Replace these with your own URLs ———
        'https://picsum.photos/id/1011/1200/800',
        'https://picsum.photos/id/1025/1200/1200',
        'https://picsum.photos/id/1035/800/1200',
        'https://picsum.photos/id/1042/1600/1000',
        'https://picsum.photos/id/1050/1200/900',
        'https://picsum.photos/id/1069/1200/1600',
        'https://picsum.photos/id/1076/1600/1200',
        'https://picsum.photos/id/1084/1200/1200',
        'https://picsum.photos/id/1080/1200/900',
        'https://picsum.photos/id/1003/1600/1100',
      ];

      /* ===========================================================
         Config & state
         =========================================================== */
      const CONFIG = {
        cols: 10,
        rows: 7,
        tile: 0.32,
        gap: 0.08,
        ambient: 0.20,
        dragEase: 0.14,
        velEase: 0.92,
        zoomIn: 0.75,
        zoomOut: 1.85,
        distortion: { flat: 0.0, curved: 0.6 }
      };

      const WorkgridState = { INTRO:'INTRO', DEFAULT:'DEFAULT', RESET:'RESET' };

      /* ===========================================================
         Distortion shader (unchanged)
         =========================================================== */
      class DistortionShader extends THREE.ShaderMaterial {
        constructor(){
          super({
            name:'DistortionShader',
            uniforms:{
              tDiffuse:{ value:null },
              distortion:{ value:new THREE.Vector2(0,0) },
              vignetteOffset:{ value:0.08 },
              vignetteDarkness:{ value:0.38 }
            },
            vertexShader:/* glsl */`
              varying vec2 vUv;
              void main(){ vUv = uv; gl_Position = vec4(position, 1.0); }
            `,
            fragmentShader:/* glsl */`
              precision highp float;
              uniform sampler2D tDiffuse;
              uniform vec2 distortion;
              uniform float vignetteOffset;
              uniform float vignetteDarkness;
              varying vec2 vUv;

              vec2 getShiftedUv(vec2 uv){ return 2.0 * (uv - 0.5); }
              vec2 getUnshiftedUv(vec2 suv){ return suv * 0.5 + 0.5; }

              void main(){
                vec2 suv = getShiftedUv(vUv);
                float d = length(suv);
                suv *= (0.88 + distortion * dot(suv, suv));
                vec2 uv2 = getUnshiftedUv(suv);
                float vig = smoothstep(0.8, vignetteOffset * 0.799,
                                       (vignetteDarkness + vignetteOffset) * d);
                vec3 col = texture2D(tDiffuse, uv2).rgb * vig;
                gl_FragColor = vec4(col, 1.0);
              }
            `
          });
          this._distortionIntensity = 0;
          this.update();
        }
        update(){
          const w = window.innerWidth, h = window.innerHeight;
          const ratio = Math.min(w, h) / Math.max(w, h);
          this.uniforms.distortion.value.set(
            this._distortionIntensity * ratio,
            this._distortionIntensity * ratio
          );
        }
        setDistortion(value){
          gsap.to(this, {
            _distortionIntensity:value, duration:1, ease:'power2.out',
            onUpdate:() => this.update()
          });
        }
      }

      /* ===========================================================
         Utils: load textures + set "cover" crop inside a square tile
         =========================================================== */
      function loadTextures(urls){
        const loader = new THREE.TextureLoader();
        return Promise.all(urls.map(url => new Promise((res, rej) => {
          loader.load(url, tex => {
            // color management for r160+
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.anisotropy = 8;
            tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
            tex.generateMipmaps = true;
            res(tex);
          }, undefined, rej);
        })));
      }

      function applyCoverCrop(tex){
        const img = tex.image;
        if (!img || !img.width || !img.height) return;
        const aspect = img.width / img.height; // w/h
        // Reset
        tex.repeat.set(1,1);
        tex.offset.set(0,0);
        if (aspect > 1){
          // wide → crop left/right
          const rx = 1 / aspect;
          tex.repeat.set(rx, 1);
          tex.offset.set((1 - rx) * 0.5, 0);
        } else if (aspect < 1){
          // tall → crop top/bottom
          const ry = aspect;
          tex.repeat.set(1, ry);
          tex.offset.set(0, (1 - ry) * 0.5);
        }
        tex.needsUpdate = true;
      }

      /* ===========================================================
         Grid (now: individual Meshes with per-tile image textures)
         Also: touch/mouse drag fixed so movement is not inverted
         =========================================================== */
      class Grid extends THREE.Group {
        constructor(canvas, camera, opts, images){
          super();
          this.canvas = canvas;
          this.camera = camera;
          this.opts = opts;

          // state
          this.pointerUv = new THREE.Vector2(0.5, 0.5);
          this.isPointerDown = false;
          this.velocity = new THREE.Vector2();
          this.offset = new THREE.Vector2();
          this.viewW = 1; this.viewH = 1;

          this._lastPX = null;
          this._lastPY = null;

          // content
          this.tiles = [];
          this.tileGeom = new THREE.PlaneGeometry(opts.tile, opts.tile, 1, 1);

          // overlay hairlines as instanced wire (keeps the clean grid)
          this.wireMat = new THREE.MeshBasicMaterial({
            color:'#aeb4c2', wireframe:true, transparent:true, opacity:.35
          });
          this.wireInst = null; // built in layout()

          // Build layout and then load images
          this.layout();

          // Asynchronously load textures and map across tiles
          loadTextures(images).then(texs => {
            texs.forEach(t => applyCoverCrop(t));
            const total = this.tiles.length;
            for (let i=0;i<total;i++){
              const tex = texs[i % texs.length];
              const mat = new THREE.MeshStandardMaterial({
                map: tex, roughness:.45, metalness:0, side:THREE.DoubleSide
              });
              this.tiles[i].material = mat;
            }
          }).catch(err => {
            console.error('Texture load error:', err);
          });

          // events
          this.onPointerMove = this.onPointerMove.bind(this);
          this.onPointerDown = this.onPointerDown.bind(this);
          this.onPointerUp = this.onPointerUp.bind(this);
          canvas.addEventListener('pointermove', this.onPointerMove, { passive:true });
          canvas.addEventListener('pointerdown', this.onPointerDown, { passive:true });
          window.addEventListener('pointerup', this.onPointerUp, { passive:true });
          window.addEventListener('pointercancel', this.onPointerUp, { passive:true });
        }

        dispose(){
          this.canvas.removeEventListener('pointermove', this.onPointerMove);
          this.canvas.removeEventListener('pointerdown', this.onPointerDown);
          window.removeEventListener('pointerup', this.onPointerUp);
          window.removeEventListener('pointercancel', this.onPointerUp);
          this.tileGeom.dispose();
          this.wireMat.dispose();
          this.tiles.forEach(m => m.material && m.material.dispose());
        }

        setViewport(w,h){ this.viewW=w; this.viewH=h; }

        layout(){
          const { cols, rows, tile, gap } = this.opts;
          const stepX = tile + gap;
          const stepY = tile + gap;
          const sizeX = stepX * (cols - 1);
          const sizeY = stepY * (rows - 1);

          // Clear previous
          this.tiles.forEach(m => this.remove(m));
          this.tiles = [];
          if (this.wireInst) this.remove(this.wireInst);

          // Create tiles
          let i = 0;
          for (let r=0;r<rows;r++){
            for (let c=0;c<cols;c++){
              const x = c*stepX - sizeX/2;
              const y = r*stepY - sizeY/2;
              const mesh = new THREE.Mesh(this.tileGeom, new THREE.MeshStandardMaterial({
                color:'#171923', roughness:.55, metalness:0, side:THREE.DoubleSide
              }));
              mesh.position.set(x,y,0);
              this.add(mesh);
              this.tiles.push(mesh);
              i++;
            }
          }

          // Instanced wire overlay
          const total = cols * rows;
          this.wireInst = new THREE.InstancedMesh(this.tileGeom, this.wireMat, total);
          const o = new THREE.Object3D();
          i = 0;
          for (let r=0;r<rows;r++){
            for (let c=0;c<cols;c++){
              const x = c*stepX - sizeX/2;
              const y = r*stepY - sizeY/2;
              o.position.set(x,y,0);
              o.rotation.set(0,0,0);
              o.scale.set(1,1,1);
              o.updateMatrix();
              this.wireInst.setMatrixAt(i++, o.matrix);
            }
          }
          this.wireInst.instanceMatrix.needsUpdate = true;
          this.add(this.wireInst);
        }

        // Convert pixel delta to a normalized world-ish delta (stable across sizes)
        _pxToNorm(dx, dy){
          const s = Math.min(this.viewW, this.viewH);
          return new THREE.Vector2(dx / s, dy / s);
        }

        onPointerMove(e){
          const rect = this.canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / rect.width;
          const y = (e.clientY - rect.top) / rect.height;
          this.pointerUv.set(x,y);

          if (this.isPointerDown){
            // Use absolute delta so it works on touch (movementX/Y can be 0 on some mobiles)
            const dx = (this._lastPX === null ? 0 : (e.clientX - this._lastPX));
            const dy = (this._lastPY === null ? 0 : (e.clientY - this._lastPY));
            this._lastPX = e.clientX; this._lastPY = e.clientY;

            // Non-inverted: content follows the finger/mouse
            const d = this._pxToNorm(dx, dy);
            // X: drag right -> move right (positive)
            // Y: drag down  -> move down  (negative Y in our world coords)
            this.offset.x += d.x * 6.0;
            this.offset.y += -d.y * 6.0;

            // Keep a velocity trail for inertia when releasing
            this.velocity.lerp(new THREE.Vector2(d.x, -d.y), 1 - this.opts.velEase);
          }
        }

        onPointerDown(e){
          this.isPointerDown = true;
          this._lastPX = e.clientX; this._lastPY = e.clientY;
          gsap.to(this.camera.position, { z: CONFIG.zoomIn, duration:1, ease:'power2.out' });
        }

        onPointerUp(){
          this.isPointerDown = false;
          this._lastPX = this._lastPY = null;
          gsap.to(this.camera.position, { z: CONFIG.zoomOut, duration:1, ease:'power2.out' });
        }

        update(){
          // ambient cursor offset (opposite to cursor in UV)
          const cursorOffset = this.pointerUv.clone().subScalar(0.5).multiplyScalar(-this.opts.ambient);

          // inertia
          if (!this.isPointerDown){
            this.offset.add(this.velocity.clone().multiplyScalar(5));
            this.velocity.multiplyScalar(this.opts.velEase);
          }

          const tx = this.offset.x + cursorOffset.x;
          const ty = this.offset.y - cursorOffset.y;
          this.position.x += (tx - this.position.x) * this.opts.dragEase;
          this.position.y += (ty - this.position.y) * this.opts.dragEase;
        }

        resetPosition(){ this.offset.set(0,0); this.velocity.set(0,0); }
      }

      /* ===========================================================
         Postprocessing (unchanged)
         =========================================================== */
      function Postprocessing({ workgridState }){
        const { gl, scene, camera, size } = useThree();
        const { composer, shader } = useMemo(() => {
          const renderPass = new RenderPass(scene, camera);
          const shader = new DistortionShader();
          const shaderPass = new ShaderPass(shader);
          const outputPass = new OutputPass();
          const composer = new EffectComposer(gl);
          composer.addPass(renderPass);
          composer.addPass(shaderPass);
          composer.addPass(outputPass);
          return { composer, shader };
        }, [gl, scene, camera]);

        useEffect(() => {
          composer.setSize(size.width, size.height);
          shader.update();
        }, [composer, shader, size]);

        useEffect(() => {
          if (workgridState === WorkgridState.INTRO) shader.setDistortion(CONFIG.distortion.flat);
          else shader.setDistortion(CONFIG.distortion.curved);
        }, [workgridState, shader]);

        useFrame(() => { composer.render(); }, 1);
        return null;
      }

      /* ===========================================================
         R3F primitive wrapper
         =========================================================== */
      function ProjectsGridPrimitive({ workgridState, images }){
        const { gl, camera, size } = useThree();
        const grid = useMemo(() => {
          return new Grid(gl.domElement, camera, {
            cols: CONFIG.cols,
            rows: CONFIG.rows,
            tile: CONFIG.tile,
            gap: CONFIG.gap,
            ambient: CONFIG.ambient,
            dragEase: CONFIG.dragEase,
            velEase: CONFIG.velEase
          }, images);
        }, [gl, camera, images]);

        useFrame(() => grid.update());
        useEffect(() => { grid.setViewport(size.width, size.height); }, [size, grid]);
        useEffect(() => { if (workgridState === WorkgridState.RESET) grid.resetPosition(); }, [workgridState, grid]);

        return React.createElement('primitive', { object: grid });
      }

      function GridView({ workgridState, images }){
        return (
          React.createElement(Canvas, {
            gl:{ antialias:true, powerPreference:'high-performance' },
            camera:{ fov:35, position:[0,0,CONFIG.zoomOut] },
            dpr:[1, 1.75]
          },
            React.createElement('ambientLight', { intensity:1 }),
            React.createElement('directionalLight', { intensity:.7, position:[2,3,4] }),
            React.createElement(ProjectsGridPrimitive, { workgridState, images }),
            React.createElement(Postprocessing, { workgridState })
          )
        );
      }

      function App(){
        const [state, setState] = useState(WorkgridState.DEFAULT);
        useEffect(() => {
          const onKey = (e) => {
            if (e.key === '1') setState(WorkgridState.INTRO);
            if (e.key === '2') setState(WorkgridState.DEFAULT);
            if (e.key === '0') setState(WorkgridState.RESET);
          };
          window.addEventListener('keydown', onKey);
          return () => window.removeEventListener('keydown', onKey);
        }, []);

        return (
          React.createElement(React.Fragment, null,
            React.createElement('div', { className:'canvas-wrap' },
              React.createElement('div', { className:'fallback-grid' }),
              React.createElement(Suspense, { fallback:null },
                React.createElement(GridView, { workgridState: state, images: IMAGES })
              )
            ),
            React.createElement('div', { className:'hud' },
              React.createElement('button', { onClick: () => setState(WorkgridState.INTRO) }, 'Flat'),
              React.createElement('button', { onClick: () => setState(WorkgridState.DEFAULT) }, 'Curved'),
              React.createElement('button', { onClick: () => setState(WorkgridState.RESET) }, 'Reset')
            )
          )
        );
      }

      // mount
      const root = createRoot(document.getElementById('root'));
      root.render(React.createElement(App));
    </script>
  </body>
</html>
