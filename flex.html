<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
    <title>Phantom-style Grid — Single File (R3F + Three)</title>

    <!-- Fonts (optional) -->
    <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">

    <style>
      :root{
        --paper:#0E0E10;
        --ink:#FFFFFF;
        --ink-2:#9F9F9F;
        --ink-3:#6C6C6C;
        --accent:#59D2C8;
      }

      *{box-sizing:border-box}
      html,body,#root{height:100%}
      body{
        margin:0; background:var(--paper); color:var(--ink);
        font:14px/1.4 Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial;
        overflow:hidden;
      }
      .header{
        position:fixed; inset:0 0 auto 0; z-index:3;
        display:flex; gap:12px; align-items:baseline;
        padding:14px 16px;
        border-bottom:1px solid var(--ink-2);
        background:linear-gradient(180deg,#0a0a0ccc,#0a0a0c66 40%,transparent);
        backdrop-filter:blur(6px);
      }
      .header .dot{
        width:8px; height:8px; border-radius:50%;
        background:var(--accent);
        box-shadow:0 0 0 6px color-mix(in oklab, var(--accent), transparent 80%);
      }
      .header h1{margin:0; font-size:18px}
      .canvas-wrap{position:absolute; inset:0}

      .fallback-grid{
        position:absolute; inset:0; z-index:0; pointer-events:none; opacity:.12;
        color:var(--ink);
        background-image:
          repeating-linear-gradient(to right, currentColor 0 1px, transparent 1px 48px),
          repeating-linear-gradient(to bottom, currentColor 0 1px, transparent 1px 48px);
      }

      .hud{
        position:fixed; z-index:4; inset:auto 12px 12px auto; display:flex; gap:8px;
        font:inherit;
      }
      .hud button{
        appearance:none; cursor:pointer; font:inherit;
        border:1px solid var(--ink-2); background:transparent; color:var(--ink);
        padding:8px 10px; border-radius:10px;
        transition:transform .12s ease;
      }
      .hud button:hover{ transform:translateY(-1px) }
    </style>
  </head>
  <body>
    <header class="header">
      <span class="dot" aria-hidden="true"></span>
      <h1>Phantom-style Grid</h1>
      <small>drag to pan • ambient parallax • flat/curved shader • image tiles w/ labels</small>
    </header>

    <div id="root"></div>

    <script type="module">
      /* ===========================================================
         ESM imports (versions pinned)
         =========================================================== */
      import React, { useEffect, useMemo, useState, Suspense } from 'https://esm.sh/react@18.3.1';
      import { createRoot } from 'https://esm.sh/react-dom@18.3.1/client';
      import * as THREE from 'https://esm.sh/three@0.160.1';
      import { Canvas, useFrame, useThree } from 'https://esm.sh/@react-three/fiber@8.16.0?deps=react@18.3.1,react-dom@18.3.1,three@0.160.1';
      import gsap from 'https://esm.sh/gsap@3.12.5';

      // three/examples post-processing
      import { EffectComposer } from 'https://esm.sh/three@0.160.1/examples/jsm/postprocessing/EffectComposer.js';
      import { RenderPass } from 'https://esm.sh/three@0.160.1/examples/jsm/postprocessing/RenderPass.js';
      import { ShaderPass } from 'https://esm.sh/three@0.160.1/examples/jsm/postprocessing/ShaderPass.js';
      import { OutputPass } from 'https://esm.sh/three@0.160.1/examples/jsm/postprocessing/OutputPass.js';

      /* ===========================================================
         Your images + editable titles/captions
         (edit title/caption as you like)
         =========================================================== */
      const IMAGES = [
        {src:'https://i.ibb.co/xSCsZcyn/wmzWGlaw.webp', title:'wmzWGlaw', caption:'—'},
        {src:'https://i.ibb.co/Hpt4F9Kb/IMG-8403.webp', title:'IMG-8403', caption:'—'},
        {src:'https://i.ibb.co/vC0H3LTF/DSC08656.webp', title:'DSC08656', caption:'—'},
        {src:'https://i.ibb.co/bMJNnQtg/DSC08604.webp', title:'DSC08604', caption:'—'},
        {src:'https://i.ibb.co/qLWQC0cN/DSC08358.webp', title:'DSC08358', caption:'—'},
        {src:'https://i.ibb.co/rRdNxC5g/DSC08300.webp', title:'DSC08300', caption:'—'},
        {src:'https://i.ibb.co/MD923R2f/DSC08254.webp', title:'DSC08254', caption:'—'},
        {src:'https://i.ibb.co/TBtrSYKc/DSC08233.webp', title:'DSC08233', caption:'—'},
        {src:'https://i.ibb.co/23QsQrCG/DSC05954.webp', title:'DSC05954', caption:'—'},
        {src:'https://i.ibb.co/ym1z1pyb/DSC05994.webp', title:'DSC05994', caption:'—'},
        {src:'https://i.ibb.co/bjMXB8HJ/2328964849369731672-5144774570.webp', title:'2328964849…4570', caption:'—'},
        {src:'https://i.ibb.co/fd1SDQQs/2399506735674938043-5144774570.webp', title:'2399506735…4570', caption:'—'},
        {src:'https://i.ibb.co/0pNWKFbk/2319420263505008414-5144774570.webp', title:'2319420263…4570', caption:'—'},
        {src:'https://i.ibb.co/WvW71PR3/2288089293770285108-5144774570.webp', title:'2288089293…4570', caption:'—'},
        {src:'https://i.ibb.co/1YyFqBj3/2278120764300123596-5144774570.webp', title:'2278120764…4570', caption:'—'},
        {src:'https://i.ibb.co/99B3hgp3/2274809041971350857-5144774570.webp', title:'2274809041…4570', caption:'—'},
        {src:'https://i.ibb.co/HpnrrYMR/2269419019461331921-5144774570.webp', title:'2269419019…4570', caption:'—'},
        {src:'https://i.ibb.co/6Rqf37ft/6039d4bbb15be328fc33b54d-IMG-6478.webp', title:'IMG-6478', caption:'—'},
        {src:'https://i.ibb.co/k2svMNFv/603d10120fba838e599b6b5e-IMG-1563.webp', title:'IMG-1563', caption:'—'},
        {src:'https://i.ibb.co/WNtnFQqP/603d1185cafcb2591f42b1ad-IMG-3932.webp', title:'IMG-3932', caption:'—'},
        {src:'https://i.ibb.co/pvFThr4K/603d1185b8ec32082f451ba9-IMG-3882.webp', title:'IMG-3882', caption:'—'},
        {src:'https://i.ibb.co/N2cSNMf4/603d102d9f59a611886a6893-IMG-2151.webp', title:'IMG-2151', caption:'—'},
        {src:'https://i.ibb.co/KjzkkW68/603d102d0f02c70fdf7d84eb-IMG-4696.webp', title:'IMG-4696', caption:'—'},
        {src:'https://i.ibb.co/DPyhP1T7/603d100d889053cc334ee5fc-IMG-2083.webp', title:'IMG-2083', caption:'—'},
        {src:'https://i.ibb.co/Fbr1sSb6/603d8d7a3a6df470a4a661a1-DSC00726.webp', title:'DSC00726', caption:'—'},
        {src:'https://i.ibb.co/5gddKNw3/603d0bb2331da47ee88db089-DSC02085.webp', title:'DSC02085', caption:'—'},
        {src:'https://i.ibb.co/9HZMK0nw/603d0b8b038105ae6904872a-DSC08334.webp', title:'DSC08334', caption:'—'},
        {src:'https://i.ibb.co/yFz4P7cG/603d0b8b04655c6fd42d2253-DSC08281.webp', title:'DSC08281', caption:'—'},
        {src:'https://i.ibb.co/QvHqKh2P/603afe37ba16f8f9174cf501-IMG-1878.webp', title:'IMG-1878', caption:'—'},
        {src:'https://i.ibb.co/tpK7LjSv/603a967ac64cec73069e2454-ZAX09877.webp', title:'ZAX09877', caption:'—'},
        {src:'https://i.ibb.co/0yjJ4j8L/603a967a5dc3e982f571b744-ZAX00968.webp', title:'ZAX00968', caption:'—'},
        {src:'https://i.ibb.co/zWBgb5Sj/603a95ee83ba30ff4ac9bc6a-DSC00423-1.webp', title:'DSC00423-1', caption:'—'},
        {src:'https://i.ibb.co/FLS6ZdgN/603a95ed29478f4bc91875b5-DSC08933.webp', title:'DSC08933', caption:'—'},
        {src:'https://i.ibb.co/5Xr0MDSw/603a93f06a41f45766a3361a-DSC09212.webp', title:'DSC09212', caption:'—'},
        {src:'https://i.ibb.co/wNFR8hJR/603a93f1d03490ae9d2aa64a-IMG-3824.webp', title:'IMG-3824', caption:'—'},
        {src:'https://i.ibb.co/39wDDcbS/603a93f0e815e830d1783e07-IMG-2033.webp', title:'IMG-2033', caption:'—'},
        {src:'https://i.ibb.co/PztRrNhR/603a93eddcd3ab104d64fcbb-ZAX09767.webp', title:'ZAX09767', caption:'—'},
      ];

      /* ===========================================================
         Config & state
         =========================================================== */
      const CONFIG = {
        cols: 10,
        rows: 7,
        tile: 0.32,
        gap: 0.08,
        ambient: 0.20,
        dragEase: 0.14,
        velEase: 0.92,
        zoomIn: 0.75,
        zoomOut: 1.85,
        distortion: { flat: 0.0, curved: 0.6 }
      };

      const WorkgridState = { INTRO:'INTRO', DEFAULT:'DEFAULT', RESET:'RESET' };

      /* ===========================================================
         Distortion shader
         =========================================================== */
      class DistortionShader extends THREE.ShaderMaterial {
        constructor(){
          super({
            name:'DistortionShader',
            uniforms:{
              tDiffuse:{ value:null },
              distortion:{ value:new THREE.Vector2(0,0) },
              vignetteOffset:{ value:0.08 },
              vignetteDarkness:{ value:0.38 }
            },
            vertexShader:/* glsl */`
              varying vec2 vUv;
              void main(){ vUv = uv; gl_Position = vec4(position, 1.0); }
            `,
            fragmentShader:/* glsl */`
              precision highp float;
              uniform sampler2D tDiffuse;
              uniform vec2 distortion;
              uniform float vignetteOffset;
              uniform float vignetteDarkness;
              varying vec2 vUv;

              vec2 getShiftedUv(vec2 uv){ return 2.0 * (uv - 0.5); }
              vec2 getUnshiftedUv(vec2 suv){ return suv * 0.5 + 0.5; }

              void main(){
                vec2 suv = getShiftedUv(vUv);
                float d = length(suv);
                suv *= (0.88 + distortion * dot(suv, suv));
                vec2 uv2 = getUnshiftedUv(suv);
                float vig = smoothstep(0.8, vignetteOffset * 0.799,
                                       (vignetteDarkness + vignetteOffset) * d);
                vec3 col = texture2D(tDiffuse, uv2).rgb * vig;
                gl_FragColor = vec4(col, 1.0);
              }
            `
          });
          this._distortionIntensity = 0;
          this.update();
        }
        update(){
          const w = window.innerWidth, h = window.innerHeight;
          const ratio = Math.min(w, h) / Math.max(w, h);
          this.uniforms.distortion.value.set(
            this._distortionIntensity * ratio,
            this._distortionIntensity * ratio
          );
        }
        setDistortion(value){
          gsap.to(this, {
            _distortionIntensity:value, duration:1, ease:'power2.out',
            onUpdate:() => this.update()
          });
        }
      }

      /* ===========================================================
         Image → canvas composite with title/caption overlays
         (one CanvasTexture per unique image, reused across tiles)
         =========================================================== */
      const TEX_SIZE = 768;         // balance quality/perf
      const P = 20;                 // padding in px
      const TITLE_SIZE = 26;        // px
      const CAPTION_SIZE = 18;      // px
      const STRIP_ALPHA = 0.28;     // bg behind text

      function loadImage(url){
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = url;
        });
      }

      function drawLabelBG(ctx, x, y, w, h, alpha){
        ctx.fillStyle = `rgba(0,0,0,${alpha})`;
        ctx.fillRect(x, y, w, h);
      }

      function ellipsize(ctx, text, maxWidth){
        if (ctx.measureText(text).width <= maxWidth) return text;
        let t = text;
        while (t.length > 1 && ctx.measureText(t + '…').width > maxWidth){
          t = t.slice(0, -1);
        }
        return t + '…';
      }

      function makeTextureFrom(img, title, caption){
        const c = document.createElement('canvas');
        c.width = TEX_SIZE; c.height = TEX_SIZE;
        const ctx = c.getContext('2d');

        // cover-fit the image inside square
        const iw = img.naturalWidth || img.width;
        const ih = img.naturalHeight || img.height;
        const s = TEX_SIZE;
        const ir = iw / ih;
        let dw, dh, dx, dy;
        if (ir > 1){           // wide
          dh = s; dw = ir * s; dx = (s - dw) / 2; dy = 0;
        } else if (ir < 1){    // tall
          dw = s; dh = s / ir; dx = 0; dy = (s - dh) / 2;
        } else {               // square
          dw = s; dh = s; dx = 0; dy = 0;
        }
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, dx, dy, dw, dh);

        // Title strip (top-left)
        ctx.font = `600 ${TITLE_SIZE}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = '#fff';
        ctx.textBaseline = 'top';
        const maxTopW = s - P*2;
        const titleText = ellipsize(ctx, title, maxTopW);
        const titleW = Math.ceil(ctx.measureText(titleText).width);
        const titleH = TITLE_SIZE + 8;
        drawLabelBG(ctx, P-6, P-6, titleW + 12, titleH + 8, STRIP_ALPHA);
        ctx.fillText(titleText, P, P);

        // Caption strip (bottom-left)
        ctx.font = `500 ${CAPTION_SIZE}px Inter, system-ui, sans-serif`;
        ctx.textBaseline = 'alphabetic';
        const maxBotW = s - P*2;
        const capText = ellipsize(ctx, caption, maxBotW);
        const capW = Math.ceil(ctx.measureText(capText).width);
        const capH = CAPTION_SIZE + 8;
        drawLabelBG(ctx, P-6, s - P - capH - 6, capW + 12, capH + 8, STRIP_ALPHA);
        ctx.fillText(capText, P, s - P - 8);

        const tex = new THREE.CanvasTexture(c);
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.anisotropy = 8;
        tex.needsUpdate = true;
        return tex;
      }

      async function buildTextures(items){
        // Load unique images and composite
        const imgs = await Promise.all(items.map(i => loadImage(i.src)));
        return imgs.map((img, i) => makeTextureFrom(img, items[i].title || `Image ${i+1}`, items[i].caption || '—'));
      }

      /* ===========================================================
         Grid with per-tile image textures (labels baked in)
         Non-inverted dragging (content follows finger)
         =========================================================== */
      class Grid extends THREE.Group {
        constructor(canvas, camera, opts, items){
          super();
          this.canvas = canvas;
          this.camera = camera;
          this.opts = opts;

          // state
          this.pointerUv = new THREE.Vector2(0.5, 0.5);
          this.isPointerDown = false;
          this.velocity = new THREE.Vector2();
          this.offset = new THREE.Vector2();
          this.viewW = 1; this.viewH = 1;
          this._lastPX = null; this._lastPY = null;

          // content
          this.tiles = [];
          this.tileGeom = new THREE.PlaneGeometry(opts.tile, opts.tile, 1, 1);

          this.wireMat = new THREE.MeshBasicMaterial({
            color:'#aeb4c2', wireframe:true, transparent:true, opacity:.35
          });
          this.wireInst = null;

          // base layout
          this.layout();

          // compose textures once, then assign (reused if fewer than tiles)
          buildTextures(items).then(texs => {
            const total = this.tiles.length;
            for (let i=0;i<total;i++){
              const tex = texs[i % texs.length];
              const mat = new THREE.MeshStandardMaterial({
                map: tex, roughness:.45, metalness:0, side:THREE.DoubleSide
              });
              this.tiles[i].material = mat;
            }
          }).catch(err => console.error('Texture build error:', err));

          // events
          this.onPointerMove = this.onPointerMove.bind(this);
          this.onPointerDown = this.onPointerDown.bind(this);
          this.onPointerUp = this.onPointerUp.bind(this);
          canvas.addEventListener('pointermove', this.onPointerMove, { passive:true });
          canvas.addEventListener('pointerdown', this.onPointerDown, { passive:true });
          window.addEventListener('pointerup', this.onPointerUp, { passive:true });
          window.addEventListener('pointercancel', this.onPointerUp, { passive:true });
        }

        dispose(){
          this.canvas.removeEventListener('pointermove', this.onPointerMove);
          this.canvas.removeEventListener('pointerdown', this.onPointerDown);
          window.removeEventListener('pointerup', this.onPointerUp);
          window.removeEventListener('pointercancel', this.onPointerUp);
          this.tileGeom.dispose();
          this.wireMat.dispose();
          this.tiles.forEach(m => m.material && m.material.dispose());
        }

        setViewport(w,h){ this.viewW=w; this.viewH=h; }

        layout(){
          const { cols, rows, tile, gap } = this.opts;
          const stepX = tile + gap;
          const stepY = tile + gap;
          const sizeX = stepX * (cols - 1);
          const sizeY = stepY * (rows - 1);

          this.tiles.forEach(m => this.remove(m));
          this.tiles = [];
          if (this.wireInst) this.remove(this.wireInst);

          let i = 0;
          for (let r=0;r<rows;r++){
            for (let c=0;c<cols;c++){
              const x = c*stepX - sizeX/2;
              const y = r*stepY - sizeY/2;
              const mesh = new THREE.Mesh(this.tileGeom, new THREE.MeshStandardMaterial({
                color:'#171923', roughness:.55, metalness:0, side:THREE.DoubleSide
              }));
              mesh.position.set(x,y,0);
              this.add(mesh);
              this.tiles.push(mesh);
              i++;
            }
          }

          // Instanced wires on top
          const total = cols * rows;
          this.wireInst = new THREE.InstancedMesh(this.tileGeom, this.wireMat, total);
          const o = new THREE.Object3D();
          i = 0;
          for (let r=0;r<rows;r++){
            for (let c=0;c<cols;c++){
              const x = c*stepX - sizeX/2;
              const y = r*stepY - sizeY/2;
              o.position.set(x,y,0); o.rotation.set(0,0,0); o.scale.set(1,1,1); o.updateMatrix();
              this.wireInst.setMatrixAt(i++, o.matrix);
            }
          }
          this.wireInst.instanceMatrix.needsUpdate = true;
          this.add(this.wireInst);
        }

        _pxToNorm(dx, dy){
          const s = Math.min(this.viewW, this.viewH);
          return new THREE.Vector2(dx / s, dy / s);
        }

        onPointerMove(e){
          const rect = this.canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / rect.width;
          const y = (e.clientY - rect.top) / rect.height;
          this.pointerUv.set(x,y);

          if (this.isPointerDown){
            const dx = (this._lastPX === null ? 0 : (e.clientX - this._lastPX));
            const dy = (this._lastPY === null ? 0 : (e.clientY - this._lastPY));
            this._lastPX = e.clientX; this._lastPY = e.clientY;

            const d = this._pxToNorm(dx, dy);
            this.offset.x += d.x * 6.0;     // follow finger (non-inverted)
            this.offset.y += -d.y * 6.0;

            this.velocity.lerp(new THREE.Vector2(d.x, -d.y), 1 - this.opts.velEase);
          }
        }

        onPointerDown(e){
          this.isPointerDown = true;
          this._lastPX = e.clientX; this._lastPY = e.clientY;
          gsap.to(this.camera.position, { z: CONFIG.zoomIn, duration:1, ease:'power2.out' });
        }

        onPointerUp(){
          this.isPointerDown = false;
          this._lastPX = this._lastPY = null;
          gsap.to(this.camera.position, { z: CONFIG.zoomOut, duration:1, ease:'power2.out' });
        }

        update(){
          const cursorOffset = this.pointerUv.clone().subScalar(0.5).multiplyScalar(-this.opts.ambient);
          if (!this.isPointerDown){
            this.offset.add(this.velocity.clone().multiplyScalar(5));
            this.velocity.multiplyScalar(this.opts.velEase);
          }
          const tx = this.offset.x + cursorOffset.x;
          const ty = this.offset.y - cursorOffset.y;
          this.position.x += (tx - this.position.x) * this.opts.dragEase;
          this.position.y += (ty - this.position.y) * this.opts.dragEase;
        }

        resetPosition(){ this.offset.set(0,0); this.velocity.set(0,0); }
      }

      /* ===========================================================
         Postprocessing
         =========================================================== */
      function Postprocessing({ workgridState }){
        const { gl, scene, camera, size } = useThree();
        const { composer, shader } = useMemo(() => {
          const renderPass = new RenderPass(scene, camera);
          const shader = new DistortionShader();
          const shaderPass = new ShaderPass(shader);
          const outputPass = new OutputPass();
          const composer = new EffectComposer(gl);
          composer.addPass(renderPass);
          composer.addPass(shaderPass);
          composer.addPass(outputPass);
          return { composer, shader };
        }, [gl, scene, camera]);

        useEffect(() => {
          composer.setSize(size.width, size.height);
          shader.update();
        }, [composer, shader, size]);

        useEffect(() => {
          if (workgridState === WorkgridState.INTRO) shader.setDistortion(CONFIG.distortion.flat);
          else shader.setDistortion(CONFIG.distortion.curved);
        }, [workgridState, shader]);

        useFrame(() => { composer.render(); }, 1);
        return null;
      }

      /* ===========================================================
         R3F primitive wrapper
         =========================================================== */
      function ProjectsGridPrimitive({ workgridState, items }){
        const { gl, camera, size } = useThree();
        const grid = useMemo(() => {
          return new Grid(gl.domElement, camera, {
            cols: CONFIG.cols,
            rows: CONFIG.rows,
            tile: CONFIG.tile,
            gap: CONFIG.gap,
            ambient: CONFIG.ambient,
            dragEase: CONFIG.dragEase,
            velEase: CONFIG.velEase
          }, items);
        }, [gl, camera, items]);

        useFrame(() => grid.update());
        useEffect(() => { grid.setViewport(size.width, size.height); }, [size, grid]);
        useEffect(() => { if (workgridState === WorkgridState.RESET) grid.resetPosition(); }, [workgridState, grid]);

        return React.createElement('primitive', { object: grid });
      }

      function GridView({ workgridState, items }){
        return (
          React.createElement(Canvas, {
            gl:{ antialias:true, powerPreference:'high-performance' },
            camera:{ fov:35, position:[0,0,CONFIG.zoomOut] },
            dpr:[1, 1.75]
          },
            React.createElement('ambientLight', { intensity:1 }),
            React.createElement('directionalLight', { intensity:.7, position:[2,3,4] }),
            React.createElement(ProjectsGridPrimitive, { workgridState, items }),
            React.createElement(Postprocessing, { workgridState })
          )
        );
      }

      function App(){
        const [state, setState] = useState(WorkgridState.DEFAULT);
        useEffect(() => {
          const onKey = (e) => {
            if (e.key === '1') setState(WorkgridState.INTRO);
            if (e.key === '2') setState(WorkgridState.DEFAULT);
            if (e.key === '0') setState(WorkgridState.RESET);
          };
          window.addEventListener('keydown', onKey);
          return () => window.removeEventListener('keydown', onKey);
        }, []);

        return (
          React.createElement(React.Fragment, null,
            React.createElement('div', { className:'canvas-wrap' },
              React.createElement('div', { className:'fallback-grid' }),
              React.createElement(Suspense, { fallback:null },
                React.createElement(GridView, { workgridState: state, items: IMAGES })
              )
            ),
            React.createElement('div', { className:'hud' },
              React.createElement('button', { onClick: () => setState(WorkgridState.INTRO) }, 'Flat'),
              React.createElement('button', { onClick: () => setState(WorkgridState.DEFAULT) }, 'Curved'),
              React.createElement('button', { onClick: () => setState(WorkgridState.RESET) }, 'Reset')
            )
          )
        );
      }

      // mount
      const root = createRoot(document.getElementById('root'));
      root.render(React.createElement(App));
    </script>
  </body>
</html>
