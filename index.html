<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Click for clarity</title>
  <link href="https://fonts.googleapis.com" rel="preconnect" crossorigin>
  <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>
  <style>
* {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      overflow: hidden;
      font-family: 'Arial', sans-serif;
      background: #0f1014; /* Dark Default */
    }
    
    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      outline: none;
    }
    
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }
    
    .instruction {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 11px;
      color: rgba(255, 255, 255, 0.5);
      letter-spacing: 0.2em;
      text-transform: uppercase;
      user-select: none;
      max-width: 90%;
      text-align: center;
      white-space: nowrap;
      pointer-events: none;
      text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    }

    :root {
      --bg-color: #0f1014;
      --card-color: transparent;
      --ink: #ffffff;
      --ink-2: #9f9f9f;
      --ink-3: #6c6c6c;
      --accent: #83ff83;
      --curve-k: 1;
      --vig-opacity: .01;
      --edge-blur: 4.4px;
      --cursor-size: 20px;
      --corner-pad: clamp(16px, 4vw, 24px);
      --corner-top: calc(env(safe-area-inset-top) + clamp(12px, 2vh, 18px));
      --z-grain: 149;
      --z-blur: 4;
      --z-vig: .01;
      --z-ui: 220;
      --z-overlay: 250;
      --z-cursor: 230;
      --glass-bg: rgba(255, 255, 255, 0.04);
      --glass-bg-hover: rgba(255, 255, 255, 0.08);
      --glass-bg-bright: rgba(255, 255, 255, 0.12);
      --glass-border: rgba(255, 255, 255, 0.12);
      --fab-size: 80px;
      --fab-bottom: calc(env(safe-area-inset-bottom) + clamp(16px, 3vh, 32px));
      --base-font-size: 14px;
      --subtle-outline: rgba(255, 255, 255, 0.08);
      --font-stack: Inter, ui-sans-serif, system-ui;
    }

    [data-theme="dark"] {
      --bg-color: #0f1014;
      --ink: #ffffff;
      --ink-2: #9f9f9f;
      --ink-3: #6c6c6c;
      --accent: #83ff83;
      --glass-bg: rgba(20, 21, 26, 0.6);
      --glass-bg-hover: rgba(255, 255, 255, 0.1);
      --glass-bg-bright: rgba(255, 255, 255, 0.15);
      --glass-border: rgba(255, 255, 255, 0.15);
      --vig-opacity: .01;
      --edge-blur: 4.4px;
      color-scheme: dark;
    }

    [data-theme="dark"] .vignette {
      background: radial-gradient(120% 90% at 50% 50%, #fff0 10%, rgb(15 16 20 / 0.8) 60%, rgb(15 16 20 / 1) 100%);
    }

    /* Mobile Optimization */
    @media (max-width: 768px) {
      .edge-blur {
        display: none !important;
      }
      .vignette {
        opacity: 0.3 !important; /* Reduce vignette intensity on mobile */
      }
      
      /* Hide Logo on Mobile */
      .logo {
        display: none;
      }

      /* Clamp Reset Button to Bottom Left on Mobile */
      .corner-reset {
        top: auto;
        right: auto;
        bottom: var(--fab-bottom);
        left: var(--corner-pad);
      }
    }

    @media (pointer: coarse) {

      .top-toggle-nav, .left-toggle-nav, .right-toggle-nav {
        gap: 4px;
        padding: 4px;
      }
      .top-toggle-nav button, .left-toggle-nav button, .right-toggle-nav button {
        padding: 8px 12px;
      }
      .top-toggle-nav button .text {
        display: none;
      }
      .top-toggle-nav button .emoji {
        display: inline;
        font-size: 1.2em;
      }
      .top-toggle-nav button svg {
        display: none;
      }
      .right-toggle-nav button .text, .left-toggle-nav button .text {
        display: none;
      }
      .right-toggle-nav button .emoji, .left-toggle-nav button .emoji {
        display: inline;
        font-size: 1.2em;
      }
      .instruction {
        bottom: 20px;
        font-size: 10px;
        white-space: normal;
        line-height: 1.4;
      }
      .fab {
        --fab-size: 60px;
      }
      .fab svg {
        width: 24px;
        height: 24px;
      }
      .logo img {
        height: 24px;
      }
      .sheet {
        padding: 16px;
        width: 100%; /* Full width sheet on mobile */
      }
      .reset-btn {
        padding: 8px 16px;
      }
      /* Prevent scrolling on Top Nav on mobile */
      .top-toggle-nav {
        max-width: 90vw;
        overflow-x: auto;
        justify-content: flex-start;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
      }
      .top-toggle-nav::-webkit-scrollbar {
        display: none;
      }
    }

    *, *::before, *::after { box-sizing: border-box; }
    html { color-scheme: dark; font-size: var(--base-font-size); }
    body, html { height: 100%; margin: 0; background: var(--bg-color); }
    body {
      color: var(--ink);
      font-family: var(--font-stack);
      line-height: 1.4;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      touch-action: none; /* Prevent scroll on canvas */
      -webkit-user-select: none;
      user-select: none;
      overscroll-behavior: none;
      transition: background-color 0.5s ease, color 0.5s ease;
    }

    body::after {
      content: ""; position: fixed; inset: 0; pointer-events: none; z-index: var(--z-grain); opacity: 0.1;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.45'/%3E%3C/svg%3E");
      background-size: 120px 120px;
    }

    .logo {
      position: fixed;
      top: var(--corner-top);
      left: var(--corner-pad);
      z-index: var(--z-ui);
      pointer-events: none;
    }

    .logo img {
      height: 32px;
      width: auto;
      display: block;
      transition: opacity 0.2s ease;
    }

    .corner-reset {
      position: fixed;
      top: var(--corner-top);
      right: var(--corner-pad);
      z-index: var(--z-ui);
      background: var(--glass-bg);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      padding: 6px;
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      pointer-events: auto;
    }

    .corner-reset button {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: var(--ink);
      cursor: pointer;
      transition: background 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
    }

    .corner-reset button:hover {
      background: var(--glass-bg-hover);
      border-radius: 4px;
    }

    .top-toggle-nav {
      position: fixed;
      top: var(--corner-top);
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: var(--z-ui);
      background: var(--glass-bg);
      padding: 8px;
      border: 1px solid var(--glass-border);
      border-radius: 4px;
      pointer-events: auto;
    }

    .top-toggle-nav button {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: var(--ink);
      cursor: pointer;
      transition: background 0.2s ease;
      display: flex;
      align-items: center;
    }

    .top-toggle-nav button:hover {
      background: var(--glass-bg-hover);
    }

    .top-toggle-nav button svg {
      width: 1em;
      height: 1em;
      margin-left: 0.5em;
    }

    .top-toggle-nav button .emoji {
      display: none;
    }

    @media (max-width: 768px) {
      .top-toggle-nav button .text {
        display: none;
      }
      .top-toggle-nav button .emoji {
        display: inline;
      }
      .top-toggle-nav button svg {
        display: none;
      }
    }

    .fab {
      position: fixed;
      bottom: var(--fab-bottom);
      right: var(--corner-pad);
      z-index: var(--z-ui);
      width: var(--fab-size);
      height: var(--fab-size);
      border-radius: 50%;
      background: var(--glass-bg-bright);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid var(--glass-border);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 0.2s ease, background 0.2s ease;
      pointer-events: auto;
    }

    .fab:active {
        transform: scale(0.95);
    }

    .fab svg {
      width: 32px;
      height: 32px;
    }

    .overlay-sheet {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: var(--z-overlay);
      opacity: 0;
      transition: opacity 0.2s ease;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(4px);
    }

    .overlay-sheet.open {
      opacity: 1;
      pointer-events: auto;
    }

    .sheet {
      position: fixed;
      right: 0;
      top: 0;
      bottom: 0;
      width: 400px;
      background: #0f1014;
      border-left: 1px solid var(--glass-border);
      padding: 24px;
      overflow-y: auto;
      box-shadow: -10px 0 30px rgba(0,0,0,0.5);
    }

    .close-btn {
      position: absolute;
      top: 16px;
      right: 16px;
      background: transparent;
      border: none;
      font-size: 28px;
      cursor: pointer;
      color: var(--ink);
      opacity: 0.7;
      transition: opacity 0.2s;
    }
    
    .close-btn:hover { opacity: 1; }

    .reset-btn {
      padding: 12px 24px;
      background: var(--accent);
      color: #000;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 16px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    #cursor {
      position: fixed;
      pointer-events: none;
      z-index: var(--z-cursor);
    }

    .cursor-circle {
      position: absolute;
      width: var(--cursor-size);
      height: var(--cursor-size);
      border-radius: 50%;
      background: var(--accent);
      opacity: 0.2;
      transform: translate(-50%, -50%);
    }

    .context-menu {
      display: none;
      position: fixed; /* changed to fixed for reliable positioning */
      background: rgba(15, 16, 20, 0.95);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      padding: 8px;
      z-index: 300;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.6);
      user-select: none;
      min-width: 180px;
    }

    .context-menu button {
      display: block;
      width: 100%;
      text-align: left;
      padding: 10px 16px;
      background: transparent;
      border: none;
      color: var(--ink);
      cursor: pointer;
      border-radius: 4px;
      font-size: 13px;
    }

    .context-menu button:hover {
      background: var(--glass-bg-hover);
    }

    .vignette {
      position: fixed; inset: 0; pointer-events: none; z-index: var(--z-vig);
      background: radial-gradient(120% 90% at 50% 50%, #fff0 10%, rgb(15 16 20 / 0.8) 60%, rgb(15 16 20 / 1) 100%);
      opacity: var(--vig-opacity);
    }

    .edge-blur {
      position: fixed; inset: 0; pointer-events: none; z-index: var(--z-blur);
      backdrop-filter: blur(var(--edge-blur)); -webkit-backdrop-filter: blur(var(--edge-blur));
      mask: radial-gradient(100% 64% at 50% 50%, transparent 40%, rgb(255 255 255 / 0.98) 60%);
      -webkit-mask: radial-gradient(100% 64% at 50% 50%, transparent 40%, rgb(255 255 255 / 0.98) 60%);
    }

    .right-toggle-nav, .left-toggle-nav {
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: var(--z-ui);
      background: var(--glass-bg);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      padding: 6px;
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      pointer-events: auto;
      overflow-y: auto;
      max-height: 80vh;
    }

    .left-toggle-nav {
      left: var(--corner-pad);
    }

    .right-toggle-nav {
      right: var(--corner-pad);
    }

    .right-toggle-nav button, .left-toggle-nav button {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: var(--ink);
      cursor: pointer;
      transition: background 0.2s ease;
      display: flex;
      align-items: center;
      border-radius: 4px;
    }

    .right-toggle-nav button:hover, .left-toggle-nav button:hover {
      background: var(--glass-bg-hover);
    }

    .right-toggle-nav button.active, .left-toggle-nav button.active {
      background: var(--glass-bg-bright);
      color: var(--accent);
    }

    /* Mobile Optimization */
    @media (max-width: 768px) {
      .edge-blur {
        display: none !important;
      }
      .vignette {
        opacity: 0.3 !important;
      }

      /* 1. Hide the Logo on mobile */
      .logo {
        display: none !important;
      }

      /* 2. Clamp Reset Button to Bottom/Left */
      .corner-reset {
        /* Force release from Top/Right */
        top: auto !important;
        right: auto !important;
        
        /* Force clamp to Bottom/Left */
        bottom: var(--fab-bottom) !important;
        left: var(--corner-pad) !important;
        
        /* Ensure it stays on top */
        z-index: 250; 
      }

      /* Hide text labels on mobile nav buttons for cleaner look */
      .top-toggle-nav button .text {
        display: none;
      }
      .top-toggle-nav button .emoji {
        display: inline;
      }
      .top-toggle-nav button svg {
        display: none;
      }
    }
  </style>
<script src="https://sites.super.myninja.ai/_assets/ninja-daytona-script.js"></script>
</head>
<body data-theme="dark">
  <div class="logo">
    <img id="logoImg" src="https://raw.githubusercontent.com/ZACKGORT/intoview/main/intoview-logo-light.svg.svg" alt="IntoView Logo">
  </div>

  <div class="corner-reset">
    <button id="resetTopBtn"><span class="text">Reset</span><span class="emoji">üîÑ</span></button>
  </div>

  <svg style="position: absolute; height: 0; width: 0;">
    <filter id="goo">
      <feGaussianBlur in="SourceGraphic" stdDeviation="1" result="blur" />
      <feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0 0 0 0 0 20 -10" result="goo" />
      <feBlend in="SourceGraphic" in2="goo" />
    </filter>
  </svg>
  
  <canvas id="canvas"></canvas>
  <div class="overlay">
    <div class="instruction">One does not simply rebuild. One resets. Then builds. ‚Äî Zack Gort</div>
  </div>

  <div class="edge-blur"></div>
  <div class="vignette"></div>
  <div id="cursor"></div>

  <div class="top-toggle-nav">
    <button id="cvBtn"><span class="text">CV</span><span class="emoji">üìÑ</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></button>
    <button id="noteBtn"><span class="text">Note</span><span class="emoji">üìì</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></button>
    <button id="kanbanBtn"><span class="text">Kanban</span><span class="emoji">üì≤</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></button>
    <button id="melodyBtn"><span class="text">Melody</span><span class="emoji">üé∂</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></button>
    <button id="emdashBtn"><span class="text">Emdash</span><span class="emoji">üìù</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></button>
    <button id="portfolioBtn"><span class="text">Portfolio</span><span class="emoji">üñºÔ∏è</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></button>
  </div>

  <div class="left-toggle-nav">
    <button id="microBtn"><span class="text">Micro</span><span class="emoji">üîç</span></button>    
    <button id="macroBtn" class="active"><span class="text">Macro</span><span class="emoji">üåê</span></button>
  </div>

  <div class="right-toggle-nav">
    <button id="forceBtn" title="Force: forward push with moderate radius influence"><span class="text">Force</span><span class="emoji">üßô</span></button>
    <button id="pushBtn" class="active" title="Push: straight forward trajectory, low radius influence"><span class="text">Push</span><span class="emoji">‚öΩ</span></button>
    <button id="pullBtn" title="Pull: draws objects toward camera"><span class="text">Pull</span><span class="emoji">üöÄ</span></button>
  </div>

  <div class="fab-wrap">
    <button id="fabButton" class="fab" aria-label="Open menu">
      <svg viewBox="0 0 100 100" aria-hidden="true">
        <defs>
          <linearGradient id="cubeTop" x1="0" x2="1" y1="0" y2="1">
            <stop offset="0" stop-color="#fff" stop-opacity="1" />
            <stop offset="1" stop-color="#dcdcdc" stop-opacity="1" />
          </linearGradient>
          <linearGradient id="cubeSide" x1="0" x2="1" y1="0" y2="1">
            <stop offset="0" stop-color="#e8e8e8" />
            <stop offset="1" stop-color="#bdbdbd" />
          </linearGradient>
          <linearGradient id="cubeDark" x1="0" x2="1" y1="0" y2="1">
            <stop offset="0" stop-color="#8a8a8a" />
            <stop offset="1" stop-color="#4b4b4b" />
          </linearGradient>
          <filter id="cubeGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="6" stdDeviation="6" flood-color="#0f1014" flood-opacity=".45" />
          </filter>
        </defs>
        <g filter="url(#cubeGlow)">
          <polygon fill="url(#cubeTop)" points="50,14 80,30 50,46 20,30" />
          <polygon fill="url(#cubeSide)" points="80,30 80,66 50,82 50,46" />
          <polygon fill="url(#cubeDark)" points="50,46 50,82 20,66 20,30" />
        </g>
      </svg>
    </button>
  </div>

  <div id="overlay" class="overlay-sheet" aria-hidden="true">
    <div class="sheet">
      <button id="closeOverlay" class="close-btn">√ó</button>
      <div class="sheet-content">
        <h3 style="margin-bottom: 1rem; color: var(--accent);">Think Pink #FF8DA1</h3>
        <div class="accordion-content">
          <p>Long story short, I was adopted and shipped to the US in a pink onezie (which is a boy's color in Korea). Anyway, it's become part of my personal brand, signifying my embrace of defying expectations from the get-go.</p>
        </div><br>
        <p>As for <strong>intoview.pro</strong>, I am using this space as a place for creative exploration and furtherence of my craft.</p>
      </div><br>

        <h2>Meanwhile...</h2>
        <p style="opacity: 0.7; font-size: 0.9em; margin-top: 0.5rem;">Go kick [blocks]</p>
        <button id="resetBtn" class="reset-btn">#yolo</button>
      </div>
    </div>
  </div>

  <div id="contextMenu" class="context-menu">
    <button id="contextReset">Reset</button>
    <button id="contextCopyResume">Copy Resume Link</button>
    <button id="contextCopyPortfolio">Copy Portfolio Link</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
  
  <script>
    // Custom ThinFilmFresnelMap texture for iridescent effects on materials
    class ThinFilmFresnelMap extends THREE.Texture {
      constructor(thickness = 500) {
        super();
        this.thickness = thickness;
        this.generate();
      }

      generate() {
        const width = 512;
        const height = 1;
        const data = new Uint8Array(width * 4);
        for (let i = 0; i < width; i++) {
          const cosTheta = i / width;
          const u = Math.pow(1 - cosTheta, 5);
          data[i * 4] = Math.floor(255 * (0.04 + (1 - 0.04) * u) + Math.sin(this.thickness / 100 * i / width * 2 * Math.PI) * 0.5 + 0.5 * 255);
          data[i * 4 + 1] = Math.floor(255 * u + Math.sin(this.thickness / 100 * i / width * 2 * Math.PI + 2 * Math.PI / 3) * 0.5 + 0.5 * 255);
          data[i * 4 + 2] = Math.floor(255 * u + Math.sin(this.thickness / 100 * Math.PI * 2 * i / width + 4 * Math.PI / 3) * 0.5 + 0.5 * 255);
          data[i * 4 + 3] = 255;
        }
        this.image = { data, width, height };
        this.magFilter = THREE.LinearFilter;
        this.minFilter = THREE.LinearFilter;
        this.wrapS = THREE.ClampToEdgeWrapping;
        this.wrapT = THREE.ClampToEdgeWrapping;
        this.needsUpdate = true;
      }
    }

    // Detect if the device is mobile for performance optimizations
    const isMobileDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

    // Get the canvas element for rendering
    const canvas = document.getElementById('canvas');
    const scene = new THREE.Scene();
    
    // Set initial scene background color to match dark theme
    scene.background = new THREE.Color(0x0f1014);
    
    // Configure the perspective camera
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 11);
    
    // Set up WebGL renderer with mobile optimizations (disable antialias on mobile)
    const renderer = new THREE.WebGLRenderer({ 
      canvas, 
      antialias: !isMobileDevice,
      powerPreference: "high-performance"
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    // Initialize Cannon.js physics world with realistic gravity
    const world = new CANNON.World();
    world.gravity.set(0, -9.81, 0); // Adjusted to Earth-like gravity for more realistic physics
    world.broadphase = new CANNON.NaiveBroadphase();
    // Define default material for physics contacts
    const defaultMaterial = new CANNON.Material();
    const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
      friction: 0.3,
      restitution: 0.5
    });
    world.addContactMaterial(defaultContactMaterial);
    
    // Add ambient and point lights to the scene
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const accentLight = new THREE.PointLight(0xff8Da1, 3, 20); 
    accentLight.position.set(-8, 5, 10);
    scene.add(accentLight);
    
    const whiteLight = new THREE.PointLight(0xffffff, 2, 100);
    whiteLight.position.set(8, 5, 10);
    scene.add(whiteLight);
    
    // Add directional light with shadow casting, optimized for mobile
    const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
    mainLight.position.set(5, 15, 10);
    mainLight.castShadow = true;
    
    // Optimize shadow map size based on device
    const shadowSize = isMobileDevice ? 512 : 2048;
    mainLight.shadow.mapSize.width = shadowSize;
    mainLight.shadow.mapSize.height = shadowSize;
    
    // Expand shadow camera frustum to avoid clipping
    const d = 30;
    mainLight.shadow.camera.left = -d;
    mainLight.shadow.camera.right = d;
    mainLight.shadow.camera.top = d;
    mainLight.shadow.camera.bottom = -d;
    
    scene.add(mainLight);
    
    // Dynamically retrieve accent color from CSS and apply to materials/lights
    const accentHex = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
    const accentColor = new THREE.Color(accentHex);
    
    // Create accent material using the dynamic color
    const accentMaterial = new THREE.MeshStandardMaterial({
      color: accentColor, 
      metalness: 0.222,
      roughness: 0.333
    });
    accentLight.color = accentColor;
    
    // Define pink material for clicked cubes (all faces pink for consistent rendering)
    const pinkMaterial = new THREE.MeshStandardMaterial({
      color: 0xFF8DA1, // Think Pink color
      metalness: 0.3,
      roughness: 0.4,
      emissive: 0xFF8DA1,
      emissiveIntensity: 0.1
    }); 
    
    // Load logo texture from SVG
    const svgString = `
      <svg width="332" height="83" viewBox="0 0 332 83" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g filter="url(#filter0_f_574_561)">
          <path d="M58.9219 68.0029L46.8359 74.8896V60.9814L58.9219 54.1621V68.0029Z" fill="#FF8DA1" stroke="black" stroke-width="0.5"/>
          <path d="M58.667 53.7354L46.584 60.6875L34.502 53.8027L46.5166 46.8506L58.667 53.7354Z" fill="#FF8DA1" stroke="black" stroke-width="0.5"/>
          <path d="M46.3359 61.1211V74.8887L34.3193 68.0029L34.252 54.2354L46.3359 61.1211Z" fill="#FF8DA1" stroke="black" stroke-width="0.5"/>
        </g>
        <g filter="url(#filter1_f_574_561)">
          <path d="M84.0703 60.9834L65.6914 71.4561V50.3057L84.0703 39.9355V60.9834Z" fill="#FF8DA1" stroke="black" stroke-width="0.5"/>
          <path d="M83.8154 39.5088L65.4395 50.082L47.0645 39.6113L65.3369 29.0381L83.8154 39.5088Z" fill="#FF8DA1" stroke="black" stroke-width="0.5"/>
          <path d="M65.1914 50.5156V71.4551L46.917 60.9834L46.8145 40.0439L65.1914 50.5156Z" fill="#FF8DA1" stroke="black" stroke-width="0.5"/>
        </g>
        <path d="M115.203 49.8809L91.0312 63.6553V35.8389L115.203 22.2002V49.8809Z" fill="#FF8DA1" stroke="black"/>
        <path d="M114.695 21.3467L90.5293 35.252L66.3623 21.4805L90.3926 7.5752L114.695 21.3467Z" fill="#FF8DA1" stroke="black"/>
        <path d="M90.0312 36.1182V63.6523L65.998 49.8809L65.8633 22.3467L90.0312 36.1182Z" fill="#FF8DA1" stroke="black"/>
        <path opacity="0.33" d="M90.4375 35.7813L90.4375 7" stroke="white" stroke-width="0.375"/>
        <path opacity="0.33" d="M90.438 35.7812L115.363 50.1719" stroke="white" stroke-width="0.375"/>
        <path opacity="0.33" d="M90.4409 35.7813L65.5156 50.1719" stroke="white" stroke-width="0.375"/>
        <path d="M152.568 47.792V34.2377H155.071V47.792H152.568ZM148.753 48.0625V45.844H158.885V48.0625H148.753ZM148.753 36.4562V34.2377H154.056V36.4562H148.753ZM153.813 31.8569C153.38 31.8569 153.015 31.7081 152.717 31.4105C152.419 31.1039 152.271 30.7341 152.271 30.3013C152.271 29.8594 152.419 29.4896 152.717 29.192C153.015 28.8854 153.38 28.7321 153.813 28.7321C154.264 28.7321 154.633 28.8854 154.922 29.192C155.219 29.4896 155.368 29.8594 155.368 30.3013C155.368 30.7341 155.219 31.1039 154.922 31.4105C154.633 31.7081 154.264 31.8569 153.813 31.8569ZM167.21 48.0625V34.2377H169.713V37.0513L169.348 36.4291C169.492 35.9602 169.758 35.5363 170.146 35.1575C170.542 34.7788 171.029 34.4767 171.607 34.2512C172.193 34.0258 172.838 33.913 173.541 33.913C174.587 33.913 175.493 34.1159 176.26 34.5218C177.027 34.9186 177.617 35.5679 178.032 36.4697C178.447 37.3625 178.654 38.5439 178.654 40.0138V48.0625H176.152V39.9462C176.152 38.5754 175.85 37.615 175.245 37.0649C174.641 36.5148 173.902 36.2397 173.027 36.2397C172.405 36.2397 171.841 36.3524 171.336 36.5779C170.84 36.7943 170.443 37.1686 170.146 37.7007C169.857 38.2327 169.713 38.9632 169.713 39.8921V48.0625H167.21ZM193.553 48.3872C192.246 48.3872 191.308 48.0715 190.74 47.4402C190.172 46.8 189.888 45.9387 189.888 44.8566V36.4562H186.803V34.2377H189.888V29.7467L192.39 28.5292V34.2377H197.057V36.4562H192.39V44.1531C192.39 44.5409 192.444 44.8836 192.552 45.1812C192.661 45.4788 192.859 45.7088 193.148 45.8711C193.436 46.0334 193.847 46.1146 194.379 46.1146C194.974 46.1146 195.461 46.0379 195.84 45.8846C196.227 45.7313 196.575 45.5645 196.881 45.3841L196.584 47.7649C196.214 47.9543 195.794 48.1031 195.326 48.2113C194.866 48.3285 194.275 48.3872 193.553 48.3872ZM211.672 48.3872C210.355 48.3872 209.21 48.0986 208.236 47.5214C207.262 46.9443 206.505 46.1191 205.964 45.0459C205.432 43.9638 205.166 42.6697 205.166 41.1636C205.166 39.6666 205.432 38.377 205.964 37.2948C206.505 36.2127 207.262 35.3785 208.236 34.7923C209.21 34.2061 210.355 33.913 211.672 33.913C212.998 33.913 214.148 34.2016 215.122 34.7788C216.095 35.3559 216.849 36.1856 217.381 37.2678C217.913 38.35 218.179 39.6441 218.179 41.1501C218.179 42.6471 217.913 43.9367 217.381 45.0189C216.849 46.1011 216.095 46.9352 215.122 47.5214C214.148 48.0986 212.998 48.3872 211.672 48.3872ZM211.672 46.0469C212.944 46.0469 213.918 45.6096 214.594 44.7348C215.279 43.851 215.622 42.6561 215.622 41.1501C215.622 39.6441 215.288 38.4492 214.621 37.5654C213.963 36.6816 212.98 36.2397 211.672 36.2397C210.392 36.2397 209.413 36.6726 208.737 37.5383C208.06 38.4041 207.722 39.6125 207.722 41.1636C207.722 42.6606 208.06 43.851 208.737 44.7348C209.413 45.6096 210.392 46.0469 211.672 46.0469ZM229.967 48.0625L224.65 34.2377H227.288L230.656 43.3686C230.738 43.576 230.814 43.7969 230.886 44.0314C230.959 44.2568 231.031 44.5139 231.103 44.8024C231.175 44.5139 231.247 44.2568 231.319 44.0314C231.4 43.7969 231.477 43.576 231.549 43.3686L234.863 34.2377H237.461L232.144 48.0625H229.967ZM249.451 47.792V34.2377H251.954V47.792H249.451ZM245.637 48.0625V45.844H255.769V48.0625H245.637ZM245.637 36.4562V34.2377H250.939V36.4562H245.637ZM250.696 31.8569C250.263 31.8569 249.898 31.7081 249.6 31.4105C249.303 31.1039 249.154 30.7341 249.154 30.3013C249.154 29.8594 249.303 29.4896 249.6 29.192C249.898 28.8854 250.263 28.7321 250.696 28.7321C251.147 28.7321 251.517 28.8854 251.805 29.192C252.103 29.4896 252.252 29.8594 252.252 30.3013C252.252 30.7341 252.103 31.1039 251.805 31.4105C251.517 31.7081 251.147 31.8569 250.696 31.8569ZM270.086 48.3872C268.752 48.3872 267.606 48.0715 266.65 47.4402C265.694 46.8 264.959 45.9342 264.445 44.843C263.94 43.7518 263.688 42.5163 263.688 41.1366C263.688 39.6215 263.949 38.3274 264.472 37.2543C265.004 36.1721 265.748 35.3469 266.704 34.7788C267.669 34.2016 268.797 33.913 270.086 33.913C271.15 33.913 272.124 34.1475 273.008 34.6165C273.892 35.0854 274.595 35.8068 275.118 36.7808C275.65 37.7548 275.916 39.0038 275.916 40.5278C275.916 40.7172 275.912 40.9517 275.903 41.2313C275.903 41.5108 275.88 41.8129 275.835 42.1376H265.636V39.9597H273.427C273.4 38.9857 273.211 38.2192 272.859 37.6601C272.517 37.1009 272.093 36.7087 271.588 36.4832C271.083 36.2487 270.582 36.1315 270.086 36.1315C268.733 36.1315 267.741 36.5599 267.11 37.4166C266.479 38.2733 266.163 39.4276 266.163 40.8796C266.163 42.4848 266.515 43.7608 267.218 44.7078C267.922 45.6547 268.896 46.1281 270.14 46.1281C270.717 46.1281 271.268 46.0334 271.791 45.844C272.323 45.6456 272.832 45.3345 273.319 44.9107L274.663 46.5339C274.198 47.066 273.513 47.5079 272.71 47.8596C271.917 48.2113 271.042 48.3872 270.086 48.3872ZM284.931 48.0625L281.455 34.2377H283.836L285.838 42.7463C285.883 42.9177 285.923 43.107 285.959 43.3144C286.004 43.5128 286.04 43.7203 286.068 43.9367C286.113 43.6842 286.149 43.4678 286.176 43.2874C286.212 43.098 286.252 42.8996 286.297 42.6922L288.191 34.2377H290.166L292.074 42.7193C292.128 42.9086 292.173 43.1115 292.209 43.328C292.254 43.5354 292.295 43.7654 292.331 44.0179C292.367 43.7744 292.403 43.5534 292.439 43.355C292.484 43.1476 292.529 42.9357 292.574 42.7193L294.509 34.2377H296.903L293.413 48.0625H291.343L289.476 39.8921C289.431 39.6937 289.382 39.4502 289.328 39.1616C289.273 38.873 289.219 38.598 289.165 38.3364C289.12 38.607 289.066 38.882 289.003 39.1616C288.949 39.4412 288.899 39.6756 288.854 39.865L287.041 48.0625H284.931Z"/>
        <g filter="url(#filter2_f_574_561)">
          <path d="M152.465 47.792V34.2377H154.967V47.792H152.465ZM148.65 48.0625V45.844H158.782V48.0625H148.65ZM148.65 36.4562V34.2377H153.953V36.4562H148.65ZM153.709 31.8569C153.276 31.8569 152.911 31.7081 152.613 31.4105C152.316 31.1039 152.167 30.7341 152.167 30.3013C152.167 29.8594 152.316 29.4896 152.613 29.192C152.911 28.8854 153.276 28.7321 153.709 28.7321C154.16 28.7321 154.53 28.8854 154.818 29.192C155.116 29.4896 155.265 29.8594 155.265 30.3013C155.265 30.7341 155.116 31.1039 154.818 31.4105C154.53 31.7081 154.16 31.8569 153.709 31.8569ZM167.107 48.0625V34.2377H169.609V37.0513L169.244 36.4291C169.388 35.9602 169.654 35.5363 170.042 35.1575C170.439 34.7788 170.926 34.4767 171.503 34.2512C172.089 34.0258 172.734 33.913 173.437 33.913C174.484 33.913 175.39 34.1159 176.156 34.5218C176.923 34.9186 177.514 35.5679 177.929 36.4697C178.343 37.3625 178.551 38.5439 178.551 40.0138V48.0625H176.048V39.9462C176.048 38.5754 175.746 37.615 175.142 37.0649C174.538 36.5148 173.798 36.2397 172.923 36.2397C172.301 36.2397 171.738 36.3524 171.233 36.5779C170.737 36.7943 170.34 37.1686 170.042 37.7007C169.754 38.2327 169.609 38.9632 169.609 39.8921V48.0625H167.107ZM193.45 48.3872C192.142 48.3872 191.204 48.0715 190.636 47.4402C190.068 46.8 189.784 45.9387 189.784 44.8566V36.4562H186.7V34.2377H189.784V29.7467L192.287 28.5292V34.2377H196.953V36.4562H192.287V44.1531C192.287 44.5409 192.341 44.8836 192.449 45.1812C192.557 45.4788 192.756 45.7088 193.044 45.8711C193.333 46.0334 193.743 46.1146 194.275 46.1146C194.87 46.1146 195.357 46.0379 195.736 45.8846C196.124 45.7313 196.471 45.5645 196.778 45.3841L196.48 47.7649C196.11 47.9543 195.691 48.1031 195.222 48.2113C194.762 48.3285 194.171 48.3872 193.45 48.3872ZM211.569 48.3872C210.252 48.3872 209.107 48.0986 208.133 47.5214C207.159 46.9443 206.401 46.1191 205.86 45.0459C205.328 43.9638 205.062 42.6697 205.062 41.1636C205.062 39.6666 205.328 38.377 205.86 37.2948C206.401 36.2127 207.159 35.3785 208.133 34.7923C209.107 34.2061 210.252 33.913 211.569 33.913C212.894 33.913 214.044 34.2016 215.018 34.7788C215.992 35.3559 216.745 36.1856 217.277 37.2678C217.809 38.35 218.075 39.6441 218.075 41.1501C218.075 42.6471 217.809 43.9367 217.277 45.0189C216.745 46.1011 215.992 46.9352 215.018 47.5214C214.044 48.0986 212.894 48.3872 211.569 48.3872ZM211.569 46.0469C212.84 46.0469 213.814 45.6096 214.49 44.7348C215.176 43.851 215.519 42.6561 215.519 41.1501C215.519 39.6441 215.185 38.4492 214.518 37.5654C213.859 36.6816 212.876 36.2397 211.569 36.2397C210.288 36.2397 209.31 36.6726 208.633 37.5383C207.957 38.4041 207.619 39.6125 207.619 41.1636C207.619 42.6606 207.957 43.851 208.633 44.7348C209.31 45.6096 210.288 46.0469 211.569 46.0469ZM229.863 48.0625L224.547 34.2377H227.185L230.553 43.3686C230.634 43.576 230.711 43.7969 230.783 44.0314C230.855 44.2568 230.927 44.5139 230.999 44.8024C231.072 44.5139 231.144 44.2568 231.216 44.0314C231.297 43.7969 231.374 43.576 231.446 43.3686L234.76 34.2377H237.357L232.041 48.0625H229.863ZM249.348 47.792V34.2377H251.851V47.792H249.348ZM245.533 48.0625V45.844H255.665V48.0625H245.533ZM245.533 36.4562V34.2377H250.836V36.4562H245.533ZM250.592 31.8569C250.16 31.8569 249.794 31.7081 249.497 31.4105C249.199 31.1039 249.05 30.7341 249.05 30.3013C249.05 29.8594 249.199 29.4896 249.497 29.192C249.794 28.8854 250.16 28.7321 250.592 28.7321C251.043 28.7321 251.413 28.8854 251.702 29.192C251.999 29.4896 252.148 29.8594 252.148 30.3013C252.148 30.7341 251.999 31.1039 251.702 31.4105C251.413 31.7081 251.043 31.8569 250.592 31.8569ZM269.983 48.3872C268.648 48.3872 267.503 48.0715 266.547 47.4402C265.591 46.8 264.856 45.9342 264.342 44.843C263.837 43.7518 263.584 42.5163 263.584 41.1366C263.584 39.6215 263.846 38.3274 264.369 37.2543C264.901 36.1721 265.645 35.3469 266.601 34.7788C267.566 34.2016 268.693 33.913 269.983 33.913C271.047 33.913 272.021 34.1475 272.905 34.6165C273.788 35.0854 274.492 35.8068 275.015 36.7808C275.547 37.7548 275.813 39.0038 275.813 40.5278C275.813 40.7172 275.808 40.9517 275.799 41.2313C275.799 41.5108 275.777 41.8129 275.732 42.1376H265.532V39.9597H273.324C273.297 38.9857 273.107 38.2192 272.756 37.6601C272.413 37.1009 271.989 36.7087 271.484 36.4832C270.979 36.2487 270.479 36.1315 269.983 36.1315C268.63 36.1315 267.638 36.5599 267.007 37.4166C266.375 38.2733 266.06 39.4276 266.06 40.8796C266.06 42.4848 266.411 43.7608 267.115 44.7078C267.818 45.6547 268.792 46.1281 270.037 46.1281C270.614 46.1281 271.164 46.0334 271.687 45.844C272.219 45.6456 272.729 45.3345 273.216 44.9107L274.663 46.5339C274.095 47.066 273.41 47.5079 272.607 47.8596C271.813 48.2113 270.939 48.3872 269.983 48.3872ZM284.828 48.0625L281.351 34.2377H283.732L285.734 42.7463C285.779 42.9177 285.82 43.107 285.856 43.3144C285.901 43.5128 285.937 43.7203 285.964 43.9367C286.009 43.6842 286.045 43.4678 286.072 43.2874C286.108 43.098 286.149 42.8996 286.194 42.6922L288.088 34.2377H290.063L291.97 42.7193C292.024 42.9086 292.069 43.1115 292.105 43.328C292.15 43.5354 292.191 43.7654 292.227 44.0179C292.263 43.7744 292.299 43.5534 292.335 43.355C292.38 43.1476 292.426 42.9357 292.471 42.7193L294.405 34.2377H296.799L293.309 48.0625H291.24L289.373 39.8921C289.328 39.6937 289.278 39.4502 289.224 39.1616C289.17 38.873 289.116 38.598 289.062 38.3364C289.017 38.607 288.963 38.882 288.899 39.1616C288.845 39.4412 288.796 39.6756 288.751 39.865L286.938 48.0625H284.828Z"/>
        </g>
        <defs>
          <filter id="filter0_f_574_561" x="31" y="43.5625" width="31.1719" height="34.7578" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
            <feFlood flood-opacity="0" result="BackgroundImageFix"/>
            <feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
            <feGaussianBlur stdDeviation="1.5" result="effect1_foregroundBlur_574_561"/>
          </filter>
          <filter id="filter1_f_574_561" x="44.6875" y="26.875" width="41.5078" height="46.8867" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
            <feFlood flood-opacity="0" result="BackgroundImageFix"/>
            <feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
            <feGaussianBlur stdDeviation="0.9375" result="effect1_foregroundBlur_574_561"/>
          </filter>
          <filter id="filter2_f_574_561" x="144.65" y="24.5293" width="156.149" height="27.8574" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
            <feFlood flood-opacity="0" result="BackgroundImageFix"/>
            <feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
            <feGaussianBlur stdDeviation="1.90226" result="effect1_foregroundBlur_574_561"/>
          </filter>
          <linearGradient id="paint0_linear_574_561" x1="144.863" y1="41.0625" x2="297.863" y2="41.0625" gradientUnits="userSpaceOnUse">
            <stop stop-color="#FF8DA1"/>
            <stop offset="1"/>
          </linearGradient>
          <linearGradient id="paint1_linear_574_561" x1="144.76" y1="41.0625" x2="297.76" y2="41.0625" gradientUnits="userSpaceOnUse">
            <stop/>
            <stop offset="1" stop-color="#FF8DA1"/>
          </linearGradient>
        </defs>
      </svg>
    `;

    const originalSvg = document.getElementById('logoImg').src;
    const textureLoader = new THREE.TextureLoader();
    const logoTexture = textureLoader.load(originalSvg);
    
    // Create plane for logo display in the scene
    const logoPlaneGeo = new THREE.PlaneGeometry(80, 20);
    const logoPlaneMat = new THREE.MeshBasicMaterial({ 
      map: logoTexture,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.9
    });
    const logoPlane = new THREE.Mesh(logoPlaneGeo, logoPlaneMat);
    logoPlane.position.set(0, 16, -166);
    scene.add(logoPlane);
    
    // Set up cube map for environment reflections
    const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512, {
      format: THREE.RGBFormat,
      generateMipmaps: true,
      minFilter: THREE.LinearMipmapLinearFilter
    });
    const cubeCamera = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget);
    scene.add(cubeCamera);
    
    // Create ground plane for shadows and physics
    const groundGeo = new THREE.PlaneGeometry(800, 800);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x0f1014, roughness: 1, metalness: 0 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -6;
    ground.receiveShadow = true;
    scene.add(ground);
    
    // Add physics body for ground
    const groundShape = new CANNON.Plane();
    const groundBody = new CANNON.Body({ mass: 0, material: defaultMaterial });
    groundBody.addShape(groundShape);
    groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
    groundBody.position.set(0, -6, 0);
    world.addBody(groundBody);
    
    let cubes = []; // Array to hold cube objects (mesh and physics body)
    let cubeSize = 3.33; // Initial cube size
    const fresnelMap = new ThinFilmFresnelMap(); // Iridescent map for materials
    // Mirror material with custom shader for reflections and iridescence
    const mirrorMaterial = new THREE.MeshStandardMaterial({
      envMap: cubeRenderTarget.texture,
      metalness: 1,
      roughness: 0.05,
      color: 0x0f1014
    });
    
    mirrorMaterial.onBeforeCompile = (shader) => {
      shader.uniforms.fresnelMap = { value: fresnelMap };
      shader.fragmentShader = 'uniform sampler2D fresnelMap;\\n' + shader.fragmentShader;
      shader.fragmentShader = shader.fragmentShader.replace(
        '#include <normal_fragment_maps>',
        '#include <normal_fragment_maps>\\nvec3 viewDir = normalize( -vViewPosition );\\nfloat dnv = saturate( dot( normal, viewDir ) );\\nvec3 irid = texture2D( fresnelMap, vec2( dnv, 0.0 ) ).rgb;\\nirid *= irid;\\n'
      );
      shader.fragmentShader = shader.fragmentShader.replace(
        '#include <lights_fragment_end>',
        '#include <lights_fragment_end>\\nreflectedLight.indirectSpecular *= irid;\\nreflectedLight.directSpecular *= irid;\\n'
      );
    };
    
    const gridGroup = new THREE.Group(); // Group to hold all cubes in the grid
    scene.add(gridGroup);
    
    // Function to create a grid of cubes with physics bodies
    function createCubes(rows, cols) {
      const spacing = cubeSize;
      const bottomY = -6 + cubeSize / 2;
      const leftX = - (cols - 1) * spacing / 2;
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const cubeGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
          // Assign materials to each face for proper rendering (accent on most faces, mirror on back)
          const materials = [
            accentMaterial, // right (+x)
            accentMaterial, // left (-x)
            accentMaterial, // top (+y)
            accentMaterial, // bottom (-y)
            accentMaterial, // front (+z)
            mirrorMaterial  // back (-z)
          ];
          const cube = new THREE.Mesh(cubeGeo, materials);
          const x = leftX + j * spacing;
          const y = bottomY + i * spacing;
          const z = 0;
          cube.position.set(x, y, z);
          cube.castShadow = true;
          cube.receiveShadow = true;
          gridGroup.add(cube);
          // Create physics shape and body for the cube
          const shape = new CANNON.Box(new CANNON.Vec3(cubeSize / 2, cubeSize / 2, cubeSize / 2));
          const body = new CANNON.Body({ mass: 2, material: defaultMaterial });
          body.addShape(shape);
          body.position.set(x, y, z);
          body.linearDamping = 0.3;
          body.angularDamping = 0.3;
          world.addBody(body);
          cubes.push({ 
            mesh: cube, 
            body: body, 
            initial: { x, y, z },
            originalMaterials: [...materials], // Store original materials for reset
            isPink: false // Track if cube is in pink state
          });
        }
      }
    }
    
    // Function to remove all cubes from scene and physics world
    function removeCubes() {
      cubes.forEach(({ mesh, body }) => {
        gridGroup.remove(mesh);
        world.remove(body);
      });
      cubes = [];
    }
    
    // Function to simulate a bounce and settle physics for initial cube placement
    function bounceAndSettle() {
      cubes.forEach(({ body }) => {
        body.position.y += 0.5;
        body.wakeUp();
      });
      const fixedTimeStep = 1 / 60;
      // Reduce physics iterations on mobile for better performance
      const iterations = isMobileDevice ? 20 : 60; 
      for (let i = 0; i < iterations; i++) {
        world.step(fixedTimeStep);
      }
      cubes.forEach(({ mesh, body }) => {
        mesh.position.copy(body.position);
        mesh.quaternion.copy(body.quaternion);
      });
    }
    
    let currentGrid = 'macro'; // Start with macro view on page load as specified
    
    // View transition state management to prevent concurrent changes
    let isViewTransitioning = false;
    let viewToggleTimeout = null;
    
    // Calculate camera targets based on current grid mode and device
    function getCameraTargets() {
      const aspect = window.innerWidth / window.innerHeight;
      let rows, cols, sizeMultiplier;
      
      if (currentGrid === 'micro') {
        sizeMultiplier = isMobileDevice ? 2.22 : 1; 
        rows = isMobileDevice ? 5 : 4; // More rows on mobile for better fill
        cols = Math.round( (isMobileDevice ? 5 : 4) * aspect * 1.5 );
      } else {
        sizeMultiplier = isMobileDevice ? 1.11 : 1;
        rows = isMobileDevice ? 10 : 8; // More rows on mobile
        cols = Math.round( (isMobileDevice ? 8 : 16) * aspect * 1.2 );
      }
      
      // Clamp rows and cols to reasonable minimums
      cols = Math.max(3, cols); 
      rows = Math.max(3, rows); 
      
      cubeSize = (currentGrid === 'micro' ? 3.33 : 2.5) * sizeMultiplier;
      const gridWidth = cols * cubeSize;
      const gridHeight = rows * cubeSize;
      
      // Adjust camera Y position for better centering, especially on mobile
      let targetCamY = -4; 
      if (isMobileDevice) {
         targetCamY = -6 + (gridHeight / 2.5); 
      }

      let targetCamZ;
      if (isMobileDevice) {
        // Closer zoom on mobile for better visibility
        if (currentGrid === 'micro') {
            targetCamZ = 19;
        } else {
            targetCamZ = 28;
        }
      } else {
        // Dynamic zoom on desktop based on grid width
        targetCamZ = currentGrid === 'micro' ? gridWidth * 0.8 + 10 : gridWidth * 1.2 + 10;
        targetCamZ *= 0.44;
      }
      
      const targetRotX = 0.2;
      return { y: targetCamY, z: targetCamZ, rotX: targetRotX, rows, cols };
    }
    
    // Update grid layout with optional camera animation and force flag
    function updateGrid(animateCamera = false, forceUpdate = false) {
      if (isViewTransitioning && !forceUpdate) {
        return;
      }
      
      isViewTransitioning = true;
      
      if (viewToggleTimeout) {
        clearTimeout(viewToggleTimeout);
      }
      
      removeCubes();
      const { rows, cols } = getCameraTargets();
      createCubes(rows, cols);
      bounceAndSettle();
      if (animateCamera) {
        const targets = getCameraTargets();
        const duration = currentGrid === 'micro' ? 0.8 : 2;
        const posEase = currentGrid === 'micro' ? 'back.out' : 'power1.inOut';
        const rotEase = 'power1.inOut';
        gsap.to(camera.position, { y: targets.y, z: targets.z, duration, ease: posEase });
        gsap.to(camera.rotation, { x: targets.rotX, duration, ease: rotEase });
        gsap.to(scene.rotation, { y: '+=0.5', duration: 1, ease: 'power2.out' });
      } else {
        const targets = getCameraTargets();
        camera.position.set(0, targets.y, targets.z);
        camera.rotation.x = targets.rotX;
      }
      
      // Reset transition state after delay
      viewToggleTimeout = setTimeout(() => {
        isViewTransitioning = false;
        viewToggleTimeout = null;
      }, animateCamera ? 2000 : 100);
    }
    
    // Initialize grid on load without animation
    updateGrid(false);
    
    // Add event listeners for view toggle buttons with debouncing
    document.querySelectorAll('.left-toggle-nav button').forEach(btn => {
      btn.addEventListener('click', () => {
        if (isViewTransitioning) return;
        
        const newGrid = btn.id === 'microBtn' ? 'micro' : 'macro';
        if (newGrid !== currentGrid) {
          document.querySelectorAll('.left-toggle-nav button').forEach(b => {
            b.classList.remove('active');
            b.setAttribute('aria-pressed', 'false');
          });
          btn.classList.add('active');
          btn.setAttribute('aria-pressed', 'true');
          currentGrid = newGrid;
          updateGrid(true);
        }
      });
    });
    
    const raycaster = new THREE.Raycaster(); // Raycaster for mouse intersections
    const mouse = new THREE.Vector2(); // Normalized mouse coordinates
    let mode = 'push'; // Initial interaction mode
    
    // Function to cap angular velocity to prevent excessive spinning
    function capAngularVelocity(body, maxAngularVelocity = 15) {
      const currentVel = body.angularVelocity;
      const velMagnitude = Math.sqrt(
        currentVel.x * currentVel.x + 
        currentVel.y * currentVel.y + 
        currentVel.z * currentVel.z
      );
      
      if (velMagnitude > maxAngularVelocity) {
        const scale = maxAngularVelocity / velMagnitude;
        currentVel.x *= scale;
        currentVel.y *= scale;
        currentVel.z *= scale;
      }
      
      // Apply damping to reduce spin over time
      body.angularDamping = 0.6;
    }
    
    // Function to toggle cube to pink color on all faces
    function toggleCubePink(cube) {
      const pinkFaceMaterials = [
        pinkMaterial,  // right
        pinkMaterial,  // left
        pinkMaterial,  // top
        pinkMaterial,  // bottom
        pinkMaterial,  // front
        pinkMaterial   // back
      ];
      
      if (cube.isPink) {
        // Revert to original materials
        cube.mesh.material = cube.originalMaterials;
        cube.isPink = false;
      } else {
        // Apply pink to all faces
        cube.mesh.material = pinkFaceMaterials;
        cube.isPink = true;
        
        // Animate scale for visual feedback
        gsap.to(cube.mesh.scale, {
          x: 1.1, y: 1.1, z: 1.1,
          duration: 0.2,
          ease: "back.out",
          yoyo: true,
          repeat: 1
        });
      }
    }
    
    // Handle mouse click or touch for cube interaction
    function onMouseClick(event) {
      if (event.target.closest('button') || event.target.closest('.fab')) return;
      
      // Handle both mouse and touch input
      let clientX = event.clientX;
      let clientY = event.clientY;
      if (event.changedTouches && event.changedTouches.length > 0) {
        clientX = event.changedTouches[0].clientX;
        clientY = event.changedTouches[0].clientY;
      }

      mouse.x = (clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(cubes.map(c => c.mesh));
      
      if (intersects.length > 0) {
        const intersect = intersects[0];
        const point = intersect.point.clone();
        let impulseStrength = 50;
        
        // Toggle pink color on the clicked cube
        const clickedCube = cubes.find(c => c.mesh === intersect.object);
        if (clickedCube) {
          toggleCubePink(clickedCube);
        }
        
        // Apply mode-specific impulses
        if (mode === 'pull') {
          // Pull: Draws single object toward camera (positive Z impulse)
          const cube = cubes.find(c => c.mesh === intersect.object);
          if (cube) {
            cube.body.wakeUp();
            const impulse = new CANNON.Vec3(0, 0, impulseStrength * 2);
            cube.body.applyImpulse(impulse, cube.body.position);
          }
        } else if (mode === 'push') {
          // Push: Straight forward trajectory (negative Z) with low radius influence
          const radius = 4; // Low radius
          cubes.forEach(cube => {
            const dist = cube.mesh.position.distanceTo(point);
            if (dist < radius) {
              cube.body.wakeUp();
              const factor = 1 - dist / radius;
              const impulse = new CANNON.Vec3(0, 0, -impulseStrength * factor);
              cube.body.applyImpulse(impulse, cube.body.position);
              // Apply controlled torque
              const maxTorque = 30;
              const torque = new CANNON.Vec3(
                (Math.random() - 0.5) * maxTorque * factor,
                (Math.random() - 0.5) * maxTorque * factor,
                (Math.random() - 0.5) * maxTorque * factor
              );
              cube.body.angularVelocity.set(torque.x, torque.y, torque.z);
              capAngularVelocity(cube.body);
            }
          });
        } else if (mode === 'force') {
          // Force: Forward push (negative Z) with moderate radius influence
          const radius = 14; // Moderate radius
          cubes.forEach(cube => {
            const dist = cube.mesh.position.distanceTo(point);
            if (dist < radius) {
              cube.body.wakeUp();
              const factor = 1 - dist / radius;
              const impulse = new CANNON.Vec3(0, 0, -impulseStrength * factor * 3.5);
              cube.body.applyImpulse(impulse, cube.body.position);
              // Apply torque for rotation
              const torque = new CANNON.Vec3(
                (Math.random() - 0.5) * 666 * factor,
                (Math.random() - 0.5) * 333 * factor,
                (Math.random() - 0.5) * 15 * factor
              );
              cube.body.angularVelocity.vadd(torque, cube.body.angularVelocity);
              capAngularVelocity(cube.body, 20);
            }
          });
        }
      }
    }
    
    // Add event listeners for click and touch
    window.addEventListener('click', onMouseClick);
    window.addEventListener('touchstart', onMouseClick, { passive: true });
    
    // Target and current rotation for scene tilting based on mouse/touch
    const targetRotation = { x: 0, y: 0 };
    const currentRotation = { x: 0, y: 0 };
    
    // Handle mouse movement for scene rotation
    function onMouseMove(event) {
      targetRotation.y = (event.clientX / window.innerWidth - 0.5) * 0.2;
      targetRotation.x = (event.clientY / window.innerHeight - 0.5) * 0.2;
    }
    
    window.addEventListener('mousemove', onMouseMove);
    
    // Handle touch movement for scene rotation
    let touchStartX = 0;
    let touchStartY = 0;
    window.addEventListener('touchstart', (event) => {
      touchStartX = event.touches[0].clientX;
      touchStartY = event.touches[0].clientY;
    }, { passive: true });
    
    window.addEventListener('touchmove', (event) => {
      const deltaX = event.touches[0].clientX - touchStartX;
      const deltaY = event.touches[0].clientY - touchStartY;
      targetRotation.y += deltaX * 0.002;
      targetRotation.x += deltaY * 0.002;
      touchStartX = event.touches[0].clientX;
      touchStartY = event.touches[0].clientY;
    }, { passive: true });
    
    let lastTime = 0; // Track last animation frame time
    const fixedTimeStep = 1.0 / 60.0; // Fixed physics step
    
    // Main animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      const currentTime = performance.now() / 1000;
      const deltaTime = currentTime - lastTime;
      lastTime = currentTime;
      
      // Cap delta time to prevent physics instability
      const safeDelta = Math.min(deltaTime, 0.1);

      world.step(fixedTimeStep, safeDelta, 3);
      
      // Sync mesh positions/rotations with physics bodies and apply continuous damping
      cubes.forEach(({ mesh, body }) => {
        mesh.position.copy(body.position);
        mesh.quaternion.copy(body.quaternion);
        
        if (body.angularVelocity.length() > 0.1) {
          capAngularVelocity(body, 10);
        }
      });
      
      // Smoothly interpolate scene rotation
      currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
      currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;
      
      scene.rotation.x = currentRotation.x;
      scene.rotation.y = currentRotation.y;
      
      // Update cube map for reflections
      cubes.forEach(c => c.mesh.visible = false);
      logoPlane.visible = true;
      cubeCamera.position.set(0, 0, 0);
      cubeCamera.update(renderer, scene);
      cubes.forEach(c => c.mesh.visible = true);
      
      renderer.render(scene, camera);
    }
    
    // Debounced window resize handler
    let resizeTimeout;
    function onWindowResize() {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        updateGrid(true);
      }, 100);
    }
    
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('orientationchange', () => {
      setTimeout(onWindowResize, 200);
    });
    
    animate();

    // Add event listeners for interaction mode buttons
    document.querySelectorAll('.right-toggle-nav button').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.right-toggle-nav button').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        mode = btn.id.replace('Btn', '').toLowerCase();
        // No mode-specific gravity changes; use consistent realistic gravity
      });
    });

    // Overlay management for info sheet
    const fabButton = document.getElementById('fabButton');
    const overlay = document.getElementById('overlay');
    const closeOverlayBtn = document.getElementById('closeOverlay');
    let lastFocus = null;

    function openOverlay() {
      lastFocus = document.activeElement;
      overlay.classList.add('open');
      const sheet = overlay.querySelector('.sheet');
      sheet.setAttribute('tabindex', '-1');

      gsap.fromTo(sheet, 
        { x: '100%', opacity: 0, scale: 0.95 },  
        { x: '0%', opacity: 1, scale: 1, duration: 0.5, ease: 'power3.out' }  
      );

      sheet.focus();
      overlay.setAttribute('aria-hidden', 'false');
      fabButton.setAttribute('aria-expanded', 'true');
      overlay.addEventListener('click', handleOutsideClick);
    }

    function closeOverlayFn() {
      const sheet = overlay.querySelector('.sheet');

      gsap.to(sheet, {
        x: '100%', opacity: 0, scale: 0.95, duration: 0.3, ease: 'power2.in',
        onComplete: () => {
          overlay.classList.remove('open');
          overlay.setAttribute('aria-hidden', 'true');
          fabButton.setAttribute('aria-expanded', 'false');
          if (lastFocus) lastFocus.focus();
          overlay.removeEventListener('click', handleOutsideClick);
        }
      });
    }

    function handleOutsideClick(e) {
      const sheet = overlay.querySelector('.sheet');
      if (!sheet.contains(e.target)) {
        closeOverlayFn();
      }
    }

    fabButton.addEventListener('click', openOverlay);
    closeOverlayBtn.addEventListener('click', closeOverlayFn);

    // Reset cubes to initial positions and states
    function resetCubes() {
      cubes.forEach(({ body, initial, originalMaterials }) => {
        body.position.set(initial.x, initial.y, initial.z);
        body.velocity.set(0, 0, 0);
        body.angularVelocity.set(0, 0, 0);
        body.quaternion.set(0, 0, 0, 1);
        body.wakeUp();
        
        // Reset to original materials and scale
        const cube = cubes.find(c => c.body === body);
        if (cube && cube.isPink) {
          cube.mesh.material = originalMaterials;
          cube.isPink = false;
          cube.mesh.scale.set(1, 1, 1);
        }
      });
      bounceAndSettle();
    }

    document.getElementById('resetBtn').addEventListener('click', () => {
      resetCubes();
      closeOverlayFn();
    });
    document.getElementById('resetTopBtn').addEventListener('click', resetCubes);

    // Spacebar reset shortcut
    document.addEventListener('keydown', (event) => {
      if (event.key === ' ') {
        event.preventDefault();
        resetCubes();
      }
    });

    // Custom cursor trail effect (desktop only)
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const isFinePointer = window.matchMedia('(pointer: fine)').matches;
    const shouldRunCursor = isFinePointer && !prefersReducedMotion && !isMobileDevice;

    if (shouldRunCursor) {
      (() => {
        const TAIL_LENGTH = window.innerWidth < 800 ? 6 : 14;
        const host = document.getElementById('cursor');
        if (!host) return;
        for (let i = 0; i < TAIL_LENGTH; i++) {
          const d = document.createElement('div');
          d.className = 'cursor-circle';
          host.appendChild(d);
        }
        const circles = host.querySelectorAll('.cursor-circle');
        let mouseX = window.innerWidth / 2, mouseY = window.innerHeight / 2;
        const history = Array(TAIL_LENGTH).fill(0).map(() => ({ x: mouseX, y: mouseY }));
        window.addEventListener('pointermove', e => {
          mouseX = e.clientX;
          mouseY = e.clientY;
        }, { passive: true });
        function tick() {
          history.shift();
          history.push({ x: mouseX, y: mouseY });
          circles.forEach((c, i) => {
            const cur = history[i];
            const next = history[i + 1] || history[TAIL_LENGTH - 1];
            cur.x += (next.x - cur.x) * 0.35;
            cur.y += (next.y - cur.y) * 0.35;
            const s = Math.max(0.22, i / TAIL_LENGTH);
            c.style.transform = `translate(calc(${cur.x}px - 50%), calc(${cur.y}px - 50%)) scale(${s})`;
          });
          requestAnimationFrame(tick);
        }
        tick();
      })();
    }

    // Navigation button event listeners
    document.getElementById('cvBtn').addEventListener('click', () => window.location.href = 'https://intoview.pro/cv');
    document.getElementById('noteBtn').addEventListener('click', () => window.location.href = 'https://intoview.pro/note');
    document.getElementById('kanbanBtn').addEventListener('click', () => window.location.href = 'https://intoview.pro/kanban');
    document.getElementById('melodyBtn').addEventListener('click', () => window.location.href = 'https://intoview.pro/melody');
    document.getElementById('emdashBtn').addEventListener('click', () => window.location.href = 'https://emdash.click/');
    document.getElementById('portfolioBtn').addEventListener('click', () => window.location.href = 'https://zackgort.com');

    // Context menu management
    const contextMenu = document.getElementById('contextMenu');

    document.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      contextMenu.style.left = `${e.pageX}px`;
      contextMenu.style.top = `${e.pageY}px`;
      contextMenu.style.display = 'block';
    });

    document.addEventListener('click', (e) => {
      if (!contextMenu.contains(e.target)) {
        contextMenu.style.display = 'none';
      }
    });

    document.getElementById('contextReset').addEventListener('click', () => {
      resetCubes();
      contextMenu.style.display = 'none';
    });
    
    document.getElementById('contextCopyResume').addEventListener('click', () => {
      navigator.clipboard.writeText('https://intoview.pro/cv').then(() => {
        alert('Resume link copied!');
      });
      contextMenu.style.display = 'none';
    });

    document.getElementById('contextCopyPortfolio').addEventListener('click', () => {
      navigator.clipboard.writeText('https://zackgort.com').then(() => {
        alert('Portfolio link copied!');
      });
      contextMenu.style.display = 'none';
    });

    // Zoom functionality with constraints
    let isZooming = false;
    let zoomTimeout = null;
    let currentZoom = 1;
    let targetZoom = 1;
    
    const zoomConstraints = {
      micro: {
        min: 0.5,
        max: 2.0,
        sensitivity: 0.001
      },
      macro: {
        min: 0.3,
        max: 2.5,
        sensitivity: 0.001
      }
    };
    
    let baseCameraZ = camera.position.z;
    let baseCameraY = camera.position.y;
    
    // Update camera position based on zoom level
    function updateCameraZoom() {
      if (isViewTransitioning) return;
      
      const constraints = zoomConstraints[currentGrid];
      targetZoom = Math.max(constraints.min, Math.min(constraints.max, targetZoom));
      
      const zoomSpeed = 0.1;
      currentZoom += (targetZoom - currentZoom) * zoomSpeed;
      
      const newZ = baseCameraZ / currentZoom;
      const newY = baseCameraY + (getCameraTargets().y - baseCameraY) * (1 - currentZoom) * 0.5;
      
      gsap.to(camera.position, {
        z: newZ,
        y: newY,
        duration: 0.2,
        ease: "power2.out",
        onUpdate: () => {
          const finalConstraints = zoomConstraints[currentGrid];
          if (camera.position.z < getCameraTargets().z * finalConstraints.min) {
            camera.position.z = getCameraTargets().z * finalConstraints.min;
          } else if (camera.position.z > getCameraTargets().z * finalConstraints.max) {
            camera.position.z = getCameraTargets().z * finalConstraints.max;
          }
        }
      });
    }
    
    // Handle wheel event for zooming
    function handleWheel(event) {
      if (event.target.closest('button') || event.target.closest('.fab') || event.target.closest('.sheet')) {
        return;
      }
      
      event.preventDefault();
      
      const constraints = zoomConstraints[currentGrid];
      const delta = event.deltaY * constraints.sensitivity;
      
      targetZoom -= delta;
      targetZoom = Math.max(constraints.min, Math.min(constraints.max, targetZoom));
      
      if (zoomTimeout) {
        clearTimeout(zoomTimeout);
      }
      
      isZooming = true;
      updateCameraZoom();
      
      zoomTimeout = setTimeout(() => {
        isZooming = false;
        zoomTimeout = null;
      }, 50);
    }
    
    window.addEventListener('wheel', handleWheel, { passive: false });
    
    // Update base camera positions after view changes
    const originalUpdateGrid = updateGrid;
    updateGrid = function(animateCamera = false, forceUpdate = false) {
      originalUpdateGrid(animateCamera, forceUpdate);
      
      setTimeout(() => {
        baseCameraZ = camera.position.z;
        baseCameraY = camera.position.y;
        currentZoom = 1;
        targetZoom = 1;
      }, animateCamera ? 2100 : 100);
    };
    
    // Continuous zoom update in requestAnimationFrame
    function animateZoom() {
      if (isZooming || Math.abs(targetZoom - currentZoom) > 0.001) {
        updateCameraZoom();
      }
      requestAnimationFrame(animateZoom);
    }
    animateZoom();
  </script>
</body>
</html>
