<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Click for clarity</title>
  <link href="https://fonts.googleapis.com" rel="preconnect" crossorigin>
  <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      overflow: hidden;
      font-family: 'Arial', sans-serif;
      background: #0f1014; /* Dark Default */
    }
    
    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      outline: none;
    }
    
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }
    
    .instruction {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 11px;
      color: rgba(255, 255, 255, 0.5);
      letter-spacing: 0.2em;
      text-transform: uppercase;
      user-select: none;
      max-width: 90%;
      text-align: center;
      white-space: nowrap;
      pointer-events: none;
      text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    }

    :root {
      --bg-color: #0f1014;
      --card-color: transparent;
      --ink: #ffffff;
      --ink-2: #9f9f9f;
      --ink-3: #6c6c6c;
      --accent: #83ff83;
      --curve-k: 1;
      --vig-opacity: .01;
      --edge-blur: 4.4px;
      --cursor-size: 20px;
      --corner-pad: clamp(16px, 4vw, 24px);
      --corner-top: calc(env(safe-area-inset-top) + clamp(12px, 2vh, 18px));
      --z-grain: 149;
      --z-blur: 4;
      --z-vig: .01;
      --z-ui: 220;
      --z-overlay: 250;
      --z-cursor: 230;
      --glass-bg: rgba(255, 255, 255, 0.04);
      --glass-bg-hover: rgba(255, 255, 255, 0.08);
      --glass-bg-bright: rgba(255, 255, 255, 0.12);
      --glass-border: rgba(255, 255, 255, 0.12);
      --fab-size: 80px;
      --fab-bottom: calc(env(safe-area-inset-bottom) + clamp(16px, 3vh, 32px));
      --base-font-size: 14px;
      --subtle-outline: rgba(255, 255, 255, 0.08);
      --font-stack: Inter, ui-sans-serif, system-ui;
    }

    [data-theme="dark"] {
      --bg-color: #0f1014;
      --ink: #ffffff;
      --ink-2: #9f9f9f;
      --ink-3: #6c6c6c;
      --accent: #83ff83;
      --glass-bg: rgba(20, 21, 26, 0.6);
      --glass-bg-hover: rgba(255, 255, 255, 0.1);
      --glass-bg-bright: rgba(255, 255, 255, 0.15);
      --glass-border: rgba(255, 255, 255, 0.15);
      --vig-opacity: .01;
      --edge-blur: 4.4px;
      color-scheme: dark;
    }

    [data-theme="dark"] .vignette {
      background: radial-gradient(120% 90% at 50% 50%, #fff0 10%, rgb(15 16 20 / 0.8) 60%, rgb(15 16 20 / 1) 100%);
    }

    /* Mobile Optimization: Hide edge-blur to prevent graphical artifacts */
    @media (max-width: 768px) {
      .edge-blur {
        display: none !important;
      }
      .vignette {
        opacity: 0.3 !important; /* Reduce vignette intensity on mobile */
      }
    }

    @media (pointer: coarse) {
      .corner-reset {
        top: auto;
        bottom: var(--fab-bottom);
        left: var(--corner-pad);
        right: auto;
      }
      .top-toggle-nav, .left-toggle-nav, .right-toggle-nav {
        gap: 4px;
        padding: 4px;
      }
      .top-toggle-nav button, .left-toggle-nav button, .right-toggle-nav button {
        padding: 8px 12px;
      }
      .top-toggle-nav button .text {
        display: none;
      }
      .top-toggle-nav button .emoji {
        display: inline;
        font-size: 1.2em;
      }
      .top-toggle-nav button svg {
        display: none;
      }
      .right-toggle-nav button .text, .left-toggle-nav button .text {
        display: none;
      }
      .right-toggle-nav button .emoji, .left-toggle-nav button .emoji {
        display: inline;
        font-size: 1.2em;
      }
      .instruction {
        bottom: 20px;
        font-size: 10px;
        white-space: normal;
        line-height: 1.4;
      }
      .fab {
        --fab-size: 60px;
      }
      .fab svg {
        width: 24px;
        height: 24px;
      }
      .logo img {
        height: 24px;
      }
      .sheet {
        padding: 16px;
        width: 100%; /* Full width sheet on mobile */
      }
      .reset-btn {
        padding: 8px 16px;
      }
      /* Prevent scrolling on Top Nav on mobile */
      .top-toggle-nav {
        max-width: 90vw;
        overflow-x: auto;
        justify-content: flex-start;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
      }
      .top-toggle-nav::-webkit-scrollbar {
        display: none;
      }
    }

    *, *::before, *::after { box-sizing: border-box; }
    html { color-scheme: dark; font-size: var(--base-font-size); }
    body, html { height: 100%; margin: 0; background: var(--bg-color); }
    body {
      color: var(--ink);
      font-family: var(--font-stack);
      line-height: 1.4;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      touch-action: none; /* Prevent scroll on canvas */
      -webkit-user-select: none;
      user-select: none;
      overscroll-behavior: none;
      transition: background-color 0.5s ease, color 0.5s ease;
    }

    body::after {
      content: ""; position: fixed; inset: 0; pointer-events: none; z-index: var(--z-grain); opacity: 0.07;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.45'/%3E%3C/svg%3E");
      background-size: 120px 120px;
    }

    .logo {
      position: fixed;
      top: var(--corner-top);
      left: var(--corner-pad);
      z-index: var(--z-ui);
      pointer-events: none;
    }

    .logo img {
      height: 32px;
      width: auto;
      display: block;
      transition: opacity 0.2s ease;
    }

    .corner-reset {
      position: fixed;
      top: var(--corner-top);
      right: var(--corner-pad);
      z-index: var(--z-ui);
      background: var(--glass-bg);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      padding: 6px;
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      pointer-events: auto;
    }

    .corner-reset button {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: var(--ink);
      cursor: pointer;
      transition: background 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
    }

    .corner-reset button:hover {
      background: var(--glass-bg-hover);
      border-radius: 4px;
    }

    .top-toggle-nav {
      position: fixed;
      top: var(--corner-top);
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: var(--z-ui);
      background: var(--glass-bg);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      padding: 6px;
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      pointer-events: auto;
    }

    .top-toggle-nav button {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: var(--ink);
      cursor: pointer;
      transition: background 0.2s ease;
      display: flex;
      align-items: center;
      border-radius: 4px;
    }

    .top-toggle-nav button:hover {
      background: var(--glass-bg-hover);
    }

    .top-toggle-nav button svg {
      width: 1em;
      height: 1em;
      margin-left: 0.5em;
    }

    .top-toggle-nav button .emoji {
      display: none;
    }

    .fab {
      position: fixed;
      bottom: var(--fab-bottom);
      right: var(--corner-pad);
      z-index: var(--z-ui);
      width: var(--fab-size);
      height: var(--fab-size);
      border-radius: 50%;
      background: var(--glass-bg-bright);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid var(--glass-border);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 0.2s ease, background 0.2s ease;
      pointer-events: auto;
    }

    .fab:active {
        transform: scale(0.95);
    }

    .fab svg {
      width: 32px;
      height: 32px;
    }

    .overlay-sheet {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: var(--z-overlay);
      opacity: 0;
      transition: opacity 0.2s ease;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(4px);
    }

    .overlay-sheet.open {
      opacity: 1;
      pointer-events: auto;
    }

    .sheet {
      position: fixed;
      right: 0;
      top: 0;
      bottom: 0;
      width: 400px;
      background: #0f1014;
      border-left: 1px solid var(--glass-border);
      padding: 24px;
      overflow-y: auto;
      box-shadow: -10px 0 30px rgba(0,0,0,0.5);
    }

    .close-btn {
      position: absolute;
      top: 16px;
      right: 16px;
      background: transparent;
      border: none;
      font-size: 28px;
      cursor: pointer;
      color: var(--ink);
      opacity: 0.7;
      transition: opacity 0.2s;
    }
    
    .close-btn:hover { opacity: 1; }

    .reset-btn {
      padding: 12px 24px;
      background: var(--accent);
      color: #000;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 16px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    #cursor {
      position: fixed;
      pointer-events: none;
      z-index: var(--z-cursor);
    }

    .cursor-circle {
      position: absolute;
      width: var(--cursor-size);
      height: var(--cursor-size);
      border-radius: 50%;
      background: var(--accent);
      opacity: 0.2;
      transform: translate(-50%, -50%);
    }

    .context-menu {
      display: none;
      position: absolute;
      background: rgba(15, 16, 20, 0.95);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      padding: 8px;
      z-index: 300;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    }

    .context-menu button {
      display: block;
      width: 100%;
      text-align: left;
      padding: 10px 16px;
      background: transparent;
      border: none;
      color: var(--ink);
      cursor: pointer;
      border-radius: 4px;
      font-size: 13px;
    }

    .context-menu button:hover {
      background: var(--glass-bg-hover);
    }

    .vignette {
      position: fixed; inset: 0; pointer-events: none; z-index: var(--z-vig);
      background: radial-gradient(120% 90% at 50% 50%, #fff0 10%, rgb(15 16 20 / 0.8) 60%, rgb(15 16 20 / 1) 100%);
      opacity: var(--vig-opacity);
    }

    .edge-blur {
      position: fixed; inset: 0; pointer-events: none; z-index: var(--z-blur);
      backdrop-filter: blur(var(--edge-blur)); -webkit-backdrop-filter: blur(var(--edge-blur));
      mask: radial-gradient(100% 64% at 50% 50%, transparent 40%, rgb(255 255 255 / 0.98) 60%);
      -webkit-mask: radial-gradient(100% 64% at 50% 50%, transparent 40%, rgb(255 255 255 / 0.98) 60%);
    }

    .right-toggle-nav, .left-toggle-nav {
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: var(--z-ui);
      background: var(--glass-bg);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      padding: 6px;
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      pointer-events: auto;
      overflow-y: auto;
      max-height: 80vh;
    }

    .left-toggle-nav {
      left: var(--corner-pad);
    }

    .right-toggle-nav {
      right: var(--corner-pad);
    }

    .right-toggle-nav button, .left-toggle-nav button {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: var(--ink);
      cursor: pointer;
      transition: background 0.2s ease;
      display: flex;
      align-items: center;
      border-radius: 4px;
    }

    .right-toggle-nav button:hover, .left-toggle-nav button:hover {
      background: var(--glass-bg-hover);
    }

    .right-toggle-nav button.active, .left-toggle-nav button.active {
      background: var(--glass-bg-bright);
      color: var(--accent);
    }

  </style>
</head>
<body data-theme="dark">
  <div class="logo">
    <img id="logoImg" src="https://raw.githubusercontent.com/ZACKGORT/intoview/main/intoview-logo-light.svg.svg" alt="IntoView Logo">
  </div>

  <div class="corner-reset">
    <button id="resetTopBtn"><span class="text">Reset</span><span class="emoji">üîÑ</span></button>
  </div>

  <svg style="position: absolute; height: 0; width: 0;">
    <filter id="goo">
      <feGaussianBlur in="SourceGraphic" stdDeviation="1" result="blur" />
      <feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0  0 0  0 0 0 20 -10" result="goo" />
      <feBlend in="SourceGraphic" in2="goo" />
    </filter>
  </svg>
  
  <canvas id="canvas"></canvas>
  <div class="overlay">
    <div class="instruction">One does not simply rebuild. One resets. Then builds. ‚Äî Zack Gort</div>
  </div>

  <div class="edge-blur"></div>
  <div class="vignette"></div>
  <div id="cursor"></div>

  <div class="top-toggle-nav">
    <button id="cvBtn"><span class="text">CV</span><span class="emoji">üìÑ</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></button>
    <button id="noteBtn"><span class="text">Note</span><span class="emoji">üìì</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></button>
    <button id="kanbanBtn"><span class="text">Kanban</span><span class="emoji">üóÇÔ∏è</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></button>
    <button id="melodyBtn"><span class="text">Melody</span><span class="emoji">üé∂</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></button>
    <button id="emdashBtn"><span class="text">Emdash</span><span class="emoji">üìù</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></button>
    <button id="portfolioBtn"><span class="text">Portfolio</span><span class="emoji">üñºÔ∏è</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></button>
  </div>

  <div class="left-toggle-nav">
    <button id="microBtn"><span class="text">Micro</span><span class="emoji">üîç</span></button>
    <button id="macroBtn" class="active"><span class="text">Macro</span><span class="emoji">üåê</span></button>
  </div>

  <div class="right-toggle-nav">
    <button id="jediBtn" title="Force: directional launch with radius influence"><span class="text">Force</span><span class="emoji">ü™Ñ</span></button>
    <button id="kickBtn" class="active" title="Kick: use current settings"><span class="text">Kick</span><span class="emoji">‚öΩ</span></button>
    <button id="pewBtn" title="Pew: shoots the block straight back like a bullet"><span class="text">Pew</span><span class="emoji">üöÄ</span></button>
  </div>

  <div class="fab-wrap">
    <button id="fabButton" class="fab" aria-label="Open menu">
      <svg viewBox="0 0 100 100" aria-hidden="true">
        <defs>
          <linearGradient id="cubeTop" x1="0" x2="1" y1="0" y2="1">
            <stop offset="0" stop-color="#fff" stop-opacity="1" />
            <stop offset="1" stop-color="#dcdcdc" stop-opacity="1" />
          </linearGradient>
          <linearGradient id="cubeSide" x1="0" x2="1" y1="0" y2="1">
            <stop offset="0" stop-color="#e8e8e8" />
            <stop offset="1" stop-color="#bdbdbd" />
          </linearGradient>
          <linearGradient id="cubeDark" x1="0" x2="1" y1="0" y2="1">
            <stop offset="0" stop-color="#8a8a8a" />
            <stop offset="1" stop-color="#4b4b4b" />
          </linearGradient>
          <filter id="cubeGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="6" stdDeviation="6" flood-color="#0f1014" flood-opacity=".45" />
          </filter>
        </defs>
        <g filter="url(#cubeGlow)">
          <polygon fill="url(#cubeTop)" points="50,14 80,30 50,46 20,30" />
          <polygon fill="url(#cubeSide)" points="80,30 80,66 50,82 50,46" />
          <polygon fill="url(#cubeDark)" points="50,46 50,82 20,66 20,30" />
        </g>
      </svg>
    </button>
  </div>

  <div id="overlay" class="overlay-sheet" aria-hidden="true">
    <div class="sheet">
      <button id="closeOverlay" class="close-btn">√ó</button>
      <div class="sheet-content">
        <h3 style="margin-bottom: 1rem; color: var(--accent);">Think Pink #FF8DA1</h3>
        <div class="accordion-content">
          <p>Long story short, I was adopted and shipped to the US in a pink onezie (which is a boy's color in Korea). Anyway, it's become part of my personal brand, signifying my embrace of defying expectations from the get-go.</p>
        </div><br>
        <p>As for <strong>intoview.pro</strong>, I am using this space as a place for creative exploration and furtherence of my craft.</p>
      </div><br>

        <h2>Meanwhile...</h2>
        <p style="opacity: 0.7; font-size: 0.9em; margin-top: 0.5rem;">Go kick [blocks]</p>
        <button id="resetBtn" class="reset-btn">#yolo</button>
      </div>
    </div>
  </div>

  <div id="contextMenu" class="context-menu">
    <button id="contextReset">Reset</button>
    <button id="contextCopyResume">Copy Resume Link</button>
    <button id="contextCopyPortfolio">Copy Portfolio Link</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
  
  <script>
    class ThinFilmFresnelMap extends THREE.Texture {
      constructor(thickness = 500) {
        super();
        this.thickness = thickness;
        this.generate();
      }

      generate() {
        const width = 512;
        const height = 1;
        const data = new Uint8Array(width * 4);
        for (let i = 0; i < width; i++) {
          const cosTheta = i / width;
          const u = Math.pow(1 - cosTheta, 5);
          data[i * 4] = Math.floor(255 * (0.04 + (1 - 0.04) * u) + Math.sin(this.thickness / 100 * i / width * 2 * Math.PI) * 0.5 + 0.5 * 255);
          data[i * 4 + 1] = Math.floor(255 * u + Math.sin(this.thickness / 100 * i / width * 2 * Math.PI + 2 * Math.PI / 3) * 0.5 + 0.5 * 255);
          data[i * 4 + 2] = Math.floor(255 * u + Math.sin(this.thickness / 100 * Math.PI * 2 * i / width + 4 * Math.PI / 3) * 0.5 + 0.5 * 255);
          data[i * 4 + 3] = 255;
        }
        this.image = { data, width, height };
        this.magFilter = THREE.LinearFilter;
        this.minFilter = THREE.LinearFilter;
        this.wrapS = THREE.ClampToEdgeWrapping;
        this.wrapT = THREE.ClampToEdgeWrapping;
        this.needsUpdate = true;
      }
    }

    // Detect mobile
    const isMobileDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

    const canvas = document.getElementById('canvas');
    const scene = new THREE.Scene();
    
    // Set Scene Background to Dark Theme Color immediately
    scene.background = new THREE.Color(0x0f1014);
    
    // Camera
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 11);
    
    // Renderer - Disable antialias on mobile for performance
    const renderer = new THREE.WebGLRenderer({ 
      canvas, 
      antialias: !isMobileDevice,
      powerPreference: "high-performance"
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    // Physics world
    const world = new CANNON.World();
    world.gravity.set(0, -15, 0);
    world.broadphase = new CANNON.NaiveBroadphase();
    // Default material
    const defaultMaterial = new CANNON.Material();
    const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
      friction: 0.3,
      restitution: 0.5
    });
    world.addContactMaterial(defaultContactMaterial);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const accentLight = new THREE.PointLight(0xff8Da1, 3, 20); 
    accentLight.position.set(-8, 5, 10);
    scene.add(accentLight);
    
    const whiteLight = new THREE.PointLight(0xffffff, 2, 100);
    whiteLight.position.set(8, 5, 10);
    scene.add(whiteLight);
    
    const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
    mainLight.position.set(5, 15, 10);
    mainLight.castShadow = true;
    
    // Optimize shadows for mobile
    const shadowSize = isMobileDevice ? 512 : 2048;
    mainLight.shadow.mapSize.width = shadowSize;
    mainLight.shadow.mapSize.height = shadowSize;
    
    // Increase shadow cam frustum to prevent clipping artifacts (Green walls issue)
    const d = 30;
    mainLight.shadow.camera.left = -d;
    mainLight.shadow.camera.right = d;
    mainLight.shadow.camera.top = d;
    mainLight.shadow.camera.bottom = -d;
    
    scene.add(mainLight);
    
    // Dynamically set accent color for 3D elements
    const accentHex = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
    const accentColor = new THREE.Color(accentHex);
    
    // Update materials and lights with accent color
    const accentMaterial = new THREE.MeshStandardMaterial({
      color: accentColor, 
      metalness: 0.222,
      roughness: 0.333
    });
    accentLight.color = accentColor; 
    
    // Load IntoView logo SVG
    const svgString = `
      <svg width="332" height="83" viewBox="0 0 332 83" fill="none" xmlns="http://www.w3.org/2000/svg">
         <path fill="#FF8DA1" d="M0,0 h332 v83 h-332 z" fill-opacity="0" /> 
      </svg>
    `;
    const originalSvg = document.getElementById('logoImg').src;
    const textureLoader = new THREE.TextureLoader();
    const logoTexture = textureLoader.load(originalSvg);
    
    const logoPlaneGeo = new THREE.PlaneGeometry(80, 20);
    const logoPlaneMat = new THREE.MeshBasicMaterial({ 
      map: logoTexture,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.9
    });
    const logoPlane = new THREE.Mesh(logoPlaneGeo, logoPlaneMat);
    logoPlane.position.set(0, 16, -166);
    scene.add(logoPlane);
    
    const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512, {
      format: THREE.RGBFormat,
      generateMipmaps: true,
      minFilter: THREE.LinearMipmapLinearFilter
    });
    const cubeCamera = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget);
    scene.add(cubeCamera);
    
    const groundGeo = new THREE.PlaneGeometry(800, 800);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x0f1014, roughness: 1, metalness: 0 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -6;
    ground.receiveShadow = true;
    scene.add(ground);
    
    const groundShape = new CANNON.Plane();
    const groundBody = new CANNON.Body({ mass: 0, material: defaultMaterial });
    groundBody.addShape(groundShape);
    groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
    groundBody.position.set(0, -6, 0);
    world.addBody(groundBody);
    
    let cubes = [];
    let cubeSize = 3.33;
    const fresnelMap = new ThinFilmFresnelMap();
    const mirrorMaterial = new THREE.MeshStandardMaterial({
      envMap: cubeRenderTarget.texture,
      metalness: 1,
      roughness: 0.05,
      color: 0x0f1014
    });
    
    mirrorMaterial.onBeforeCompile = (shader) => {
      shader.uniforms.fresnelMap = { value: fresnelMap };
      shader.fragmentShader = 'uniform sampler2D fresnelMap;\n' + shader.fragmentShader;
      shader.fragmentShader = shader.fragmentShader.replace(
        '#include <normal_fragment_maps>',
        '#include <normal_fragment_maps>\nvec3 viewDir = normalize( -vViewPosition );\nfloat dnv = saturate( dot( normal, viewDir ) );\nvec3 irid = texture2D( fresnelMap, vec2( dnv, 0.0 ) ).rgb;\nirid *= irid;\n'
      );
      shader.fragmentShader = shader.fragmentShader.replace(
        '#include <lights_fragment_end>',
        '#include <lights_fragment_end>\nreflectedLight.indirectSpecular *= irid;\nreflectedLight.directSpecular *= irid;\n'
      );
    };
    
    const gridGroup = new THREE.Group();
    scene.add(gridGroup);
    
    function createCubes(rows, cols) {
      const spacing = cubeSize;
      const bottomY = -6 + cubeSize / 2;
      const leftX = - (cols - 1) * spacing / 2;
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const cubeGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
          const materials = [
            accentMaterial, // right
            accentMaterial, // left
            accentMaterial, // top
            accentMaterial, // bottom
            mirrorMaterial, // front
            accentMaterial  // back
          ];
          const cube = new THREE.Mesh(cubeGeo, materials);
          const x = leftX + j * spacing;
          const y = bottomY + i * spacing;
          const z = 0;
          cube.position.set(x, y, z);
          cube.castShadow = true;
          cube.receiveShadow = true;
          gridGroup.add(cube);
          const shape = new CANNON.Box(new CANNON.Vec3(cubeSize / 2, cubeSize / 2, cubeSize / 2));
          const body = new CANNON.Body({ mass: 2, material: defaultMaterial });
          body.addShape(shape);
          body.position.set(x, y, z);
          body.linearDamping = 0.3;
          body.angularDamping = 0.3;
          world.addBody(body);
          cubes.push({ mesh: cube, body: body, initial: { x, y, z } });
        }
      }
    }
    
    function removeCubes() {
      cubes.forEach(({ mesh, body }) => {
        gridGroup.remove(mesh);
        world.remove(body);
      });
      cubes = [];
    }
    
    function bounceAndSettle() {
      cubes.forEach(({ body }) => {
        body.position.y += 0.5;
        body.wakeUp();
      });
      const fixedTimeStep = 1 / 60;
      // Reduce iterations on mobile to prevent freezing
      const iterations = isMobileDevice ? 20 : 60; 
      for (let i = 0; i < iterations; i++) {
        world.step(fixedTimeStep);
      }
      cubes.forEach(({ mesh, body }) => {
        mesh.position.copy(body.position);
        mesh.quaternion.copy(body.quaternion);
      });
    }
    
    let currentGrid = 'macro';
    function getCameraTargets() {
      const aspect = window.innerWidth / window.innerHeight;
      let rows, cols, sizeMultiplier;
      
      if (currentGrid === 'micro') {
        sizeMultiplier = isMobileDevice ? 0.85 : 1; 
        rows = isMobileDevice ? 7 : 5; // MORE ROWS FOR MOBILE
        cols = Math.round( (isMobileDevice ? 4 : 7) * aspect * 1.5 );
      } else {
        sizeMultiplier = isMobileDevice ? 0.75 : 1;
        rows = isMobileDevice ? 12 : 8; // MORE ROWS FOR MOBILE
        cols = Math.round( (isMobileDevice ? 6 : 16) * aspect * 1.2 );
      }
      
      // Safety clamps
      cols = Math.max(3, cols); 
      rows = Math.max(2, rows); 
      
      cubeSize = (currentGrid === 'micro' ? 3.33 : 2.5) * sizeMultiplier;
      const gridWidth = cols * cubeSize;
      const gridHeight = rows * cubeSize;
      
      // Center camera vertically on the grid roughly
      let targetCamY = -4; 
      if (isMobileDevice) {
         // On mobile, look slightly higher to see the full stack since it's now taller
         targetCamY = -6 + (gridHeight / 2.5); 
      }

      let targetCamZ;
      if (isMobileDevice) {
        // Custom Zoom for Mobile "Fill"
        // We set fixed distances for mobile to ensure the grid fills the screen 
        // without clipping or looking too distant.
        if (currentGrid === 'micro') {
            targetCamZ = 32; 
        } else {
            targetCamZ = 45; 
        }
      } else {
        // Desktop logic remains dynamic based on width
        targetCamZ = currentGrid === 'micro' ? gridWidth * 0.8 + 10 : gridWidth * 1.2 + 10;
        targetCamZ *= 0.44;
      }
      
      const targetRotX = 0.2;
      return { y: targetCamY, z: targetCamZ, rotX: targetRotX, rows, cols };
    }
    
    function updateGrid(animateCamera = false) {
      removeCubes();
      const { rows, cols } = getCameraTargets();
      createCubes(rows, cols);
      bounceAndSettle();
      if (animateCamera) {
        const targets = getCameraTargets();
        const duration = currentGrid === 'micro' ? 0.8 : 2;
        const posEase = currentGrid === 'micro' ? 'back.out' : 'power1.inOut';
        const rotEase = 'power1.inOut';
        gsap.to(camera.position, { y: targets.y, z: targets.z, duration, ease: posEase });
        gsap.to(camera.rotation, { x: targets.rotX, duration, ease: rotEase });
        gsap.to(scene.rotation, { y: '+=0.5', duration: 1, ease: 'power2.out' });
      } else {
        const targets = getCameraTargets();
        camera.position.set(0, targets.y, targets.z);
        camera.rotation.x = targets.rotX;
      }
    }
    
    // Initial load
    updateGrid(false);
    
    document.querySelectorAll('.left-toggle-nav button').forEach(btn => {
      btn.addEventListener('click', () => {
        const newGrid = btn.id === 'microBtn' ? 'micro' : 'macro';
        if (newGrid !== currentGrid) {
          document.querySelectorAll('.left-toggle-nav button').forEach(b => {
            b.classList.remove('active');
            b.setAttribute('aria-pressed', 'false');
          });
          btn.classList.add('active');
          btn.setAttribute('aria-pressed', 'true');
          currentGrid = newGrid;
          updateGrid(true);
        }
      });
    });
    
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let mode = 'kick';
    
    function onMouseClick(event) {
      if (event.target.closest('button') || event.target.closest('.fab')) return;
      
      // Update mouse position based on touch or click
      let clientX = event.clientX;
      let clientY = event.clientY;
      if (event.changedTouches && event.changedTouches.length > 0) {
        clientX = event.changedTouches[0].clientX;
        clientY = event.changedTouches[0].clientY;
      }

      mouse.x = (clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(cubes.map(c => c.mesh));
      
      if (intersects.length > 0) {
        const intersect = intersects[0];
        const point = intersect.point.clone();
        let impulseStrength = 50;
        if (mode === 'pew') {
          const cube = cubes.find(c => c.mesh === intersect.object);
          if (cube) {
            cube.body.wakeUp();
            const impulse = new CANNON.Vec3(0, 0, -impulseStrength * 2);
            cube.body.applyImpulse(impulse, cube.body.position);
          }
        } else if (mode === 'kick') {
          const cube = cubes.find(c => c.mesh === intersect.object);
          if (cube) {
            cube.body.wakeUp();
            const impulse = new CANNON.Vec3(0, 0, -impulseStrength);
            cube.body.applyImpulse(impulse, cube.body.position);
            const torque = new CANNON.Vec3(
              (Math.random() - 0.5) * 120,
              (Math.random() - 0.5) * 120,
              (Math.random() - 0.5) * 120
            );
            cube.body.angularVelocity.set(torque.x, torque.y, torque.z);
          }
        } else if (mode === 'jedi') {
          const radius = 7;
          cubes.forEach(cube => {
            const dist = cube.mesh.position.distanceTo(point);
            if (dist < radius) {
              cube.body.wakeUp();
              const factor = 1 - dist / radius;
              const direction = new CANNON.Vec3();
              direction.copy(point);
              direction.vsub(cube.body.position, direction);
              direction.normalize();
              direction.scale(-impulseStrength * factor * 3.5, direction);
              cube.body.applyImpulse(direction, cube.body.position);
              const torque = new CANNON.Vec3(
                (Math.random() - 0.5) * 333 * factor,
                (Math.random() - 0.5) * 222 * factor,
                (Math.random() - 0.5) * 50 * factor
              );
              cube.body.angularVelocity.vadd(torque, cube.body.angularVelocity);
            }
          });
        }
      }
    }
    
    // Unified event listener
    window.addEventListener('click', onMouseClick);
    window.addEventListener('touchstart', onMouseClick, { passive: true });
    
    const targetRotation = { x: 0, y: 0 };
    const currentRotation = { x: 0, y: 0 };
    
    function onMouseMove(event) {
      targetRotation.y = (event.clientX / window.innerWidth - 0.5) * 0.2;
      targetRotation.x = (event.clientY / window.innerHeight - 0.5) * 0.2;
    }
    
    window.addEventListener('mousemove', onMouseMove);
    
    let touchStartX = 0;
    let touchStartY = 0;
    window.addEventListener('touchstart', (event) => {
      touchStartX = event.touches[0].clientX;
      touchStartY = event.touches[0].clientY;
    }, { passive: true });
    
    window.addEventListener('touchmove', (event) => {
      const deltaX = event.touches[0].clientX - touchStartX;
      const deltaY = event.touches[0].clientY - touchStartY;
      targetRotation.y += deltaX * 0.002; // Slightly more sensitive on mobile
      targetRotation.x += deltaY * 0.002;
      touchStartX = event.touches[0].clientX;
      touchStartY = event.touches[0].clientY;
    }, { passive: true });
    
    let lastTime = 0;
    const fixedTimeStep = 1.0 / 60.0;
    
    function animate() {
      requestAnimationFrame(animate);
      
      const currentTime = performance.now() / 1000;
      const deltaTime = currentTime - lastTime;
      lastTime = currentTime;
      
      // Cap delta time to prevent spiraling physics
      const safeDelta = Math.min(deltaTime, 0.1);

      world.step(fixedTimeStep, safeDelta, 3);
      
      cubes.forEach(({ mesh, body }) => {
        mesh.position.copy(body.position);
        mesh.quaternion.copy(body.quaternion);
      });
      
      currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
      currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;
      
      scene.rotation.x = currentRotation.x;
      scene.rotation.y = currentRotation.y;
      
      // Update cube reflections
      cubes.forEach(c => c.mesh.visible = false);
      logoPlane.visible = true;
      cubeCamera.position.set(0, 0, 0);
      cubeCamera.update(renderer, scene);
      cubes.forEach(c => c.mesh.visible = true);
      
      renderer.render(scene, camera);
    }
    
    // Optimized resize handler
    let resizeTimeout;
    function onWindowResize() {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        updateGrid(true);
      }, 100);
    }
    
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('orientationchange', () => {
      setTimeout(onWindowResize, 200);
    });
    
    animate();

    document.querySelectorAll('.right-toggle-nav button').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.right-toggle-nav button').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        mode = btn.id.replace('Btn', '').toLowerCase();
        if (mode === 'jedi') {
          world.gravity.set(0, -5, 0);
        } else {
          world.gravity.set(0, -25, 0);
        }
      });
    });

    const fabButton = document.getElementById('fabButton');
    const overlay = document.getElementById('overlay');
    const closeOverlayBtn = document.getElementById('closeOverlay');
    let lastFocus = null;

    function openOverlay() {
      lastFocus = document.activeElement;
      overlay.classList.add('open');
      const sheet = overlay.querySelector('.sheet');
      sheet.setAttribute('tabindex', '-1');

      gsap.fromTo(sheet, 
        { x: '100%', opacity: 0, scale: 0.95 },  
        { x: '0%', opacity: 1, scale: 1, duration: 0.5, ease: 'power3.out' }  
      );

      sheet.focus();
      overlay.setAttribute('aria-hidden', 'false');
      fabButton.setAttribute('aria-expanded', 'true');
      overlay.addEventListener('click', handleOutsideClick);
    }

    function closeOverlayFn() {
      const sheet = overlay.querySelector('.sheet');

      gsap.to(sheet, {
        x: '100%', opacity: 0, scale: 0.95, duration: 0.3, ease: 'power2.in',
        onComplete: () => {
          overlay.classList.remove('open');
          overlay.setAttribute('aria-hidden', 'true');
          fabButton.setAttribute('aria-expanded', 'false');
          if (lastFocus) lastFocus.focus();
          overlay.removeEventListener('click', handleOutsideClick);
        }
      });
    }

    function handleOutsideClick(e) {
      const sheet = overlay.querySelector('.sheet');
      if (!sheet.contains(e.target)) {
        closeOverlayFn();
      }
    }

    fabButton.addEventListener('click', openOverlay);
    closeOverlayBtn.addEventListener('click', closeOverlayFn);

    function resetCubes() {
      cubes.forEach(({ body, initial }) => {
        body.position.set(initial.x, initial.y, initial.z);
        body.velocity.set(0, 0, 0);
        body.angularVelocity.set(0, 0, 0);
        body.quaternion.set(0, 0, 0, 1);
        body.wakeUp();
      });
      bounceAndSettle();
    }

    document.getElementById('resetBtn').addEventListener('click', () => {
      resetCubes();
      closeOverlayFn();
    });
    document.getElementById('resetTopBtn').addEventListener('click', resetCubes);

    document.addEventListener('keydown', (event) => {
      if (event.key === ' ') {
        event.preventDefault();
        resetCubes();
      }
    });

    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const isFinePointer = window.matchMedia('(pointer: fine)').matches;
    const shouldRunCursor = isFinePointer && !prefersReducedMotion && !isMobileDevice;

    if (shouldRunCursor) {
      (() => {
        const TAIL_LENGTH = window.innerWidth < 800 ? 6 : 14;
        const host = document.getElementById('cursor');
        if (!host) return;
        for (let i = 0; i < TAIL_LENGTH; i++) {
          const d = document.createElement('div');
          d.className = 'cursor-circle';
          host.appendChild(d);
        }
        const circles = host.querySelectorAll('.cursor-circle');
        let mouseX = window.innerWidth / 2, mouseY = window.innerHeight / 2;
        const history = Array(TAIL_LENGTH).fill(0).map(() => ({ x: mouseX, y: mouseY }));
        window.addEventListener('pointermove', e => {
          mouseX = e.clientX;
          mouseY = e.clientY;
        }, { passive: true });
        function tick() {
          history.shift();
          history.push({ x: mouseX, y: mouseY });
          circles.forEach((c, i) => {
            const cur = history[i];
            const next = history[i + 1] || history[TAIL_LENGTH - 1];
            cur.x += (next.x - cur.x) * 0.35;
            cur.y += (next.y - cur.y) * 0.35;
            const s = Math.max(0.22, i / TAIL_LENGTH);
            c.style.transform = `translate(calc(${cur.x}px - 50%), calc(${cur.y}px - 50%)) scale(${s})`;
          });
          requestAnimationFrame(tick);
        }
        tick();
      })();
    }

    document.getElementById('cvBtn').addEventListener('click', () => window.location.href = 'https://intoview.pro/cv');
    document.getElementById('noteBtn').addEventListener('click', () => window.location.href = 'https://intoview.pro/note');
    document.getElementById('kanbanBtn').addEventListener('click', () => window.location.href = 'https://intoview.pro/kanban');
    document.getElementById('melodyBtn').addEventListener('click', () => window.location.href = 'https://intoview.pro/melody');
    document.getElementById('emdashBtn').addEventListener('click', () => window.location.href = 'https://emdash.click/');
    document.getElementById('portfolioBtn').addEventListener('click', () => window.location.href = 'https://zackgort.com');

    const contextMenu = document.getElementById('contextMenu');

    document.addEventListener('contextmenu', (e) => {
      if (isMobileDevice) return; 
      e.preventDefault();
      contextMenu.style.left = `${e.pageX}px`;
      contextMenu.style.top = `${e.pageY}px`;
      contextMenu.style.display = 'block';
    });

    document.addEventListener('click', (e) => {
      if (!contextMenu.contains(e.target)) {
        contextMenu.style.display = 'none';
      }
    });

    document.getElementById('contextReset').addEventListener('click', () => {
      resetCubes();
      contextMenu.style.display = 'none';
    });
    
    document.getElementById('contextCopyResume').addEventListener('click', () => {
      navigator.clipboard.writeText('https://intoview.pro/cv').then(() => alert('Link copied!'));
      contextMenu.style.display = 'none';
    });

    document.getElementById('contextCopyPortfolio').addEventListener('click', () => {
      navigator.clipboard.writeText('https://zackgort.com').then(() => alert('Link copied!'));
      contextMenu.style.display = 'none';
    });
  </script>
</body>
</html>
