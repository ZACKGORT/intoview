<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>intoview • note — single file</title>
<style>
  :root{
    --bg:#0E0E10; --surface1:#151518; --surface2:#1A1A1F; --border:#2A2A30;
    --fg:#EDEDEF; --fg-2:#B8B8BE; --fg-3:#8C8C92; --inverse:#0B1211;
    --accent:#59D2C8; --accent-600:#3FB9AF; --accent-700:#2EA59B; --accent-400:#79E1D9;
    --success:#3CCB7A; --warning:#E7B04A; --danger:#F16565;
    --radius-sm:8px; --radius-md:12px; --radius-lg:16px; --radius-xl:24px;
    --shadow-e1:0 1px 0 rgba(255,255,255,.02), 0 1px 2px rgba(0,0,0,.30);
    --shadow-e2:0 4px 12px rgba(0,0,0,.35);
    --ring-focus:0 0 0 2px rgba(89,210,200,.55);
  }
  html,body{background:var(--bg);color:var(--fg);margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,Apple Color Emoji,Segoe UI Emoji}
  *,*:before,*:after{box-sizing:border-box}
  .wrap{max-width:720px;margin:0 auto;padding:16px 16px 28px}
  .muted{color:var(--fg-2)}
  .card{background:var(--surface1);border:1px solid var(--border);border-radius:16px;box-shadow:var(--shadow-e1);padding:12px}
  .row{display:flex;gap:8px;align-items:center}
  .row.wrap{flex-wrap:wrap}
  .grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  .btn{display:inline-flex;align-items:center;justify-content:center;height:44px;padding:0 16px;border-radius:12px;border:1px solid transparent;background:var(--accent);color:var(--inverse);cursor:pointer;transition:.15s ease-in-out}
  .btn:hover{filter:brightness(1.05)}
  .btn:active{filter:brightness(.95)}
  .btn.sec{background:var(--surface1);border-color:var(--border);color:var(--fg)}
  .btn.sm{height:36px;padding:0 12px;font-size:14px}
  .btn.block{width:100%}
  .focus{outline:none;box-shadow:var(--ring-focus)}
  textarea,input{font:inherit;color:inherit}
  textarea.caption{width:100%;min-height:84px;background:var(--surface1);border:1px solid var(--border);border-radius:12px;padding:12px;resize:vertical}
  .vf{position:relative;aspect-ratio:4/3;width:100%;overflow:hidden;border-radius:12px;border:1px solid var(--border);background:#000}
  video{width:100%;height:100%;object-fit:cover;display:block}
  .mask{position:absolute;inset:0;pointer-events:none}
  .mask .shade{position:absolute;inset:0;outline:1200px solid rgba(0,0,0,.35)}
  .mask .grid{position:absolute;inset:0;display:grid;grid-template-columns:1fr 1fr 1fr;grid-template-rows:1fr 1fr 1fr;opacity:.30}
  .mask .grid > div{border-right:1px solid var(--border)}
  .mask .grid > div:nth-child(3n){border-right:0}
  .mask .grid:after{content:"";grid-column:1/-1;border-top:1px solid var(--border);align-self:center}
  .level{position:absolute;left:12px;right:12px;bottom:12px;display:flex;justify-content:center}
  .export-surface{background:var(--surface2);border:1px solid var(--border);border-radius:12px;aspect-ratio:4/3;width:100%;display:flex;align-items:center;justify-content:center;overflow:hidden}
  .foot{height:24px}
  @media (prefers-reduced-motion: reduce){
    *{animation:none!important;transition:none!important}
  }
</style>
</head>
<body>
  <main class="wrap">
    <div class="muted" style="margin-bottom:8px;font-size:14px">intoview • note</div>

    <section class="card">
      <div class="vf" id="vf">
        <video id="video" playsinline muted></video>
        <div class="mask">
          <div class="shade"></div>
          <div class="grid">
            <div></div><div></div><div></div>
            <div></div><div></div><div></div>
            <div></div><div></div><div></div>
          </div>
        </div>
        <div class="level"><canvas id="level" width="240" height="56" style="width:240px;height:56px"></canvas></div>
      </div>

      <div class="grid3" style="margin-top:12px">
        <button class="btn sm sec" id="r169">16:9</button>
        <button class="btn sm" id="r43">4:3</button>
        <button class="btn sm sec" id="r11">1:1</button>
      </div>

      <div class="row" style="margin-top:8px">
        <button class="btn block" id="capture">Capture</button>
      </div>

      <canvas id="raw" style="display:none"></canvas>
    </section>

    <section class="card" style="margin-top:12px">
      <div class="row" style="justify-content:space-between;margin-bottom:8px">
        <div class="muted" style="font-size:14px">Caption</div>
        <div class="row">
          <button class="btn sm" id="posBL">BL</button>
          <button class="btn sm sec" id="posBC">BC</button>
          <button class="btn sm sec" id="posBR">BR</button>
        </div>
      </div>
      <textarea id="caption" class="caption" placeholder="Say something…">A quick visual note</textarea>
    </section>

    <section style="margin-top:12px">
      <div class="card" style="padding:12px">
        <div class="row" style="justify-content:space-between;margin-bottom:8px">
          <div class="muted" style="font-size:14px">Export • <span id="expRatioTxt">4:3</span></div>
          <button class="btn sm" id="exportBtn">Export PNG</button>
        </div>
        <div class="export-surface">
          <canvas id="exportCanvas" style="width:100%;height:auto;max-height:72vh"></canvas>
        </div>
      </div>
    </section>

    <div class="foot"></div>
  </main>

<script>
(function(){
  const $ = (sel)=>document.querySelector(sel);
  const $$ = (sel)=>document.querySelectorAll(sel);
  const video = $("#video");
  const raw = $("#raw");
  const exportCanvas = $("#exportCanvas");
  const expRatioTxt = $("#expRatioTxt");
  const captionEl = $("#caption");
  const r169=$("#r169"), r43=$("#r43"), r11=$("#r11");
  const posBL=$("#posBL"), posBC=$("#posBC"), posBR=$("#posBR");
  const captureBtn=$("#capture"), exportBtn=$("#exportBtn");
  const levelCanvas = $("#level");

  let ratio = "4:3";            // '16:9' | '4:3' | '1:1'
  let captionPos = "BL";        // 'BL'|'BC'|'BR'
  let lastShot = null;          // HTMLCanvasElement
  let meta = { focal:"26mm", iso:"ISO 200" };

  // --- Camera init ---
  async function initCamera(){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false });
      video.srcObject = stream;
      await video.play();
    }catch(err){
      console.warn("Camera not available/denied", err);
    }
  }
  initCamera();

  // --- Ratio buttons ---
  function setRatio(r){
    ratio = r;
    r169.classList.toggle("sec", r!=="16:9");
    r43.classList.toggle("sec", r!=="4:3");
    r11.classList.toggle("sec", r!=="1:1");
    expRatioTxt.textContent = r;
  }
  r169.addEventListener("click", ()=>setRatio("16:9"));
  r43.addEventListener("click", ()=>setRatio("4:3"));
  r11.addEventListener("click", ()=>setRatio("1:1"));
  setRatio("4:3");

  // --- Caption pos ---
  function setPos(p){
    captionPos = p;
    posBL.classList.toggle("sec", p!=="BL");
    posBC.classList.toggle("sec", p!=="BC");
    posBR.classList.toggle("sec", p!=="BR");
  }
  posBL.addEventListener("click", ()=>setPos("BL"));
  posBC.addEventListener("click", ()=>setPos("BC"));
  posBR.addEventListener("click", ()=>setPos("BR"));
  setPos("BL");

  // --- Capture ---
  function capture(){
    if(!video.videoWidth) return;
    const vw = video.videoWidth, vh = video.videoHeight;
    const [rw, rh] = ratio.split(":").map(Number);
    const targ = rw/rh;
    let sw = vw, sh = Math.round(vw / targ);
    if (sh > vh){ sh = vh; sw = Math.round(vh * targ); }
    const sx = Math.floor((vw - sw)/2);
    const sy = Math.floor((vh - sh)/2);

    raw.width = sw; raw.height = sh;
    const ctx = raw.getContext("2d");
    ctx.drawImage(video, sx, sy, sw, sh, 0, 0, sw, sh);

    // copy to immutable canvas
    const shot = document.createElement("canvas");
    shot.width = sw; shot.height = sh;
    shot.getContext("2d").drawImage(raw,0,0);
    lastShot = shot;
    drawExport(); // refresh preview
  }
  captureBtn.addEventListener("click", capture);

  // --- Export drawing ---
  function roundRect(ctx, x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }
  function wrapText(ctx, text, x, y, maxWidth, lineHeight){
    const words = String(text||"").split(" ");
    let line = ""; const lines = [];
    for(let i=0;i<words.length;i++){
      const test = line + words[i] + " ";
      if (ctx.measureText(test).width > maxWidth && i>0){
        lines.push(line.trim()); line = words[i] + " ";
      } else line = test;
    }
    lines.push(line.trim());
    for(let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], x, y - (lines.length-1-i)*lineHeight);
    }
  }

  function drawExport(){
    const ratioForCanvas = (ratio==="1:1") ? [1,1] : [4,3]; // preview surface stays 4:3 (or 1:1)
    const size = (ratio==="1:1") ? {w:1200,h:1200} : {w:1200,h:900};
    exportCanvas.width = size.w; exportCanvas.height = size.h;
    const ctx = exportCanvas.getContext("2d");

    // bg
    ctx.fillStyle = "#0E0E10"; ctx.fillRect(0,0,size.w,size.h);

    const inset = 24, metaH = 56;
    const imgArea = { x: inset, y: inset, w: size.w - inset*2, h: size.h - inset*2 - metaH };

    if (lastShot){
      const iw = lastShot.width, ih = lastShot.height;
      const scale = Math.max(imgArea.w/iw, imgArea.h/ih);
      const dw = iw*scale, dh = ih*scale;
      const dx = imgArea.x + (imgArea.w - dw)/2;
      const dy = imgArea.y + (imgArea.h - dh)/2;
      ctx.save(); roundRect(ctx, imgArea.x, imgArea.y, imgArea.w, imgArea.h, 20); ctx.clip();
      ctx.drawImage(lastShot, dx, dy, dw, dh);
      ctx.restore();
    }

    // caption
    ctx.font = "600 28px Inter, system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillStyle = "#EDEDEF";
    ctx.textBaseline = "alphabetic";
    const pad = 24;
    let cx = imgArea.x + pad;
    let cy = imgArea.y + imgArea.h - pad;
    ctx.textAlign = "left";
    if (captionPos === "BC"){ cx = imgArea.x + imgArea.w/2; ctx.textAlign = "center"; }
    if (captionPos === "BR"){ cx = imgArea.x + imgArea.w - pad; ctx.textAlign = "right"; }
    wrapText(ctx, captionEl.value, cx, cy, imgArea.w - pad*2, 34);

    // metadata strip
    const y0 = size.h - metaH - inset;
    ctx.fillStyle = "#151518"; ctx.strokeStyle = "#2A2A30";
    roundRect(ctx, inset, y0, size.w - inset*2, metaH, 12); ctx.fill(); ctx.stroke();

    ctx.font = "500 16px 'JetBrains Mono', ui-monospace, SFMono-Regular, Menlo";
    ctx.fillStyle = "#B8B8BE"; ctx.textAlign = "left";
    ctx.fillText(new Date().toISOString(), inset+20, y0+36);
    ctx.textAlign = "right";
    const rightText = [meta.focal, meta.iso, ratio].filter(Boolean).join("  •  ");
    ctx.fillText(rightText, size.w - inset - 20, y0+36);
  }

  captionEl.addEventListener("input", drawExport);

  // Export button
  exportBtn.addEventListener("click", ()=>{
    // upscale export a bit for quality
    const target = (ratio==="1:1") ? {w:1600,h:1600} : {w:1600,h:1200};
    const c = document.createElement("canvas");
    c.width = target.w; c.height = target.h;
    const ctx = c.getContext("2d");

    // Render using same function but with overridden size constants
    // inline minimal duplicate to respect target size
    const inset = 32, metaH = 56;
    const imgArea = { x: inset, y: inset, w: target.w - inset*2, h: target.h - inset*2 - metaH };

    ctx.fillStyle = "#0E0E10"; ctx.fillRect(0,0,target.w,target.h);
    if (lastShot){
      const iw = lastShot.width, ih = lastShot.height;
      const scale = Math.max(imgArea.w/iw, imgArea.h/ih);
      const dw = iw*scale, dh = ih*scale;
      const dx = imgArea.x + (imgArea.w - dw)/2;
      const dy = imgArea.y + (imgArea.h - dh)/2;
      // rounded image
      ctx.save();
      (function roundRect(ctx,x,y,w,h,r){
        ctx.beginPath(); ctx.moveTo(x+r,y);
        ctx.arcTo(x+w,y,x+w,y+h,r);
        ctx.arcTo(x+w,y+h,x,y+h,r);
        ctx.arcTo(x,y+h,x,y,r);
        ctx.arcTo(x,y,x+w,y,r);
        ctx.closePath();
      })(ctx, imgArea.x, imgArea.y, imgArea.w, imgArea.h, 24);
      ctx.clip();
      ctx.drawImage(lastShot, dx, dy, dw, dh);
      ctx.restore();
    }
    // caption
    ctx.font = "600 32px Inter, system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillStyle = "#EDEDEF";
    ctx.textBaseline = "alphabetic";
    const pad = 28;
    let cx = imgArea.x + pad, cy = imgArea.y + imgArea.h - pad;
    ctx.textAlign = "left";
    if (captionPos === "BC"){ cx = imgArea.x + imgArea.w/2; ctx.textAlign = "center"; }
    if (captionPos === "BR"){ cx = imgArea.x + imgArea.w - pad; ctx.textAlign = "right"; }
    (function wrapText(ctx,text,x,y,maxWidth,lineHeight){
      const words = String(text||"").split(" ");
      let line = ""; const lines = [];
      for(let i=0;i<words.length;i++){
        const test = line + words[i] + " ";
        if (ctx.measureText(test).width > maxWidth && i>0){ lines.push(line.trim()); line = words[i] + " "; }
        else { line = test; }
      }
      lines.push(line.trim());
      for(let i=0;i<lines.length;i++){ ctx.fillText(lines[i], x, y - (lines.length-1-i)*lineHeight); }
    })(ctx, captionEl.value, cx, cy, imgArea.w - pad*2, 36);

    // meta strip
    const y0 = target.h - metaH - inset;
    ctx.fillStyle = "#151518"; ctx.strokeStyle = "#2A2A30";
    (function roundRect(ctx,x,y,w,h,r){
      ctx.beginPath(); ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    })(ctx, inset, y0, target.w - inset*2, metaH, 12);
    ctx.fill(); ctx.stroke();

    ctx.font = "500 18px 'JetBrains Mono', ui-monospace, SFMono-Regular, Menlo";
    ctx.fillStyle = "#B8B8BE"; ctx.textAlign = "left";
    ctx.fillText(new Date().toISOString(), inset+20, y0+36);
    ctx.textAlign = "right";
    const rightText = [meta.focal, meta.iso, ratio].filter(Boolean).join("  •  ");
    ctx.fillText(rightText, target.w - inset - 20, y0+36);

    c.toBlob((blob)=>{
      if(!blob){ return; }
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = `intoview_${ratio.replace(":","-")}_${Date.now()}.png`;
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }, "image/png", 0.92);
  });

  // --- Liquid level (canvas) ---
  (function(){
    const c = levelCanvas;
    const ctx = c.getContext("2d");
    const w = c.width, h = c.height;
    let roll = 0;

    function roundRect(ctx,x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }
    function clipRoundRect(ctx,x,y,w,h,r){ roundRect(ctx,x,y,w,h,r); ctx.clip(); }

    function draw(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      c.width = 240*dpr; c.height = 56*dpr; ctx.setTransform(dpr,0,0,dpr,0,0);
      ctx.clearRect(0,0,240,56);

      const r=16;
      const styles = getComputedStyle(document.documentElement);
      const surface2 = styles.getPropertyValue('--surface2').trim() || '#1A1A1F';
      const border = styles.getPropertyValue('--border').trim() || '#2A2A30';
      const accent = styles.getPropertyValue('--accent').trim() || '#59D2C8';

      ctx.fillStyle = surface2; ctx.strokeStyle = border; ctx.lineWidth = 1.5;
      roundRect(ctx, .5,.5, 239, 55, r); ctx.fill(); ctx.stroke();

      const angle = -roll * Math.PI/180;
      const mid = 56*0.55;

      ctx.save();
      clipRoundRect(ctx, 1,1, 238, 54, r-2);

      ctx.translate(240/2, mid);
      ctx.rotate(angle);
      ctx.fillStyle = accent; ctx.globalAlpha = .9;
      ctx.fillRect(-240, 0, 480, 56);
      ctx.globalAlpha = 1;

      const grd = ctx.createLinearGradient(-240, -56, 240, 56);
      grd.addColorStop(0, 'rgba(255,255,255,0.10)');
      grd.addColorStop(1, 'rgba(255,255,255,0.00)');
      ctx.fillStyle = grd;
      ctx.fillRect(-240, -56, 480, 112);

      ctx.restore();

      // bubble
      const bubbleR = 8;
      const bubbleX = 240/2 + ((45 - (roll+45)) / 90) * 80;
      const bubbleY = mid - 4;
      ctx.beginPath();
      ctx.arc(bubbleX, bubbleY, bubbleR, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.fill();
    }

    function setRoll(val){ roll = Math.max(-45, Math.min(45, val)); draw(); }

    function onOrient(e){
      setRoll(e.gamma || 0);
    }
    function onMouse(e){
      const pct = (e.clientX / innerWidth) * 2 - 1;
      setRoll(pct * 30);
    }

    if ('DeviceOrientationEvent' in window){
      window.addEventListener('deviceorientation', onOrient);
    } else {
      window.addEventListener('mousemove', onMouse);
    }
    draw();
  })();

  // Draw preview on load and when caption changes
  window.addEventListener("load", drawExport);
})();
</script>
</body>
</html>
