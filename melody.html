<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Fullscreen Piano — Yamaha-ish (MIDI 27–78)</title>
<style>
  :root{
    --bg:#0b0b0b;
    --panel:#121212;
    --fg:#e9e9e9;
    --muted:#a8a8a8;
    --accent:#4ee0b5;

    --gap: clamp(4px, 0.6vw, 10px);

    /* Keyboard sizing */
    --kb-h: clamp(240px, 68vh, 78vh);
    --white-w: 48px;                  /* JS sets exact value to fit width */
    --white-r: 10px;
    --black-w: calc(var(--white-w) * 0.56); /* Yamaha-ish width */
    --black-h: calc(var(--kb-h) * 0.62);
    --black-r: 8px;

    /* Fine-tune where each black sits between its two whites (0..1) */
    --pos-cs: .60;  /* C# between C–D  */
    --pos-ds: .64;  /* D# between D–E  */
    --pos-fs: .60;  /* F# between F–G  */
    --pos-gs: .58;  /* G# between G–A  */
    --pos-as: .62;  /* A# between A–B  */
  }

  *{box-sizing:border-box}
  html, body { height:100% }
  body{
    margin:0; background:var(--bg); color:var(--fg);
    font:14px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    display:grid; grid-template-rows:auto 1fr auto; gap:var(--gap);
    padding: clamp(8px, 2vw, 16px);
  }

  header, footer, .panel{
    background:var(--panel);
    border:1px solid rgb(255 255 255 / .08);
    border-radius:12px;
    box-shadow:0 8px 28px rgb(0 0 0 / .35);
  }

  header{
    display:flex; align-items:center; justify-content:space-between; gap:12px;
    padding:10px 12px;
  }
  .title{display:flex; align-items:center; gap:10px; font-weight:700}
  .title small{color:var(--muted); font-weight:600}

  .controls{display:flex; align-items:center; gap:10px; flex-wrap:wrap}
  .controls label{color:var(--muted); font-weight:600}
  .controls input[type="range"]{width:140px; accent-color:var(--accent)}
  .btn{
    display:inline-grid; place-items:center; padding:8px 10px; border-radius:10px; cursor:pointer; user-select:none;
    border:1px solid rgb(255 255 255 / .12);
    background:rgb(255 255 255 / .06); color:var(--fg);
    transition:transform .05s ease, background .2s ease, border-color .2s ease;
  }
  .btn:hover{ background:rgb(255 255 255 / .12); }
  .btn:active{ transform:translateY(1px); }

  /* ===== Keyboard ===== */
  .stage{
    min-height:0; display:grid; grid-template-rows: var(--kb-h) minmax(160px, 1fr); gap:var(--gap);
  }

  .keyboard{
    position:relative;
    height:var(--kb-h);
    border:1px solid rgb(255 255 255 / .08);
    border-radius:12px;
    background:
      radial-gradient(1200px 60% at 50% 0%, rgb(255 255 255 / .05), transparent 60%),
      linear-gradient(180deg, rgb(255 255 255 / .03), transparent);
    overflow:hidden;
  }

  /* White key row (flexes to fill width exactly) */
  .whites{
    position:absolute; inset: clamp(6px, 1.2vh, 12px);
    display:flex; align-items:end; justify-content:stretch; gap:var(--gap);
  }
  .white{
    width:var(--white-w); height:100%;
    border-radius:var(--white-r); background:linear-gradient(#fbfbfb, #f2f2f2);
    border:1px solid #e2e2e2; color:#222;
    box-shadow:
      inset 0 -36px 40px -12px rgb(0 0 0 / .08),
      0 10px 16px rgb(0 0 0 / .35);
    position:relative; display:grid; grid-template-rows: 1fr auto;
    overflow:clip; cursor:pointer;
    transition:transform .03s ease, box-shadow .12s ease, filter .12s ease;
  }
  .white:active, .white.playing{
    transform:translateY(1px);
    box-shadow:
      inset 0 -10px 18px -6px rgb(0 0 0 / .16),
      0 6px 12px rgb(0 0 0 / .45),
      0 0 0 3px var(--accent) inset;
    filter:brightness(0.98);
  }
  .wlabel{
    font: 600 12px/1 ui-monospace, Menlo, Consolas, monospace;
    color:#333; background:#f6f6f6; border-top:1px solid #e8e8e8;
    padding:6px 8px; display:flex; align-items:center; justify-content:center; gap:8px;
  }
  .wlabel small{color:#666}

  /* Black keys locked to top (absolute over whites) */
  .black{
    position:absolute;
    top: clamp(6px, 1.2vh, 12px);
    width:var(--black-w);
    height:var(--black-h);
    border-radius: var(--black-r);
    background: linear-gradient(#3a3a3a, #1b1b1b);
    border:1px solid #101010;
    box-shadow:
      inset 0 -20px 20px -6px rgb(0 0 0 / .55),
      0 12px 20px rgb(0 0 0 / .6);
    z-index:3;
    cursor:pointer;
    display:block;
    transition:transform .03s ease, box-shadow .12s ease, filter .12s ease;
  }
  .black:active, .black.playing{
    transform:translateY(1px);
    box-shadow:
      inset 0 -8px 16px -6px rgb(0 0 0 / .75),
      0 6px 12px rgb(0 0 0 / .7),
      0 0 0 3px var(--accent) inset;
    filter:brightness(1.02);
  }

  /* ===== 3-note “Yamaha memory” faded highlights ===== */
  .white.mem0, .black.mem0{ box-shadow: 0 0 0 3px rgb(78 224 181 / .65) inset, 0 0 18px rgb(78 224 181 / .35); }
  .white.mem1, .black.mem1{ box-shadow: 0 0 0 3px rgb(78 224 181 / .35) inset, 0 0 14px rgb(78 224 181 / .25); }
  .white.mem2, .black.mem2{ box-shadow: 0 0 0 3px rgb(78 224 181 / .18) inset, 0 0 10px rgb(78 224 181 / .15); }

  /* ===== Log ===== */
  .panel{ display:grid; grid-template-rows:auto 1fr; }
  .panel .head{ display:flex; align-items:center; gap:10px; padding:10px 12px; border-bottom:1px solid rgb(255 255 255 / .06); }
  .panel .head .meta{ color:var(--muted); font-weight:600 }
  .log{
    padding:10px 12px; overflow:auto; white-space:pre-wrap;
    font:12px/1.35 ui-monospace, Menlo, Consolas, monospace;
  }

  footer{ padding:8px 10px; display:flex; align-items:center; justify-content:space-between; gap:10px; color:var(--muted); }
  @media (max-width:560px){ footer{ flex-direction:column; align-items:flex-start } }
</style>
</head>
<body>

<header>
  <div class="title">
    <span>Fullscreen Piano (Yamaha-ish)</span>
    <small id="rangeLabel"></small>
  </div>
  <div class="controls">
    <label for="volSlider">Vol</label>
    <input id="volSlider" type="range" min="0" max="100" value="60" />
    <button class="btn" id="btnClear">Clear Log</button>
    <button class="btn" id="btnCopy">Copy</button>
  </div>
</header>

<main class="stage">
  <section class="keyboard" aria-label="Piano keyboard">
    <div id="whites" class="whites"></div>
    <!-- black keys injected absolutely on top -->
  </section>

  <section class="panel" aria-label="Captured notes">
    <div class="head">
      <strong>Key Log</strong>
      <span class="meta" id="count">(0)</span>
    </div>
    <div class="log" id="log" aria-live="polite"></div>
  </section>
</main>

<footer>
  <small>Keys flex to fit; keyboard fills most of the viewport. Last 3 notes stay softly highlighted.</small>
  <small>Synth: same WebAudio voice as intoview.</small>
</footer>

<script>
/* =======================
   Range & helpers
   ======================= */
const START_MIDI = 27;  // inclusive
const END_MIDI   = 78;  // inclusive

const WHITE_PCS = new Set([0,2,4,5,7,9,11]);
const BLACK_PCS = new Set([1,3,6,8,10]);

const css = ()=>getComputedStyle(document.documentElement);
const num = (v, fallback)=>Number.parseFloat(String(v)) || fallback;
const clamp = (x, a, b)=>Math.min(b, Math.max(a, x));
const lerp = (a,b,t)=>a+(b-a)*t;
const rndh = x => Math.round(x*2)/2; // snap to half px

function midiToName(m){
  const pcs = ['c','c#','d','d#','e','f','f#','g','g#','a','a#','b'];
  const pc  = pcs[((m % 12)+12)%12];
  const oct = Math.floor(m/12)-1;
  return (pc + oct).toUpperCase();
}
function midiToFreq(m){ return 440 * Math.pow(2, (m-69)/12); }

/* =======================
   Build exact real-piano set for MIDI 27–78
   ======================= */
const whites = []; // {midi, name, wIndex}
const blacks = []; // {midi, name, leftW, rightW, frac}

let wIndex = 0;
for (let m = START_MIDI; m <= END_MIDI; m++){
  const pc = ((m % 12)+12)%12;
  if (WHITE_PCS.has(pc)) whites.push({midi:m, name:midiToName(m), wIndex: wIndex++});
}
function nearestWhiteIndexBelow(m){
  for (let mm = m-1; mm >= START_MIDI; mm--){
    if (WHITE_PCS.has(((mm%12)+12)%12)){
      const w = whites.find(x => x.midi === mm);
      if (w) return w.wIndex;
    }
  }
  return whites[0]?.wIndex ?? 0;
}
function nearestWhiteIndexAbove(m){
  for (let mm = m+1; mm <= END_MIDI; mm++){
    if (WHITE_PCS.has(((mm%12)+12)%12)){
      const w = whites.find(x => x.midi === mm);
      if (w) return w.wIndex;
    }
  }
  return whites.at(-1)?.wIndex ?? 0;
}
function pcFrac(pc){
  const s = css();
  switch(pc){
    case 1:  return num(s.getPropertyValue('--pos-cs'), .60);
    case 3:  return num(s.getPropertyValue('--pos-ds'), .64);
    case 6:  return num(s.getPropertyValue('--pos-fs'), .60);
    case 8:  return num(s.getPropertyValue('--pos-gs'), .58);
    case 10: return num(s.getPropertyValue('--pos-as'), .62);
    default: return .60;
  }
}
for (let m = START_MIDI; m <= END_MIDI; m++){
  const pc = ((m % 12)+12)%12;
  if (!BLACK_PCS.has(pc)) continue;
  const leftW  = nearestWhiteIndexBelow(m);
  const rightW = nearestWhiteIndexAbove(m);
  const frac   = pcFrac(pc);
  blacks.push({midi:m, name:midiToName(m), leftW, rightW, frac});
}

/* =======================
   DOM & labels
   ======================= */
const whitesEl  = document.getElementById('whites');
const keyboard  = document.querySelector('.keyboard');
const logEl     = document.getElementById('log');
const countEl   = document.getElementById('count');
document.getElementById('rangeLabel').textContent =
  `${midiToName(START_MIDI)} → ${midiToName(END_MIDI)} (real 88-key mapping)`;

/* =======================
   WebAudio SYNTH (from intoview)
   ======================= */
const POLY_MAX = 10;
const NOTE_COOLDOWN_MS = 90;
const lastTrigByNote = new Map();

let AC=null, master=null; let pianoGroup=null; const activeVoices=new Set(); let synthReady=false;
function ensureAudio(){
  if(!AC){
    const C = window.AudioContext || window.webkitAudioContext;
    AC = new C();

    master = AC.createGain();
    const vs = document.getElementById('volSlider');
    master.gain.value = (parseInt(vs.value,10)||60)/100;

    const comp = AC.createDynamicsCompressor();
    comp.threshold.setValueAtTime(-22, AC.currentTime);
    comp.knee.setValueAtTime(24, AC.currentTime);
    comp.ratio.setValueAtTime(4, AC.currentTime);
    comp.attack.setValueAtTime(0.003, AC.currentTime);
    comp.release.setValueAtTime(0.25, AC.currentTime);

    master.connect(comp);
    comp.connect(AC.destination);

    pianoGroup = AC.createGain();
    pianoGroup.gain.value = 1.0;
    pianoGroup.connect(master);

    buildReverb();
  }
  if (AC.state === 'suspended') AC.resume();
}
function buildReverb(){
  const convolver=AC.createConvolver();
  const rate=AC.sampleRate, length=Math.floor(rate*0.9);
  const impulse=AC.createBuffer(2,length,rate);
  for(let ch=0; ch<2; ch++){
    const d=impulse.getChannelData(ch);
    for(let i=0;i<length;i++){
      const t=i/length;
      d[i]=(Math.random()*2-1)*Math.pow(1-t, 2.6)*0.4;
    }
    impulse.getChannelData(ch).set(d);
  }
  convolver.buffer=impulse;
  const dry=AC.createGain(); dry.gain.value=0.84;
  const wet=AC.createGain(); wet.gain.value=0.26;
  pianoGroup.disconnect();
  pianoGroup.connect(dry).connect(master);
  pianoGroup.connect(wet).connect(convolver).connect(master);
}
function makeShaper(k=1.35){
  const n=1024, curve=new Float32Array(n);
  for(let i=0;i<n;i++){ const x=i/(n-1)*2-1; curve[i]=Math.tanh(k*x); }
  const sh=AC.createWaveShaper(); sh.curve=curve; sh.oversample='2x';
  return sh;
}
function createPianoVoice(freq, vel){
  const now=AC.currentTime;
  const voiceGain=AC.createGain(); voiceGain.gain.value=0.0001;
  const shaper=makeShaper(1.35);
  const lp=AC.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=Math.min(12000, freq*12); lp.Q.value=0.6;
  const ap=AC.createBiquadFilter(); ap.type='allpass'; ap.frequency.value=freq*2; ap.Q.value=0.6;

  const nbuf=AC.createBuffer(1, Math.floor(AC.sampleRate*0.02), AC.sampleRate);
  const nd=nbuf.getChannelData(0);
  for(let i=0;i<nd.length;i++){ nd[i]=(Math.random()*2-1)*Math.pow(1-i/nd.length,2.0); }
  const nsrc=AC.createBufferSource(); nsrc.buffer=nbuf;
  const ng=AC.createGain(); ng.gain.value=0.0;

  const partials=[
    {ratio:1.0,  amp:0.95, decay:1.0},
    {ratio:2.01, amp:0.38, decay:0.75},
    {ratio:3.02, amp:0.18, decay:0.55},
    {ratio:4.05, amp:0.10, decay:0.42},
    {ratio:5.07, amp:0.06, decay:0.36},
  ];
  const oscNodes=[];
  for(const p of partials){
    const o=AC.createOscillator(); o.type='sine'; o.frequency.value=freq*p.ratio;
    const g=AC.createGain(); g.gain.value=0.0;
    const a=0.003 + 0.002*(1/p.ratio);
    const d=0.04 + 0.03*(1/p.ratio);
    const peak=p.amp*vel;
    g.gain.setValueAtTime(0.0001, now);
    g.gain.linearRampToValueAtTime(peak, now+a);
    g.gain.linearRampToValueAtTime(peak*0.55, now+a+d);
    g.gain.setTargetAtTime(0.0001, now+a+d, p.decay);
    o.connect(g).connect(voiceGain);
    o.start(now);
    oscNodes.push({o,g});
  }
  ng.gain.setValueAtTime(0.0001, now);
  ng.gain.linearRampToValueAtTime(0.25*vel, now+0.002);
  ng.gain.linearRampToValueAtTime(0.0001, now+0.025);
  nsrc.connect(ng).connect(voiceGain);
  nsrc.start(now);

  const atk=0.002, peak=0.85*vel;
  voiceGain.gain.setValueAtTime(0.0001, now);
  voiceGain.gain.linearRampToValueAtTime(peak, now+atk);

  voiceGain.connect(ap).connect(lp).connect(shaper).connect(pianoGroup);

  const stop=(releaseTime=0.8)=>{
    const t=AC.currentTime;
    voiceGain.gain.cancelScheduledValues(t);
    voiceGain.gain.setTargetAtTime(0.0001, t, Math.max(0.08, releaseTime/4));
    setTimeout(()=>{ try{ oscNodes.forEach(({o})=>o.stop()); nsrc.stop(); }catch{} }, Math.ceil(releaseTime*1000)+100);
  };
  return { stop };
}
function playPiano(note, {hold=false, vel=.95} = {}){
  ensureAudio();
  const key = typeof note === 'number' ? note : String(note).toLowerCase();
  const nowMs = performance.now();
  const last = lastTrigByNote.get(key) || 0;
  if (nowMs - last < NOTE_COOLDOWN_MS) return () => {};
  lastTrigByNote.set(key, nowMs);

  if (activeVoices.size >= POLY_MAX) {
    const oldest = activeVoices.values().next().value;
    try { oldest?.stop(0.2); } catch {}
    activeVoices.delete(oldest);
  }

  const midi = typeof note === 'number' ? note : 60;
  const f = midiToFreq(midi);
  const v = createPianoVoice(f, vel);
  activeVoices.add(v);
  return () => { v.stop(hold ? 1.2 : 0.8); activeVoices.delete(v); };
}
document.getElementById('volSlider').addEventListener('input', (e)=>{
  ensureAudio();
  const v = (+e.target.value || 0)/100;
  master.gain.setTargetAtTime(v, AC.currentTime, 0.01);
});
document.addEventListener('pointerdown',()=>{ if(!synthReady){ ensureAudio(); synthReady=true; } },{once:true, passive:true});
document.addEventListener('keydown',()=>{ if(!synthReady){ ensureAudio(); synthReady=true; } },{once:true});

/* =======================
   Build white keys
   ======================= */
function makeWhiteKey(item){
  const el = document.createElement('button');
  el.className = 'white';
  el.type = 'button';
  el.dataset.midi = String(item.midi);
  el.setAttribute('aria-label', item.name);

  // label
  const lab = document.createElement('div');
  lab.className = 'wlabel';
  const n = item.name;
  const pc = n.slice(0, n.length-1), oct = n.slice(-1);
  lab.innerHTML = `<strong>${pc}</strong><small>${oct}</small>`;

  el.appendChild(document.createElement('div')); // filler
  el.appendChild(lab);

  el.addEventListener('pointerdown', (e)=>{ e.preventDefault(); triggerKey(item.midi, el); });
  el.addEventListener('pointerup',   ()=> el.classList.remove('playing'));
  el.addEventListener('pointerleave',()=> el.classList.remove('playing'));
  return el;
}
const whitesElList = [];
whites.forEach(w => { const b = makeWhiteKey(w); whitesElList.push(b); whitesEl.appendChild(b); });

/* =======================
   Build black keys (absolute, locked to top)
   ======================= */
const blackEls = [];
function createBlackKey(B){
  const el = document.createElement('button');
  el.className = 'black';
  el.type = 'button';
  el.dataset.midi = String(B.midi);
  el.setAttribute('aria-label', B.name);
  el.addEventListener('pointerdown', (e)=>{ e.preventDefault(); triggerKey(B.midi, el); });
  el.addEventListener('pointerup',   ()=> el.classList.remove('playing'));
  el.addEventListener('pointerleave',()=> el.classList.remove('playing'));
  keyboard.appendChild(el);
  return el;
}
blacks.forEach(b => blackEls.push(createBlackKey(b)));

/* =======================
   Responsive width + realistic black placement
   ======================= */
function layout(){
  // 1) Compute white width so the row fills, then set CSS vars
  const inset = Math.max(6, Math.min(12, innerHeight * 0.012));
  const kbRect = keyboard.getBoundingClientRect();
  const innerW = kbRect.width - inset*2;
  const whiteCount = whites.length;

  const gapCss = getComputedStyle(whitesEl).gap;
  const gap = num(gapCss, Math.max(3, Math.min(12, innerWidth * 0.006)));

  const whiteW = (innerW - gap * (whiteCount - 1)) / whiteCount;
  document.documentElement.style.setProperty('--white-w', whiteW + 'px');
  document.documentElement.style.setProperty('--black-w', (whiteW * 0.56) + 'px');

  whitesEl.style.inset = `${inset}px`;

  // 2) Read live centers of all white keys (after width applied)
  const wRects = whitesElList.map(el => el.getBoundingClientRect());
  const centers = wRects.map(r => (r.left + r.right)/2 - kbRect.left);

  const blackW = whiteW * 0.56;

  // 3) Place each black by lerping between left & right white centers
  blacks.forEach((b, i) => {
    const li = clamp(b.leftW,  0, centers.length-1);
    const ri = clamp(b.rightW, 0, centers.length-1);
    const cL = centers[li], cR = centers[ri];
    const c  = lerp(cL, cR, clamp(b.frac, 0, 1));
    const leftPx = rndh(c - blackW/2);
    blackEls[i].style.left = `${leftPx}px`;
  });
}
addEventListener('resize', ()=>{ requestAnimationFrame(layout); }, {passive:true});
addEventListener('orientationchange', ()=>{ setTimeout(layout, 60); }, {passive:true});
requestAnimationFrame(layout);

/* =======================
   Play + LOG + 3-note memory
   ======================= */
const entries = [];
const logElRef = logEl;
const memory = []; // last 3 buttons for faded highlight

function updateMemory(btn){
  document.querySelectorAll('.mem0,.mem1,.mem2').forEach(el=>{
    el.classList.remove('mem0','mem1','mem2');
  });
  if (btn){
    memory.unshift(btn);
    if (memory.length > 3) memory.length = 3;
  }
  memory.forEach((el, idx) => el?.classList.add(`mem${idx}`));
}

function triggerKey(midi, btn){
  btn.classList.add('playing');
  playPiano(midi);
  pushLog(midi);
  updateMemory(btn);
}

function pushLog(midi){
  const name = midiToName(midi);
  const t = new Date();
  entries.push({ t, midi, name });
  const hh=String(t.getHours()).padStart(2,'0');
  const mm=String(t.getMinutes()).padStart(2,'0');
  const ss=String(t.getSeconds()).padStart(2,'0');
  const ms=String(t.getMilliseconds()).padStart(3,'0');
  const line = `[${hh}:${mm}:${ss}.${ms}] ${name} (${midi})`;
  logElRef.textContent += (logElRef.textContent ? '\n' : '') + line;
  countEl.textContent = `(${entries.length})`;
  logElRef.scrollTop = logElRef.scrollHeight;
}

document.getElementById('btnClear').addEventListener('click', ()=>{
  entries.splice(0, entries.length);
  logEl.textContent = '';
  countEl.textContent = '(0)';
});
document.getElementById('btnCopy').addEventListener('click', async ()=>{
  const csv = 'time,midi,name\n' + entries.map(e => `${e.t.toISOString()},${e.midi},${e.name}`).join('\n');
  try{
    await navigator.clipboard.writeText(csv);
    const btn = document.getElementById('btnCopy');
    btn.textContent = 'Copied!';
    setTimeout(()=> btn.textContent = 'Copy', 900);
  }catch{
    const blob = new Blob([csv], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement('a'), {href:url, download:'key-log.csv'});
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  }
});

/* =======================
   Optional: quick QWERTY mapping (left→right)
   ======================= */
const qwertyOrder = [
  '`','1','2','3','4','5','6','7','8','9','0','-','=',
  'q','w','e','r','t','y','u','i','o','p','[',']','\\',
  'a','s','d','f','g','h','j','k','l',';','\'',
  'z','x','c','v','b','n','m',',','.','/'
];
const whiteButtons = [...document.querySelectorAll('.white')];
const blackButtons = [...document.querySelectorAll('.black')];
const keyTargets = [...whiteButtons, ...blackButtons]; // whites first, then blacks
const keyToMidi = new Map();
for (let i=0; i<Math.min(qwertyOrder.length, keyTargets.length); i++){
  keyToMidi.set(qwertyOrder[i], parseInt(keyTargets[i].dataset.midi, 10));
}
document.addEventListener('keydown', (e)=>{
  if (e.repeat) return;
  const k = e.key.toLowerCase();
  const midi = keyToMidi.get(k);
  if (!midi) return;
  e.preventDefault();
  const btn = keyTargets.find(b => +b.dataset.midi === midi);
  if (!btn) return;
  triggerKey(midi, btn);
});
document.addEventListener('keyup', (e)=>{
  const k = e.key.toLowerCase();
  const midi = keyToMidi.get(k);
  if (!midi) return;
  const btn = keyTargets.find(b => +b.dataset.midi === midi);
  btn?.classList.remove('playing');
});
</script>
</body>
</html>
