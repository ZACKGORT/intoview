<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>i n t o v i e w : s t a c k [ N O T E S ]</title>
  <link href="https://fonts.googleapis.com" rel="preconnect" crossorigin>
  <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">
  
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

  <style>
    /* --- CORE STYLING (PRESERVED FROM STACK.html) --- */
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    body { overflow: hidden; font-family: 'Inter', sans-serif; background: #0f1014; color: #fff; }
    #canvas { display: block; width: 100vw; height: 100vh; outline: none; }
    
    :root {
      --bg-color: #0f1014;
      --glass-bg: rgba(255, 255, 255, 0.04);
      --glass-bg-hover: rgba(255, 255, 255, 0.08);
      --glass-bg-bright: rgba(255, 255, 255, 0.12);
      --glass-border: rgba(255, 255, 255, 0.12);
      --accent: #83ff83; /* Neon Green */
      --active: #FF1493; /* Neon Pink */
      --string: #00ffff; /* Neon Cyan for Strings */
      --font-stack: Inter, ui-sans-serif, system-ui;
    }

    /* UI LAYOUT (PRESERVED) */
    .ui-layer { position: fixed; inset: 0; pointer-events: none; z-index: 100; }
    .pointer-events-auto { pointer-events: auto; }

    /* Left Rail - Camera Presets */
    .left-rail {
      position: fixed; top: 50%; left: 24px; transform: translateY(-50%);
      display: flex; flex-direction: column; gap: 8px;
      background: var(--glass-bg); backdrop-filter: blur(8px);
      padding: 6px; border: 1px solid var(--glass-border); border-radius: 8px;
      pointer-events: auto;
    }

    /* Right Rail - Impulse Controls (EXTENDED) */
    .right-rail {
      position: fixed; top: 50%; right: 24px; transform: translateY(-50%);
      display: flex; flex-direction: column; gap: 8px;
      background: var(--glass-bg); backdrop-filter: blur(8px);
      padding: 6px; border: 1px solid var(--glass-border); border-radius: 8px;
      pointer-events: auto;
    }

    button {
      padding: 8px 16px; background: transparent; border: none;
      color: #fff; cursor: pointer; transition: background 0.2s ease;
      display: flex; align-items: center; gap: 8px; border-radius: 4px;
      font-family: var(--font-stack); font-weight: 500; font-size: 14px;
      text-align: left;
    }
    button:hover { background: var(--glass-bg-hover); }
    button.active { background: var(--glass-bg-bright); color: var(--accent); }
    button.mode-active { color: var(--active); border: 1px solid var(--active); }
    button.mode-build { color: var(--string); border: 1px solid var(--string); }

    .emoji { font-size: 1.2em; }
    
    .power-display {
      text-align: center; font-family: 'JetBrains Mono', monospace; font-size: 10px;
      color: rgba(255,255,255,0.5); padding: 4px 0; border-top: 1px solid var(--glass-border);
      margin-top: 4px;
    }
    .power-val { color: var(--accent); font-weight: bold; }

    /* Top Mode Toggle (EXTENDED) */
    .top-bar {
      position: fixed; top: 24px; left: 50%; transform: translateX(-50%);
      background: var(--glass-bg); backdrop-filter: blur(8px);
      padding: 6px; border: 1px solid var(--glass-border); border-radius: 8px;
      display: flex; gap: 8px; pointer-events: auto;
    }

    /* Modal - Editor (EXTENDED) */
    .modal-overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.6); backdrop-filter: blur(4px);
      display: flex; align-items: center; justify-content: center;
      opacity: 0; pointer-events: none; transition: opacity 0.2s; z-index: 200;
    }
    .modal-overlay.open { opacity: 1; pointer-events: auto; }
    
    .modal {
      background: #0f1014; border: 1px solid var(--glass-border);
      padding: 24px; width: 400px; border-radius: 12px;
      box-shadow: 0 20px 50px rgba(0,0,0,0.5);
      transform: scale(0.9); transition: transform 0.2s ease;
      display: flex; flex-direction: column; gap: 12px;
    }
    .modal-overlay.open .modal { transform: scale(1); }
    
    .modal h3 { color: var(--accent); font-size: 14px; text-transform: uppercase; letter-spacing: 0.1em; }
    
    /* --- EXTENDED EDITOR STYLES --- */
    .modal textarea {
      width: 100%; height: 120px; background: rgba(255,255,255,0.05); border: 1px solid var(--glass-border);
      padding: 12px; color: white; border-radius: 4px; font-family: 'Inter', sans-serif; outline: none; resize: none;
    }
    .modal input {
      width: 100%; background: rgba(255,255,255,0.05); border: 1px solid var(--glass-border);
      padding: 12px; color: white; border-radius: 4px; font-family: 'Inter', sans-serif; outline: none;
    }
    .modal input:focus, .modal textarea:focus { border-color: var(--accent); }
    .tags-input { font-size: 12px; font-family: 'JetBrains Mono', monospace; color: var(--string); }
    
    .modal-actions { display: flex; justify-content: flex-end; gap: 8px; margin-top: 8px; }
    .btn-primary { background: var(--accent); color: #000; font-weight: 700; justify-content: center; }
    .btn-primary:hover { background: #6eff6e; }

    /* --- FACE MENU (NEW) --- */
    .face-menu {
        position: absolute; display: none; 
        background: rgba(15, 16, 20, 0.95); border: 1px solid var(--glass-border);
        border-radius: 8px; padding: 4px; z-index: 300;
        backdrop-filter: blur(12px); box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }
    .face-menu button {
        font-size: 12px; padding: 6px 12px; width: 100%;
    }
    .face-menu button:hover { color: var(--string); }

    /* HUD */
    .hud {
      position: fixed; bottom: 24px; left: 24px; 
      font-family: 'JetBrains Mono', monospace; font-size: 11px; color: rgba(255,255,255,0.4);
      pointer-events: none; line-height: 1.5;
    }
    .hud kbd { border: 1px solid rgba(255,255,255,0.2); padding: 1px 4px; border-radius: 3px; color: var(--accent); }

    .vignette {
      position: fixed; inset: 0; pointer-events: none; z-index: 50;
      background: radial-gradient(120% 90% at 50% 50%, #fff0 10%, rgb(15 16 20 / 0.8) 60%, rgb(15 16 20 / 1) 100%);
      opacity: 0.5;
    }
    body::after {
      content: ""; position: fixed; inset: 0; pointer-events: none; z-index: 49; opacity: 0.05;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.45'/%3E%3C/svg%3E");
    }
  </style>
</head>
<body>

  <canvas id="canvas"></canvas>

  <div class="vignette"></div>

  <div class="top-bar">
    <button id="modeExploreBtn" class="active"><span class="emoji">‚ú®</span> Explore</button>
    <button id="modeBuildBtn"><span class="emoji">üß±</span> Build</button>
    <button id="modeEditBtn"><span class="emoji">üìù</span> Edit</button>
    <button id="modeFocusBtn"><span class="emoji">üïØÔ∏è</span> Focus</button>
  </div>

  <div class="left-rail">
    <button id="microBtn"><span class="emoji">üîç</span> Micro</button>    
    <button id="macroBtn" class="active"><span class="emoji">üåê</span> Macro</button>
  </div>

  <div class="right-rail">
    <button id="impulseNudgeBtn" class="active"><span class="emoji">üëâ</span> Nudge</button>
    <button id="impulsePullBtn"><span class="emoji">üß≤</span> Pull</button>
    <button id="impulseBootBtn"><span class="emoji">ü•æ</span> Boot</button>
    <div class="power-display">PWR: <span id="powerVal" class="power-val">1</span>x</div>
  </div>

  <div class="hud">
    <div id="hudText">
      [L-Click] Interact<br>[R-Click] Context<br>[1-4] Power<br>[Space] Reset
    </div>
  </div>

  <div id="noteModal" class="modal-overlay">
    <div class="modal">
      <h3>Data Block Editor</h3>
      <input type="text" id="noteTitle" placeholder="Concept Title" autocomplete="off">
      <textarea id="noteContent" placeholder="Enter thoughts, definitions, or code..."></textarea>
      <input type="text" id="noteTags" class="tags-input" placeholder="#tags #connected" autocomplete="off">
      <div class="modal-actions">
        <button id="deleteNoteBtn" style="color: #ff4d4d;">Delete</button>
        <button id="cancelNoteBtn">Cancel</button>
        <button id="saveNoteBtn" class="btn-primary">Commit to Grid</button>
      </div>
    </div>
  </div>

  <div id="faceMenu" class="face-menu">
      <button id="spawnConnectedBtn">‚õìÔ∏è Spawn Linked Note</button>
      <button id="viewConnectionsBtn">üëÅÔ∏è Trace Strings</button>
  </div>

  <script>
    // === SETUP & CONSTANTS (PRESERVED) ===
    const CUBE_SIZE = 3.33;
    const NEON_GREEN = 0x39FF14;
    const NEON_PINK = 0xFF1493;
    const NEON_CYAN = 0x00FFFF;
    
    // Extended State
    let state = {
      interactionMode: 'explore', // explore | build | edit | focus
      currentGrid: 'macro',
      impulseType: 'nudge',
      powerLevel: 1,
      selectedCube: null,
      clipboard: null
    };

    // --- THREE.JS & SCENE INIT (PRESERVED) ---
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0f1014);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, -4, 34 * 0.44); 

    // Lighting (PRESERVED)
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const accentLight = new THREE.PointLight(NEON_PINK, 3, 20);
    accentLight.position.set(-8, 5, 10);
    scene.add(accentLight);

    const whiteLight = new THREE.PointLight(NEON_GREEN, 2, 100);
    whiteLight.position.set(8, 5, 10);
    scene.add(whiteLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
    mainLight.position.set(5, 15, 10);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 2048;
    mainLight.shadow.mapSize.height = 2048;
    const d = 30;
    mainLight.shadow.camera.left = -d; mainLight.shadow.camera.right = d;
    mainLight.shadow.camera.top = d; mainLight.shadow.camera.bottom = -d;
    scene.add(mainLight);

    const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256);
    const cubeCamera = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget);
    scene.add(cubeCamera);

    // Floor / Ground
    const groundGeo = new THREE.PlaneGeometry(800, 800);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x0f1014, roughness: 1, metalness: 0 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -6;
    ground.receiveShadow = true;
    scene.add(ground);

    const gridHelper = new THREE.GridHelper(200, 60, 0x222222, 0x111111);
    gridHelper.position.y = -5.99;
    scene.add(gridHelper);

    // Tile Cursor
    const cursorGeo = new THREE.PlaneGeometry(CUBE_SIZE, CUBE_SIZE);
    const cursorMat = new THREE.MeshBasicMaterial({ color: NEON_GREEN, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
    const tileCursor = new THREE.Mesh(cursorGeo, cursorMat);
    tileCursor.rotation.x = -Math.PI / 2;
    tileCursor.visible = false;
    scene.add(tileCursor);

    // Face Highlight (NEW EXTENSION)
    const faceHighlightGeo = new THREE.PlaneGeometry(CUBE_SIZE, CUBE_SIZE);
    const faceHighlightMat = new THREE.MeshBasicMaterial({ color: NEON_CYAN, transparent: true, opacity: 0.3, side: THREE.DoubleSide, depthTest: false });
    const faceHighlight = new THREE.Mesh(faceHighlightGeo, faceHighlightMat);
    faceHighlight.visible = false;
    scene.add(faceHighlight);

    // --- PHYSICS (CANNON.JS) (PRESERVED) ---
    const world = new CANNON.World();
    world.gravity.set(0, -19.81, 0);
    world.broadphase = new CANNON.NaiveBroadphase();
    const defaultMaterial = new CANNON.Material();
    const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, { friction: 0.3, restitution: 0.5 });
    world.addContactMaterial(defaultContactMaterial);

    const groundShape = new CANNON.Plane();
    const groundBody = new CANNON.Body({ mass: 0, material: defaultMaterial });
    groundBody.addShape(groundShape);
    groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
    groundBody.position.set(0, -6, 0);
    world.addBody(groundBody);

    // --- MATERIALS (PRESERVED) ---
    const neonGreenMaterial = new THREE.MeshPhysicalMaterial({
      color: NEON_GREEN, metalness: 0.8, roughness: 0.0, clearcoat: 1.0, emissive: NEON_GREEN, emissiveIntensity: 0.55, envMap: cubeRenderTarget.texture
    });
    const neonPinkMaterial = new THREE.MeshPhysicalMaterial({
      color: NEON_PINK, metalness: 0.1, roughness: 0.1, clearcoat: 1.0, emissive: NEON_PINK, emissiveIntensity: 0.6
    });
    const neonCyanMaterial = new THREE.MeshPhysicalMaterial({
      color: NEON_CYAN, metalness: 0.1, roughness: 0.1, clearcoat: 1.0, emissive: NEON_CYAN, emissiveIntensity: 0.6
    });

    // --- NOTE SYSTEM EXTENSIONS ---
    let blocks = []; // Array of { mesh, body, id, data, links }
    let visualLinks = []; // Array of line meshes
    
    function snapToGrid(val) { return Math.round(val / CUBE_SIZE) * CUBE_SIZE; }

    // === STRING THEORY: VISUAL LINKS ===
    class LinkManager {
        static createLink(blockA, blockB, type = 'string') {
            // 1. Physics Constraint (Reuse PointToPoint for "string" feel)
            // Using a loose constraint to simulate string tension
            const constraint = new CANNON.DistanceConstraint(blockA.body, blockB.body, CUBE_SIZE * 1.5, 100);
            world.addConstraint(constraint);

            // 2. Visual Mesh
            const material = new THREE.LineBasicMaterial({ color: NEON_CYAN, opacity: 0.6, transparent: true });
            const points = [blockA.mesh.position, blockB.mesh.position];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            scene.add(line);

            // 3. Store Data
            const linkData = { mesh: line, bodyA: blockA.body, bodyB: blockB.body, constraint: constraint };
            visualLinks.push(linkData);
            
            // Bidirectional refs
            if(!blockA.links) blockA.links = [];
            if(!blockB.links) blockB.links = [];
            blockA.links.push(blockB.id);
            blockB.links.push(blockA.id);
        }

        static update() {
            visualLinks.forEach(link => {
                const posA = link.bodyA.position;
                const posB = link.bodyB.position;
                const positions = new Float32Array([posA.x, posA.y, posA.z, posB.x, posB.y, posB.z]);
                link.mesh.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                link.mesh.geometry.attributes.position.needsUpdate = true;
            });
        }
    }

    // === CUBE CREATION (EXTENDED) ===
    function createBlock(x, z, yOffset = 0, linkedFrom = null, customData = null) {
      const startY = -6 + (CUBE_SIZE / 2) + yOffset;
      
      const geo = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
      const mat = linkedFrom ? neonCyanMaterial.clone() : neonGreenMaterial.clone();
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x, startY, z);
      mesh.castShadow = true; mesh.receiveShadow = true;
      scene.add(mesh);

      const shape = new CANNON.Box(new CANNON.Vec3(CUBE_SIZE/2, CUBE_SIZE/2, CUBE_SIZE/2));
      const body = new CANNON.Body({ mass: 2, material: defaultMaterial });
      body.addShape(shape);
      body.position.set(x, startY, z);
      body.linearDamping = 0.3; body.angularDamping = 0.3;
      world.addBody(body);

      // EXTENDED DATA PAYLOAD
      const block = { 
          mesh, body, id: Date.now() + Math.random(),
          links: [],
          data: customData || { 
              title: "Untitled Node", 
              content: "", 
              tags: [], 
              created: new Date().toISOString() 
          }
      };
      
      blocks.push(block);

      // Auto-link if spawned from another
      if (linkedFrom) {
          LinkManager.createLink(linkedFrom, block);
      } else {
          // Legacy magnetic stacking (PRESERVED LOGIC)
          checkAndLinkNeighbors(block);
      }

      // Boot effect
      gsap.from(mesh.scale, { x: 0, y: 0, z: 0, duration: 0.4, ease: "back.out(1.7)" });

      return block;
    }

    // (PRESERVED) Legacy Stacking Logic
    function checkAndLinkNeighbors(newBlock) {
      const range = CUBE_SIZE * 1.1;
      blocks.forEach(other => {
        if (other === newBlock) return;
        const dist = newBlock.body.position.distanceTo(other.body.position);
        if (dist < range) {
          const constraint = new CANNON.LockConstraint(newBlock.body, other.body);
          world.addConstraint(constraint);
        }
      });
    }

    // === INTERACTION SYSTEM (EXTENDED) ===
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredTile = { x: 0, z: 0 };
    let lastHitFace = null;
    let lastHitBlock = null;

    window.addEventListener('mousemove', (e) => {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      
      // Face Highlight Logic (BUILD MODE ONLY)
      faceHighlight.visible = false;
      const blockIntersects = raycaster.intersectObjects(blocks.map(b => b.mesh));
      
      if (blockIntersects.length > 0) {
          const hit = blockIntersects[0];
          lastHitBlock = blocks.find(b => b.mesh === hit.object);
          
          if (state.interactionMode === 'build' || state.interactionMode === 'edit') {
              // Calculate Face Normal in World Space
              const normal = hit.face.normal.clone().applyQuaternion(hit.object.quaternion).round();
              // Position highlight slightly off the face
              const offset = normal.clone().multiplyScalar(CUBE_SIZE * 0.51);
              faceHighlight.position.copy(hit.object.position).add(offset);
              // Rotate highlight to match face orientation
              faceHighlight.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), normal);
              faceHighlight.visible = true;
              lastHitFace = normal;
          }
      } else {
          lastHitBlock = null;
          lastHitFace = null;
      }

      // Tile Cursor (PRESERVED)
      const intersects = raycaster.intersectObject(ground);
      if (intersects.length > 0) {
        const p = intersects[0].point;
        hoveredTile.x = snapToGrid(p.x);
        hoveredTile.z = snapToGrid(p.z);
        tileCursor.position.set(hoveredTile.x, -5.9, hoveredTile.z);
        tileCursor.visible = (state.interactionMode === 'explore' || state.interactionMode === 'build');
      }

      // Camera Tilt (PRESERVED)
      const targetRotX = (e.clientY / window.innerHeight - 0.5) * 0.2;
      const targetRotY = (e.clientX / window.innerWidth - 0.5) * 0.2;
      gsap.to(scene.rotation, { x: targetRotX, y: targetRotY, duration: 1 });
    });

    window.addEventListener('mousedown', (e) => {
      if (e.target.closest('button') || e.target.closest('.modal') || e.target.closest('.modal-overlay') || e.target.closest('.face-menu')) return;
      
      // Hide context menu on global click
      document.getElementById('faceMenu').style.display = 'none';

      if (lastHitBlock) {
          if (state.interactionMode === 'explore') {
              applyImpulse(lastHitBlock);
          } 
          else if (state.interactionMode === 'build') {
              if (lastHitFace) {
                  // Show Face Context Menu
                  showFaceMenu(e.clientX, e.clientY);
              }
          }
          else if (state.interactionMode === 'edit') {
              openEditor(lastHitBlock);
          }
          else if (state.interactionMode === 'focus') {
              focusOnBlock(lastHitBlock);
          }
      } else {
          // Ground Click
          if (state.interactionMode === 'build' || state.interactionMode === 'explore') {
              // Occupancy check
              const isOccupied = blocks.some(b => Math.abs(b.body.position.x - hoveredTile.x) < 1 && Math.abs(b.body.position.z - hoveredTile.z) < 1);
              openEditor(null, hoveredTile.x, hoveredTile.z, isOccupied);
          }
      }
    });

    // === NEW LOGIC: FACE MENU ===
    function showFaceMenu(x, y) {
        const menu = document.getElementById('faceMenu');
        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
        menu.style.display = 'block';
        
        // Context Action 1: Spawn Linked
        document.getElementById('spawnConnectedBtn').onclick = () => {
            if (lastHitBlock && lastHitFace) {
                const spawnPos = new THREE.Vector3().copy(lastHitBlock.mesh.position).add(lastHitFace.multiplyScalar(CUBE_SIZE * 1.5)); // distance constraint gap
                createBlock(spawnPos.x, spawnPos.z, spawnPos.y - (-6 + CUBE_SIZE/2), lastHitBlock);
                menu.style.display = 'none';
            }
        };

        // Context Action 2: View Connections (Placeholder for visual flair)
        document.getElementById('viewConnectionsBtn').onclick = () => {
            // Pulse existing links
            gsap.to(visualLinks.map(l => l.mesh.material), { opacity: 1, duration: 0.2, yoyo: true, repeat: 3 });
            menu.style.display = 'none';
        };
    }

    // === PHYSICS IMPULSES (PRESERVED) ===
    function applyImpulse(block) {
      const forceMult = state.powerLevel;
      const body = block.body;
      body.wakeUp();

      if (state.impulseType === 'nudge') {
        const dir = new THREE.Vector3().subVectors(block.mesh.position, camera.position).normalize();
        dir.y = 0.2;
        const force = 15 * forceMult;
        body.applyImpulse(new CANNON.Vec3(dir.x * force, dir.y * force, dir.z * force), body.position);
      } else if (state.impulseType === 'pull') {
        const dir = new THREE.Vector3().subVectors(camera.position, block.mesh.position).normalize();
        dir.y = 0.1;
        const force = 10 * forceMult;
        body.applyImpulse(new CANNON.Vec3(dir.x * force, dir.y * force, dir.z * force), body.position);
      } else if (state.impulseType === 'boot') {
        const force = 80 * forceMult;
        body.applyImpulse(new CANNON.Vec3(0, force, -force * 0.5), body.position);
        body.angularVelocity.set(Math.random()*10, Math.random()*10, Math.random()*10);
      }
    }

    // === EDITOR UI LOGIC (EXTENDED) ===
    const modal = document.getElementById('noteModal');
    let editingBlock = null;
    let newBlockCoords = null;

    function openEditor(block, x, z, occupied) {
        modal.classList.add('open');
        editingBlock = block;
        newBlockCoords = { x, z, occupied };

        if (block) {
            document.getElementById('noteTitle').value = block.data.title;
            document.getElementById('noteContent').value = block.data.content;
            document.getElementById('noteTags').value = block.data.tags.join(' ');
            document.getElementById('deleteNoteBtn').style.display = 'block';
        } else {
            document.getElementById('noteTitle').value = '';
            document.getElementById('noteContent').value = '';
            document.getElementById('noteTags').value = '';
            document.getElementById('deleteNoteBtn').style.display = 'none';
        }
        
        setTimeout(() => document.getElementById('noteTitle').focus(), 100);
    }

    document.getElementById('cancelNoteBtn').addEventListener('click', () => modal.classList.remove('open'));
    
    document.getElementById('saveNoteBtn').addEventListener('click', () => {
        const title = document.getElementById('noteTitle').value || "Untitled";
        const content = document.getElementById('noteContent').value;
        const tags = document.getElementById('noteTags').value.split(' ').filter(t => t);
        
        const newData = { title, content, tags, modified: new Date().toISOString() };

        if (editingBlock) {
            // Update Existing
            editingBlock.data = newData;
            // Visual feedback: flash white
            editingBlock.mesh.material.emissive.setHex(0xffffff);
            gsap.to(editingBlock.mesh.material.emissive, { r:0, g:1, b:1, duration: 1 }); // settle to cyan if edited
        } else if (newBlockCoords) {
            // Create New
            let yOffset = 0;
            // Basic stacking height calc
            if (newBlockCoords.occupied) {
                let maxY = -100;
                blocks.forEach(b => {
                    if (Math.abs(b.body.position.x - newBlockCoords.x) < 1 && Math.abs(b.body.position.z - newBlockCoords.z) < 1) {
                        if (b.body.position.y > maxY) maxY = b.body.position.y;
                    }
                });
                if (maxY > -100) yOffset = maxY + 6;
            }
            createBlock(newBlockCoords.x, newBlockCoords.z, yOffset, null, newData);
        }
        modal.classList.remove('open');
    });

    document.getElementById('deleteNoteBtn').addEventListener('click', () => {
        if (editingBlock) {
            scene.remove(editingBlock.mesh);
            world.remove(editingBlock.body);
            blocks = blocks.filter(b => b !== editingBlock);
            // Also remove links associated? (Simplified: leave visuals for now or clear)
        }
        modal.classList.remove('open');
    });

    // === MODE & UI HANDLERS ===
    function setMode(m) {
        state.interactionMode = m;
        ['Explore','Build','Edit','Focus'].forEach(key => {
            const btn = document.getElementById(`mode${key}Btn`);
            if (m === key.toLowerCase()) {
                btn.classList.add('active');
                if (m === 'build') btn.classList.add('mode-build');
                if (m === 'edit') btn.classList.add('mode-active');
            } else {
                btn.classList.remove('active', 'mode-active', 'mode-build');
            }
        });
        
        // Update HUD
        const hud = document.getElementById('hudText');
        if (m === 'explore') hud.innerHTML = "[L-Click] Impulse<br>[1-4] Power<br>[Space] Reset";
        if (m === 'build') hud.innerHTML = "[L-Click Face] Spawn Link<br>[L-Click Floor] New Note";
        if (m === 'edit') hud.innerHTML = "[L-Click Block] Edit Data";
        if (m === 'focus') hud.innerHTML = "[L-Click] Spotlight Note";
    }

    document.getElementById('modeExploreBtn').onclick = () => setMode('explore');
    document.getElementById('modeBuildBtn').onclick = () => setMode('build');
    document.getElementById('modeEditBtn').onclick = () => setMode('edit');
    document.getElementById('modeFocusBtn').onclick = () => setMode('focus');

    // Keydown for Power Levels (PRESERVED)
    window.addEventListener('keydown', (e) => {
        if(['1','2','3','4'].includes(e.key)) {
            state.powerLevel = parseInt(e.key);
            document.getElementById('powerVal').innerText = e.key;
        }
    });

    // Impulse Toggles (PRESERVED)
    const impBtns = { nudge: 'impulseNudgeBtn', pull: 'impulsePullBtn', boot: 'impulseBootBtn' };
    Object.keys(impBtns).forEach(k => {
        document.getElementById(impBtns[k]).onclick = () => {
            state.impulseType = k;
            Object.values(impBtns).forEach(id => document.getElementById(id).classList.remove('active'));
            document.getElementById(impBtns[k]).classList.add('active');
        };
    });

    // Camera Presets (PRESERVED)
    document.getElementById('microBtn').onclick = () => {
        gsap.to(camera.position, { y: -6 + (10/2.5), z: 21, duration: 1 });
        gsap.to(camera.rotation, { x: 0.2, duration: 1 });
    };
    document.getElementById('macroBtn').onclick = () => {
        gsap.to(camera.position, { y: -4, z: 34 * 0.44, duration: 1 });
        gsap.to(camera.rotation, { x: 0, duration: 1 });
    };

    // === ANIMATION LOOP (EXTENDED) ===
    const fixedTimeStep = 1.0 / 60.0;
    function animate() {
      requestAnimationFrame(animate);
      world.step(fixedTimeStep);

      // 1. Sync Physics -> Mesh (PRESERVED)
      blocks.forEach(({ mesh, body }) => {
        mesh.position.copy(body.position);
        mesh.quaternion.copy(body.quaternion);
      });

      // 2. Update Strings (NEW HOOK)
      LinkManager.update();

      cubeCamera.update(renderer, scene);
      renderer.render(scene, camera);
    }

    animate();

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

  </script>
</body>
</html>
